[
["index.html", "Aplicações práticas do software R para Agronomia 1 Gráficos em R", " Aplicações práticas do software R para Agronomia Gabriel Danilo Shimizu 2020-05-12 1 Gráficos em R "],
["gráfico-de-colunas.html", " 2 Gráfico de Colunas 2.1 Conjunto de dados 2.2 Adicionando melhorias 2.3 Barras de desvio-padrão 2.4 Unidade do eixo Y 2.5 Média dos tratamentos 2.6 Separação de casa decimal 2.7 Letras do teste de comparação 2.8 Pacote Agricolae 2.9 Pacote ggplot2 e ggpubr 2.10 Utilizando o ggplot2 2.11 Pacote ggpubr 2.12 Duas variáveis categóricas 2.13 Colunas empilhadas 2.14 Dois lados com escala positiva", " 2 Gráfico de Colunas O gráfico em colunas consiste em construir retângulos, em que uma das dimensões é proporcional à magnitude a ser representada (\\(n_i\\) ou \\(f_i\\)), sendo a outra arbitrária, porém igual para todas as colunas. Essas colunas são dispostas paralelamente umas às outras de forma vertical. Além do título e fonte de referências deve-se observar o seguinte: as colunas devem ter todas a mesma largura; a distância entre as colunas deve ser constante e de preferência menor que a largura das colunas. 2.1 Conjunto de dados tratamentos=rep(c(paste(&quot;T&quot;,1:5)),e=4) resposta=c(100,120,110,90,150,145,149,165,150,144,134,139,220,206,210,210,266,249,248,260) ## Média e Desvio-padrão (Por Tratamento) media=tapply(resposta,tratamentos, mean) desvio=tapply(resposta,tratamentos,sd) barplot(media) 2.2 Adicionando melhorias barplot(media, las=1, col=&quot;lightyellow&quot;, ylab=&quot;Resposta&quot;, xlab=&quot;Tratamentos&quot;, ylim=c(0,300)) abline(h=0) Comandos: las=1: deixar escala do eixo Y na vertical col=“cor”: mudar cor das barras (Ex. “red”,“blue”,“green” ou gray.colors(quantidade de tonalidades) para escala cinza ou rainbow(quantidade de cores) para escala colorida. Também é possível específicar a cor de cada barra (col=c(“red”,“green”,“yellow”,“gray”,“blue”))). xlab e ylab: nomear eixo X e Y xlim e ylim: escala do eixo X e Y abline(h=0): linha na horizontal em Y=0 (No caso de vertical, abline(v=0)). É possível alterar a cor pela função “col=”cor\"\" e o tracejado pelo “lty=número” (Ver o Help do comando) 2.3 Barras de desvio-padrão bar=barplot(media, las=1, col=&quot;lightyellow&quot;, ylab=&quot;Resposta&quot;, xlab=&quot;Tratamentos&quot;, ylim=c(0,300)) abline(h=0) arrows(bar,media+desvio,bar,media-desvio,length = 0.1,angle=90,code=3) 2.4 Unidade do eixo Y (Ex. \\(Kg\\ ha^{-1}\\)) bar=barplot(media, las=1, col=&quot;lightyellow&quot;, ylab=expression(&quot;Resposta&quot;*&quot; &quot;*(kg*&quot; &quot;*ha^-1)), xlab=&quot;Tratamentos&quot;, ylim=c(0,300)) abline(h=0) arrows(bar,media+desvio,bar,media-desvio,length = 0.1,angle=90,code=3) 2.5 Média dos tratamentos bar=barplot(media, las=1, col=&quot;lightyellow&quot;, ylab=expression(&quot;Resposta&quot;*&quot; &quot;*(kg*&quot; &quot;*ha^-1)), xlab=&quot;Tratamentos&quot;, ylim=c(0,300)) abline(h=0) text(bar,media+desvio+10,media) arrows(bar,media+desvio,bar,media-desvio,length = 0.1,angle=90,code=3) 2.6 Separação de casa decimal options(OutDec=&quot;,&quot;) bar=barplot(media, las=1, col=&quot;lightyellow&quot;, ylab=expression(&quot;Resposta&quot;*&quot; &quot;*(kg*&quot; &quot;*ha^-1)), xlab=&quot;Tratamentos&quot;, ylim=c(0,300)) abline(h=0) text(bar,media+desvio+10,media) arrows(bar,media+desvio,bar,media-desvio,length = 0.1,angle=90,code=3) 2.7 Letras do teste de comparação tukey=c(&quot;d&quot;,&quot;c&quot;,&quot;c&quot;,&quot;b&quot;,&quot;a&quot;) options(OutDec=&quot;,&quot;) bar=barplot(media, las=1, col=&quot;lightyellow&quot;, ylab=expression(&quot;Resposta&quot;*&quot; &quot;*(kg*&quot; &quot;*ha^-1)), xlab=&quot;Tratamentos&quot;, ylim=c(0,300)) abline(h=0) text(bar,media+desvio+10,paste(round(media,0),tukey)) arrows(bar,media+desvio,bar,media-desvio,length = 0.1,angle=90,code=3) 2.8 Pacote Agricolae 2.8.1 Conjunto de dados tratamentos=rep(c(paste(&quot;T&quot;,1:5)),e=4) resposta=c(100,120,110,90,150,145,149,165,150,144,134,139,220,206,210,210,266,249,248,260) 2.8.2 Modelo de Anova modelo=aov(resposta~tratamentos) library(agricolae) a=HSD.test(modelo,&quot;tratamentos&quot;, group = T) 2.8.3 Gráfico com média plot(a, las=1) 2.8.4 Gráfico de barras bar.group(a$groups, col=&quot;lightblue&quot;, las=1, ylim=c(0,300)) abline(h=0) 2.8.5 Barras de desvio-padrão bar.err(a$means, variation=&quot;SD&quot;, col=&quot;lightblue&quot;, las=1, ylim=c(0,300)) abline(h=0) 2.8.6 Barras de erro padrão bar.err(a$means, variation=&quot;SE&quot;, col=&quot;lightblue&quot;, las=1, ylim=c(0,300)) abline(h=0) 2.8.7 Barras de máximo-mínimo bar.err(a$means, variation=&quot;range&quot;, col=&quot;lightblue&quot;, las=1, ylim=c(0,300)) abline(h=0) 2.8.8 Barras da distância interquartil bar.err(a$means, variation=&quot;IQR&quot;, col=&quot;lightblue&quot;, las=1, ylim=c(0,300)) abline(h=0) 2.9 Pacote ggplot2 e ggpubr 2.9.1 Conjunto de dados Vamos trabalhar com três experimentos em DIC com quatro tratamentos e três repetições cada. exp1=c(10,12,13,18,19,16,5,6,5,25,26,28) exp2=c(9,12,11,18,20,16,7,6,9,25,28,28) exp3=c(9,12,13,18,22,15,3,6,4,25,30,28) Trat=rep(c(paste(&quot;T&quot;,1:4)),e=3) dados=data.frame(Trat,exp1,exp2,exp3) dados$Trat=as.factor(Trat) Obs. Para facilitar, vamos realizar a análise direto pelo pacote ExpDes.pt (é necessário instalar o pacote) 2.9.2 Análise de exp1 ExpDes.pt::dic(Trat,exp1) ## ------------------------------------------------------------------------ ## Quadro da analise de variancia ## ------------------------------------------------------------------------ ## GL SQ QM Fc Pr&gt;Fc ## Tratamento 3 719,58 130,83 3,8864e-07 ## Residuo 8 14,67 ## Total 11 734,25 ## ------------------------------------------------------------------------ ## CV = 8,88 % ## ## ------------------------------------------------------------------------ ## Teste de normalidade dos residuos ## Valor-p: 0,3563889 ## De acordo com o teste de Shapiro-Wilk a 5% de significancia, os residuos podem ser considerados normais. ## ------------------------------------------------------------------------ ## ## ------------------------------------------------------------------------ ## Teste de homogeneidade de variancia ## valor-p: 0,6539247 ## De acordo com o teste de bartlett a 5% de significancia, as variancias podem ser consideradas homogeneas. ## ------------------------------------------------------------------------ ## ## Teste de Tukey ## ------------------------------------------------------------------------ ## Grupos Tratamentos Medias ## a T 4 26,33333 ## b T 2 17,66667 ## c T 1 11,66667 ## d T 3 5,333333 ## ------------------------------------------------------------------------ 2.9.3 Análise de exp2 ExpDes.pt::dic(Trat,exp2) ## ------------------------------------------------------------------------ ## Quadro da analise de variancia ## ------------------------------------------------------------------------ ## GL SQ QM Fc Pr&gt;Fc ## Tratamento 3 684,92 78,276 2,8606e-06 ## Residuo 8 23,33 ## Total 11 708,25 ## ------------------------------------------------------------------------ ## CV = 10,84 % ## ## ------------------------------------------------------------------------ ## Teste de normalidade dos residuos ## Valor-p: 0,2365244 ## De acordo com o teste de Shapiro-Wilk a 5% de significancia, os residuos podem ser considerados normais. ## ------------------------------------------------------------------------ ## ## ------------------------------------------------------------------------ ## Teste de homogeneidade de variancia ## valor-p: 0,9823917 ## De acordo com o teste de bartlett a 5% de significancia, as variancias podem ser consideradas homogeneas. ## ------------------------------------------------------------------------ ## ## Teste de Tukey ## ------------------------------------------------------------------------ ## Grupos Tratamentos Medias ## a T 4 27 ## b T 2 18 ## c T 1 10,66667 ## c T 3 7,333333 ## ------------------------------------------------------------------------ 2.9.4 Análise de exp3 ExpDes.pt::dic(Trat,exp3) ## ------------------------------------------------------------------------ ## Quadro da analise de variancia ## ------------------------------------------------------------------------ ## GL SQ QM Fc Pr&gt;Fc ## Tratamento 3 894,25 47,066 1,9902e-05 ## Residuo 8 50,67 ## Total 11 944,92 ## ------------------------------------------------------------------------ ## CV = 16,32 % ## ## ------------------------------------------------------------------------ ## Teste de normalidade dos residuos ## Valor-p: 0,9419794 ## De acordo com o teste de Shapiro-Wilk a 5% de significancia, os residuos podem ser considerados normais. ## ------------------------------------------------------------------------ ## ## ------------------------------------------------------------------------ ## Teste de homogeneidade de variancia ## valor-p: 0,7583526 ## De acordo com o teste de bartlett a 5% de significancia, as variancias podem ser consideradas homogeneas. ## ------------------------------------------------------------------------ ## ## Teste de Tukey ## ------------------------------------------------------------------------ ## Grupos Tratamentos Medias ## a T 4 27,66667 ## b T 2 18,33333 ## c T 1 11,33333 ## d T 3 4,333333 ## ------------------------------------------------------------------------ 2.10 Utilizando o ggplot2 library(ggplot2) library(gridExtra) 2.10.1 Média e desvio-padrão media=tapply(exp1, Trat, mean) desvio=tapply(exp1, Trat, sd) ## Construindo uma nova data.frame com a media e desvio dados1=data.frame(Trat=rownames(media),media,desvio) 2.10.2 Gráfico básico ggplot(dados1, aes(x=Trat,y=media))+ geom_col() 2.10.3 Média no gráfico ggplot(dados1, aes(x=Trat,y=media))+ geom_col()+ geom_text(label=round(media,1), vjust=-1) # Obs. Round é para arrendondar o valor, neste caso estamos pedindo até a primeira casa decimal 2.10.4 Letras do teste de comparação ggplot(dados1, aes(x=Trat,y=media))+ geom_col()+ geom_text(label=paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), vjust=-1) #Obs. a função paste serve para juntar palavras, nesse caso está juntando cada média com suas respectivas letras do teste de comparação de médias 2.10.5 Escala do eixo Y ggplot(dados1, aes(x=Trat,y=media))+ geom_col()+ geom_text(label=paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), vjust=-1)+ ylim(c(0,40)) 2.10.6 Cor das colunas ggplot(dados1, aes(x=Trat,y=media))+ geom_col(fill=c(1,2,3,4))+ geom_text(label=paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), vjust=-1)+ ylim(c(0,40)) 2.10.7 Removendo cor de fundo ggplot(dados1, aes(x=Trat,y=media))+ geom_col(fill=c(1,2,3,4))+ geom_text(label=paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), vjust=-1)+ ylim(c(0,40))+ theme_bw() 2.10.8 Removendo linhas de grade ggplot(dados1, aes(x=Trat,y=media))+ geom_col(fill=c(1,2,3,4))+ geom_text(label=paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), vjust=-1)+ ylim(c(0,40))+ theme_bw()+ theme_classic() 2.10.9 Nome dos eixos X e Y Obs. A função expression() funciona nesses argumentos. ggplot(dados1, aes(x=Trat,y=media))+ geom_col(fill=c(1,2,3,4))+ geom_text(label=paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), vjust=-1)+ ylim(c(0,40))+ theme_bw()+ theme_classic()+ ylab(&quot;Resposta&quot;)+ xlab(&quot; &quot;) 2.10.10 Cor do contorno das colunas ggplot(dados1, aes(x=Trat,y=media))+ geom_col(fill=c(1,2,3,4),col=&quot;black&quot;)+ # Modifiquei aqui geom_text(label=paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), vjust=-1)+ ylim(c(0,40))+ theme_bw()+ theme_classic()+ ylab(&quot;Resposta&quot;)+ xlab(&quot; &quot;) 2.10.11 Barras de desvio-padrão ggplot(dados1, aes(x=Trat,y=media))+ geom_col(fill=c(1,2,3,4),col=&quot;black&quot;)+ geom_text(label=paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), vjust=-2)+ ylim(c(0,40))+ theme_bw()+ theme_classic()+ ylab(&quot;Resposta&quot;)+ xlab(&quot; &quot;)+ geom_errorbar(aes(ymax=media+desvio,ymin=media-desvio), width=0.25) # Width é a largura da barra 2.10.12 Juntando os gráficos Obs. Vamos chamar todo o plot de cada uma das variáveis de a,b,c, respectivamente. 2.10.13 Variável exp1 media=tapply(exp1, Trat, mean) desvio=tapply(exp1, Trat, sd) dados1=data.frame(Trat=rownames(media),media,desvio) a=ggplot(dados1, aes(x=Trat,y=media))+ geom_col(fill=c(1,2,3,4),col=&quot;black&quot;)+ geom_text(label=paste(round(media,1), c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), vjust=-3)+ ylim(c(0,40))+theme_bw()+theme_classic()+ylab(&quot;Resposta&quot;)+xlab(&quot; &quot;)+ geom_errorbar(aes(ymax=media+desvio, ymin=media-desvio), width=0.25) 2.10.14 Variável exp2 media=tapply(exp2, Trat, mean) desvio=tapply(exp2, Trat, sd) dados2=data.frame(Trat=rownames(media),media,desvio) b=ggplot(dados2, aes(x=Trat,y=media))+ geom_col(fill=c(1,2,3,4),col=&quot;black&quot;)+ geom_text(label=paste(round(media,1), c(&quot;c&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;)), vjust=-3)+ ylim(c(0,40))+theme_bw()+theme_classic()+ylab(&quot;Resposta&quot;)+xlab(&quot; &quot;)+ geom_errorbar(aes(ymax=media+desvio, ymin=media-desvio), width=0.25) 2.10.15 Variável exp3 media=tapply(exp3, Trat, mean) desvio=tapply(exp3, Trat, sd) dados3=data.frame(Trat=rownames(media),media,desvio) c=ggplot(dados3, aes(x=Trat,y=media))+ geom_col(fill=c(1,2,3,4),col=&quot;black&quot;)+ geom_text(label=paste(round(media,1), c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), vjust=-4)+ ylim(c(0,40))+theme_bw()+theme_classic()+ylab(&quot;Resposta&quot;)+xlab(&quot; &quot;)+ geom_errorbar(aes(ymax=media+desvio, ymin=media-desvio), width=0.25) grid.arrange(a,b,c,ncol=3) 2.11 Pacote ggpubr Obs. Existem vários packages que utilizam o ggplot2 e geram saídas similares, contudo, com argumentos dos comandos mais simples. exp1=c(10,12,13,18,19,16,5,6,5,25,26,28) exp2=c(9,12,11,18,20,16,7,6,9,25,28,28) exp3=c(9,12,13,18,22,15,3,6,4,25,30,28) Trat=rep(c(paste(&quot;T&quot;,1:4)),e=3) dados=data.frame(Trat,exp1,exp2,exp3) dados$Trat=as.factor(Trat) library(ggpubr) library(gridExtra) 2.11.1 Comando base ggbarplot(dados, x = &quot;Trat&quot;, y = &quot;exp1&quot;, add=&quot;mean&quot;) 2.11.2 Barras de desvio-padrão ggbarplot(dados, x = &quot;Trat&quot;, y = &quot;exp1&quot;, add = &quot;mean_sd&quot;) 2.11.3 Cor da coluna ggbarplot(dados, x = &quot;Trat&quot;, y = &quot;exp1&quot;, add = &quot;mean_sd&quot;, fill = &quot;Trat&quot;) ggbarplot(dados, x = &quot;Trat&quot;, y = &quot;exp1&quot;, add = &quot;mean_sd&quot;, fill = &quot;Trat&quot;, palette = c(1,2,3,4)) 2.11.4 Letra do teste de comparação ggbarplot(dados, x = &quot;Trat&quot;, y = &quot;exp1&quot;, add = &quot;mean_sd&quot;, fill = &quot;Trat&quot;, label = c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;), lab.vjust=-2) 2.11.5 Adicionando a média media=tapply(exp1,Trat,mean) ggbarplot(dados, x = &quot;Trat&quot;, y = &quot;exp1&quot;, add = &quot;mean_sd&quot;, fill = &quot;Trat&quot;, label = paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;)), lab.vjust=-2) 2.11.6 Escala do eixo Y ggbarplot(dados, x = &quot;Trat&quot;, y = &quot;exp1&quot;, add = &quot;mean_sd&quot;, fill = &quot;Trat&quot;, label = paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), lab.vjust=-2)+ylim(c(0,40)) 2.11.7 Removendo legenda ggbarplot(dados, x = &quot;Trat&quot;, y = &quot;exp1&quot;, add = &quot;mean_sd&quot;, fill = &quot;Trat&quot;, label = paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), lab.vjust=-2, legend=&quot;n&quot;)+ylim(c(0,40)) 2.11.8 Juntando os gráficos 2.11.9 Variável exp1 media=tapply(exp1,Trat,mean) a=ggbarplot(dados, x = &quot;Trat&quot;, y = &quot;exp1&quot;, add = &quot;mean_sd&quot;, fill = &quot;Trat&quot;, label = paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), lab.vjust=-3, legend=&quot;n&quot;)+ylim(c(0,40)) 2.11.10 Variável exp2 media=tapply(exp2,Trat,mean) b=ggbarplot(dados, x = &quot;Trat&quot;, y = &quot;exp2&quot;, add = &quot;mean_sd&quot;, fill = &quot;Trat&quot;, label = paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), lab.vjust=-3, legend=&quot;n&quot;)+ylim(c(0,40)) 2.11.11 Variável exp3 media=tapply(exp3,Trat,mean) c=ggbarplot(dados, x = &quot;Trat&quot;, y = &quot;exp3&quot;, add = &quot;mean_sd&quot;, fill = &quot;Trat&quot;, label = paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), lab.vjust=-3, legend=&quot;n&quot;)+ylim(c(0,40)) grid.arrange(a,b,c,ncol=3) Como deixar apenas o gráfico a esquerda com a escala de Y? Existem casos em que uma mesma variável foi analisada em várias situações e dessa forma, geramos gráficos com a mesma unidade de medida. Nesse sentido, é frequente apresentar apenas uma escala de Y, geralmente o gráfico a esquerda. No pacote ggpubr, podemos efetuar da seguinte forma: media=tapply(exp1,Trat,mean) a=ggbarplot(dados, x = &quot;Trat&quot;, y = &quot;exp1&quot;, add = &quot;mean_sd&quot;, fill = &quot;Trat&quot;, ylab=&quot;Resposta&quot;, label = paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), lab.vjust=-3, legend=&quot;n&quot;)+ylim(c(0,40)) media=tapply(exp2,Trat,mean) b=ggbarplot(dados, x = &quot;Trat&quot;, y = &quot;exp2&quot;, add = &quot;mean_sd&quot;, fill = &quot;Trat&quot;, label = paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;)), lab.vjust=-3, legend=&quot;n&quot;, yscale=&quot;n&quot;)+ ylim(c(0,40))+ theme(axis.text.y=element_blank())+ # Comando para remover os números da escala de Y ylab(&quot;&quot;) # Remover nome do eixo Y media=tapply(exp3,Trat,mean) c=ggbarplot(dados, x = &quot;Trat&quot;, y = &quot;exp3&quot;, add = &quot;mean_sd&quot;, fill = &quot;Trat&quot;, label = paste(round(media,1),c(&quot;c&quot;,&quot;b&quot;,&quot;d&quot;,&quot;a&quot;)), lab.vjust=-4, legend=&quot;n&quot;)+ ylim(c(0,40))+ theme(axis.text.y=element_blank())+ ylab(&quot;&quot;) grid.arrange(a,b,c,ncol=3) 2.12 Duas variáveis categóricas 2.12.1 Conjunto de dados Fator1=factor(rep(c(paste(&quot;F&quot;,1:2)),e=20)) Fator2=factor(c(rep(c(paste(&quot;T&quot;,1:5)),e=4),rep(c(paste(&quot;T&quot;,1:5)),e=4))) resposta=c(100,120,110,90,150,145,149,165,250,244,220,239,220,206,210,210,266,249,248,260,110,130,120,100,160,165,169,175,160,154,144,149,230,216,220,220,276,259,258,270) dados=data.frame(Fator1,Fator2,resposta) ## Média e Desvio-padrão (Por Tratamento) media=with(dados, tapply(dados$resposta,list(Fator1, Fator2), mean)) desvio=with(dados, tapply(resposta,list(Fator1, Fator2), sd)) 2.12.2 Gráfico simples barplot(media, beside = T) O argumento beside=T é refente a um gráfico de barras em que as barras são posicionadas lado a lado. Do contrário, as barras serão empilhadas (stacked). 2.12.3 Melhorias barplot(media, beside = T, las=1, col=c(&quot;lawngreen&quot;,&quot;gold&quot;), ylab=&quot;Resposta&quot;, xlab=&quot;Fator2&quot;, ylim=c(0,300)) abline(h=0) Comandos: las=1: deixar escala do eixo Y na vertical col=“cor”: mudar cor das barras (Ex. “red”,“blue”,“green” ou gray.colors(quantidade de tonalidades) para escala cinza ou rainbow(quantidade de cores) para escala colorida. Também é possível específicar a cor de cada barra (col=c(“red”,“green”,“yellow”,“gray”,“blue”))). xlab e ylab: nomear eixo X e Y xlim e ylim: escala do eixo X e Y abline(h=0): linha na horizontal em Y=0 (No caso de vertical, abline(v=0)). É possível alterar a cor pela função “col=”cor\"\" e o tracejado pelo “lty=número” (Ver o Help do comando) 2.12.4 Cores barplot(1:21, col=c(&quot;red&quot;,&quot;white&quot;,&quot;black&quot;,&quot;lightyellow&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;orange&quot;, &quot;yellow&quot;,&quot;gray&quot;,&quot;pink&quot;,&quot;brown&quot;,&quot;Gainsboro&quot;, &quot;Lavender&quot;, &quot;DeepSkyBlue&quot;,&quot;LawnGreen&quot;, &quot;Gold&quot;,&quot;MediumOrchid&quot;, &quot;LightSalmon&quot;, &quot;Sienna&quot;, &quot;Tomato&quot;, &quot;DeepPink1&quot;)) 2.12.5 Barras de desvio-padrão bar=barplot(media,beside=T, las=1, ylab=&quot;Resposta&quot;, xlab=&quot;Tratamentos&quot;, ylim=c(0,300)) abline(h=0) arrows(bar,media+desvio,bar,media-desvio,length = 0.1,angle=90,code=3) 2.12.6 Unidade do eixo Y (Ex. \\(Kg\\ ha^{-1}\\)) bar=barplot(media, beside=T, las=1, ylab=expression(&quot;Resposta&quot;*&quot; &quot;*(kg*&quot; &quot;*ha^-1)), xlab=&quot;Tratamentos&quot;, ylim=c(0,300)) abline(h=0) arrows(bar,media+desvio,bar,media-desvio,length = 0.1,angle=90,code=3) 2.12.7 Média acima das barras bar=barplot(media, beside=T, las=1, ylab=expression(&quot;Resposta&quot;*&quot; &quot;*(kg*&quot; &quot;*ha^-1)), xlab=&quot;Tratamentos&quot;, ylim=c(0,300)) abline(h=0) text(bar,media+desvio+10,media, cex=0.8) arrows(bar,media+desvio,bar,media-desvio,length = 0.1,angle=90,code=3) 2.12.8 Separação de casa decimal options(OutDec=&quot;,&quot;) bar=barplot(media, beside=T, las=1, ylab=expression(&quot;Resposta&quot;*&quot; &quot;*(kg*&quot; &quot;*ha^-1)), xlab=&quot;Tratamentos&quot;, ylim=c(0,300)) abline(h=0) text(bar,media+desvio+10,media, cex=0.8) arrows(bar,media+desvio,bar,media-desvio,length = 0.1,angle=90,code=3) 2.12.9 Letras do teste de comparação tukey=c(&quot;dB&quot;,&quot;dA&quot;,&quot;cB&quot;,&quot;cA&quot;,&quot;cB&quot;,&quot;cA&quot;,&quot;bB&quot;,&quot;bA&quot;,&quot;aB&quot;,&quot;aA&quot;) options(OutDec=&quot;,&quot;) bar=barplot(media, beside=T, las=1, ylab=expression(&quot;Resposta&quot;*&quot; &quot;*(kg*&quot; &quot;*ha^-1)), xlab=&quot;Tratamentos&quot;, ylim=c(0,300)) abline(h=0) text(bar,media+desvio+10,paste(round(media,0),tukey), cex=0.8) arrows(bar,media+desvio,bar,media-desvio,length = 0.1,angle=90,code=3) 2.12.10 Adicionando legenda legend.text=rownames(media): adicionar a legenda (neste caso em relação ao Fator 2) args.legend: argumentos da legenda (x=“topleft”: legenda será adicionada no parte superior esquerda, podemos adicionar superior direito (“topright”), inferior esquerdo (“bottomleft”), inferior direito (“bottomright”), centralizado (“center”)) tukey=c(&quot;dB&quot;,&quot;dA&quot;,&quot;cB&quot;,&quot;cA&quot;,&quot;cB&quot;,&quot;cA&quot;,&quot;bB&quot;,&quot;bA&quot;,&quot;aB&quot;,&quot;aA&quot;) options(OutDec=&quot;,&quot;) bar=barplot(media, beside=T, legend.text = rownames(media), args.legend = list(x=&quot;topleft&quot;, bty=&quot;n&quot;), las=1, ylab=expression(&quot;Resposta&quot;*&quot; &quot;*(kg*&quot; &quot;*ha^-1)), xlab=&quot;Tratamentos&quot;, ylim=c(0,300)) abline(h=0) text(bar,media+desvio+10,paste(round(media,0),tukey), cex=0.8) arrows(bar,media+desvio,bar,media-desvio,length = 0.1,angle=90,code=3) 2.13 Colunas empilhadas 2.13.1 Conjunto de dados Fator1=factor(rep(c(paste(&quot;F&quot;,1:2)),e=20)) Fator2=factor(c(rep(c(paste(&quot;T&quot;,1:5)),e=4),rep(c(paste(&quot;T&quot;,1:5)),e=4))) resposta=c(100,120,110,90,150,145,149,165,250,244,220,239,220,206,210, 210,266,249,248,260,110,130,120,100,160,165,169,175,160,154, 144,149,230,216,220,220,276,259,258,270) dados=data.frame(Fator1,Fator2,resposta) ## Média e Desvio-padrão (Por Tratamento) media=with(dados, tapply(dados$resposta,list(Fator1, Fator2), mean)) desvio=with(dados, tapply(resposta,list(Fator1, Fator2), sd)) 2.13.2 Gráfico básico barplot(media, beside=F) O argumento beside=F é refente a um gráfico de barras em que as barras são posicionadas lado a lado. Do contrário, as barras serão empilhadas (stacked). 2.13.3 Melhorias barplot(media, beside=F, las=1, col=c(&quot;lawngreen&quot;,&quot;gold&quot;), ylab=&quot;Resposta&quot;, xlab=&quot;Fator2&quot;, ylim=c(0,600)) abline(h=0) Comandos: las=1: deixar escala do eixo Y na vertical col=“cor”: mudar cor das barras (Ex. “red”,“blue”,“green” ou gray.colors(quantidade de tonalidades) para escala cinza ou rainbow(quantidade de cores) para escala colorida. Também é possível específicar a cor de cada barra (col=c(“red”,“green”,“yellow”,“gray”,“blue”))). xlab e ylab: nomear eixo X e Y xlim e ylim: escala do eixo X e Y abline(h=0): linha na horizontal em Y=0 (No caso de vertical, abline(v=0)). É possível alterar a cor pela função “col=”cor\"\" e o tracejado pelo “lty=número” (Ver o Help do comando) 2.13.4 Barras de desvio-padrão bar=barplot(media,beside=F, las=1,col=c(&quot;lawngreen&quot;,&quot;gold&quot;), ylab=&quot;Resposta&quot;, xlab=&quot;Tratamentos&quot;, ylim=c(0,600)) abline(h=0) arrows(bar,media[1,]+desvio[1,],bar,media[1,]-desvio[1,],length = 0.1,angle=90,code=3) arrows(bar,media[1,]+media[2,]+desvio[2,],bar,media[1,]+media[2,]-desvio[2,],length = 0.1,angle=90,code=3) 2.13.5 Unidade do eixo Y (Ex. \\(Kg\\ ha^{-1}\\)) bar=barplot(media, beside=F, las=1,col=c(&quot;lawngreen&quot;,&quot;gold&quot;), ylab=expression(Resposta~~(kg~ha^-1)), xlab=&quot;Tratamentos&quot;, ylim=c(0,600)) abline(h=0) arrows(bar,media[1,]+desvio[1,],bar,media[1,]-desvio[1,],length = 0.1,angle=90,code=3) arrows(bar,media[1,]+media[2,]+desvio[2,],bar,media[1,]+media[2,]-desvio[2,],length = 0.1,angle=90,code=3) 2.13.6 Média acima das barras bar=barplot(media, beside=F, las=1,col=c(&quot;lawngreen&quot;,&quot;gold&quot;), ylab=expression(Resposta~~(kg~ha^-1)), xlab=&quot;Tratamentos&quot;, ylim=c(0,600)) abline(h=0) text(bar,media[1,]+desvio[1,]+20,media[1,], cex=0.8) text(bar,media[1,]+media[2,]+desvio[2,]+20,media[2,], cex=0.8) arrows(bar,media[1,]+desvio[1,],bar,media[1,]-desvio[1,],length = 0.1,angle=90,code=3) arrows(bar,media[1,]+media[2,]+desvio[2,],bar,media[1,]+media[2,]-desvio[2,],length = 0.1,angle=90,code=3) 2.13.7 Separação de casa decimal options(OutDec=&quot;,&quot;) bar=barplot(media, beside=F, las=1,col=c(&quot;lawngreen&quot;,&quot;gold&quot;), ylab=expression(Resposta~~(kg~ha^-1)), xlab=&quot;Tratamentos&quot;, ylim=c(0,600)) abline(h=0) text(bar,media[1,]+desvio[1,]+20,media[1,], cex=0.8) text(bar,media[1,]+media[2,]+desvio[2,]+20,media[2,], cex=0.8) arrows(bar,media[1,]+desvio[1,],bar,media[1,]-desvio[1,],length = 0.1,angle=90,code=3) arrows(bar,media[1,]+media[2,]+desvio[2,],bar,media[1,]+media[2,]-desvio[2,],length = 0.1,angle=90,code=3) 2.13.8 Letras do teste de comparação tukey=c(&quot;dB&quot;,&quot;dA&quot;,&quot;cB&quot;,&quot;cA&quot;,&quot;cB&quot;,&quot;cA&quot;,&quot;bB&quot;,&quot;bA&quot;,&quot;aB&quot;,&quot;aA&quot;) options(OutDec=&quot;,&quot;) bar=barplot(media, beside=F, las=1,col=c(&quot;lawngreen&quot;,&quot;gold&quot;), ylab=expression(Resposta~~(kg~ha^-1)), xlab=&quot;Tratamentos&quot;, ylim=c(0,600)) abline(h=0) text(bar,media[1,]+desvio[1,]+20,paste(media[1,], tukey[c(1,3,6,7,9)]), cex=0.8) text(bar,media[1,]+media[2,]+desvio[2,]+20,paste(media[2,], tukey[c(2,4,6,8,10)]), cex=0.8) arrows(bar,media[1,]+desvio[1,],bar,media[1,]-desvio[1,],length = 0.1,angle=90,code=3) arrows(bar,media[1,]+media[2,]+desvio[2,],bar,media[1,]+media[2,]-desvio[2,],length = 0.1,angle=90,code=3) 2.13.9 Adicionando legenda legend.text=rownames(media): adicionar a legenda (neste caso em relação ao Fator 2) args.legend: argumentos da legenda (x=“topleft”: legenda será adicionada no parte superior esquerda, podemos adicionar superior direito (“topright”), inferior esquerdo (“bottomleft”), inferior direito (“bottomright”), centralizado (“center”)) tukey=c(&quot;dB&quot;,&quot;dA&quot;,&quot;cB&quot;,&quot;cA&quot;,&quot;cB&quot;,&quot;cA&quot;,&quot;bB&quot;,&quot;bA&quot;,&quot;aB&quot;,&quot;aA&quot;) options(OutDec=&quot;,&quot;) bar=barplot(media, beside=F, legend.text = rownames(media), args.legend = list(x=&quot;topleft&quot;, bty=&quot;n&quot;), las=1,col=c(&quot;lawngreen&quot;,&quot;gold&quot;), ylab=expression(Resposta~(kg~ha^-1)), xlab=&quot;Tratamentos&quot;, ylim=c(0,600)) abline(h=0) text(bar,media[1,]+desvio[1,]+20,paste(media[1,], tukey[c(1,3,6,7,9)]), cex=0.8) text(bar,media[1,]+media[2,]+desvio[2,]+20,paste(media[2,], tukey[c(2,4,6,8,10)]), cex=0.8) arrows(bar,media[1,]+desvio[1,],bar,media[1,]-desvio[1,],length = 0.1,angle=90,code=3) arrows(bar,media[1,]+media[2,]+desvio[2,],bar,media[1,]+media[2,]-desvio[2,],length = 0.1,angle=90,code=3) 2.14 Dois lados com escala positiva 2.14.1 Conjunto de dados trat=rep(c(&quot;T1&quot;,&quot;T2&quot;,&quot;T3&quot;,&quot;T4&quot;,&quot;T5&quot;),e=3) mspa=c(8,10,12,18,20,22,28,30,32,38,40,42,48,50,52) msr=c(14,15,16,19,20,21,24,25,26,29,30,31,34,35,36) 2.14.2 Média e desvio-padrão m1=tapply(mspa, trat, mean) m2=tapply(msr, trat, mean) sd1=tapply(mspa, trat, sd) sd2=tapply(msr, trat, sd) # alterando margem e configurando para dois plots um abaixo do outro op &lt;- list(mfrow = c(2,1), oma = c(5,4,0,0) + 0.1, mar = c(0,0,0,1)) 2.14.3 Somente colunas Obs. Nesse caso em específico, estamos querendo que ambas as variáveis assumem respostas positivas. Todavia, queremo a coluna da variável MSPA acima e MSR abaixo. par(op) b1=barplot(m1, axes=F, col=&quot;blue&quot;, ylim=c(0,60), axisnames = F, las=1) b2=barplot(m2, axes=F, col=&quot;red&quot;, ylim=c(60,0), las=1) 2.14.4 Escala do eixo Y par(op) b1=barplot(m1, axes=F, col=&quot;blue&quot;, ylim=c(0,60), axisnames = F, las=1) axis(2,seq(0,50,10),las=1) b1=barplot(m2, axes=F, col=&quot;red&quot;, ylim=c(60,0), axisnames = F, las=1) axis(2,seq(0,50,10),las=1) 2.14.5 Barras de desvio-padrão par(op) b1=barplot(m1, axes=F, col=&quot;blue&quot;, ylim=c(0,60), axisnames = F, las=1) axis(2,seq(0,50,10),las=1) arrows(b1,m1+sd1,b1,m1-sd1,angle = 90,code=3, length = 0.05) b2=barplot(m2, axes=F, col=&quot;red&quot;, ylim=c(60,0), axisnames = F, las=1) axis(2,seq(0,50,10),las=1) arrows(b2,m2+sd2,b2,m2-sd2,angle = 90,code=3, length = 0.05) 2.14.6 Linha em 0 e título de Y par(op) b1=barplot(m1, axes=F, col=&quot;blue&quot;, ylim=c(0,60), axisnames = F, las=1) axis(2,seq(0,50,10),las=1) arrows(b1,m1+sd1,b1,m1-sd1,angle = 90,code=3, length = 0.05) b2=barplot(m2, axes=F, col=&quot;red&quot;, ylim=c(60,0), axisnames = F, las=1) axis(2,seq(0,50,10),las=1) title(ylab = &quot;Resposta&quot;,outer=T, line = 3) arrows(b2,m2+sd2,b2,m2-sd2,angle = 90,code=3, length = 0.05) abline(h=0) 2.14.7 Título para MS (g) par(op) b1=barplot(m1, axes=F, col=&quot;blue&quot;, ylim=c(0,60), axisnames = F, las=1) axis(2,seq(0,50,10),las=1) arrows(b1,m1+sd1,b1,m1-sd1,angle = 90,code=3, length = 0.05) b2=barplot(m2, axes=F, col=&quot;red&quot;, ylim=c(60,0), # axisnames = F, las=1) axis(2,seq(0,50,10),las=1) title(ylab = expression(MS~(g)),outer=T, line = 3) arrows(b2,m2+sd2,b2,m2-sd2,angle = 90,code=3, length = 0.05) abline(h=0) 2.14.8 Coluna hachurada par(op) b1=barplot(m1, axes=F, col=&quot;blue&quot;, density = 40, ylim=c(0,60), axisnames = F, las=1) axis(2,seq(0,50,10),las=1) arrows(b1,m1+sd1,b1,m1-sd1,angle = 90,code=3, length = 0.05) b2=barplot(m2, axes=F, col=&quot;red&quot;, ylim=c(60,0), density = 20, # axisnames = F, las=1) axis(2,seq(0,50,10),las=1) title(ylab = expression(MS~(g)),outer=T, line = 3) arrows(b2,m2+sd2,b2,m2-sd2,angle = 90,code=3, length = 0.05) abline(h=0) 2.14.9 Adicionando legenda par(op) b1=barplot(m1, axes=F, col=&quot;blue&quot;, density = 40, ylim=c(0,60), axisnames = F, las=1) axis(2,seq(0,50,10),las=1) arrows(b1,m1+sd1,b1,m1-sd1,angle = 90,code=3, length = 0.05) legend(&quot;topleft&quot;, fill=c(&quot;blue&quot;,&quot;red&quot;), legend=c(&quot;MSPA&quot;,&quot;MSR&quot;), density = c(40,20), bty=&quot;n&quot;) b2=barplot(m2, axes=F, col=&quot;red&quot;, ylim=c(60,0), density = 20, # axisnames = F, las=1) axis(2,seq(0,50,10),las=1) title(ylab = expression(MS~(g)),outer=T, line = 3) arrows(b2,m2+sd2,b2,m2-sd2,angle = 90,code=3, length = 0.05) abline(h=0) 2.14.10 Teste de comparação par(op) b1=barplot(m1, axes=F, col=&quot;blue&quot;, density = 40, ylim=c(0,60), axisnames = F, las=1) axis(2,seq(0,50,10),las=1) arrows(b1,m1+sd1,b1,m1-sd1,angle = 90,code=3, length = 0.05) legend(&quot;topleft&quot;, fill=c(&quot;blue&quot;,&quot;red&quot;), legend=c(&quot;MSPA&quot;,&quot;MSR&quot;), density = c(40,20), bty=&quot;n&quot;) text(b1,m1+sd1+5,c(&quot;e&quot;,&quot;d&quot;,&quot;c&quot;,&quot;b&quot;,&quot;a&quot;)) b2=barplot(m2, axes=F, col=&quot;red&quot;, ylim=c(60,0), density = 20, # axisnames = F, las=1) axis(2,seq(0,50,10),las=1) text(b2,m2+sd2+5,c(&quot;e&quot;,&quot;d&quot;,&quot;c&quot;,&quot;b&quot;,&quot;a&quot;)) title(ylab = expression(MS~(g)),outer=T, line = 3) arrows(b2,m2+sd2,b2,m2-sd2,angle = 90,code=3, length = 0.05) abline(h=0) 2.14.11 Mudando fonte par(family=&quot;serif&quot;) par(op) b1=barplot(m1, axes=F, col=&quot;blue&quot;, density = 40, ylim=c(0,60), axisnames = F, las=1) axis(2,seq(0,50,10),las=1) arrows(b1,m1+sd1,b1,m1-sd1,angle = 90,code=3, length = 0.05) legend(&quot;topleft&quot;, fill=c(&quot;blue&quot;,&quot;red&quot;), legend=c(&quot;MSPA&quot;,&quot;MSR&quot;), density = c(40,20), bty=&quot;n&quot;) text(b1,m1+sd1+5,c(&quot;e&quot;,&quot;d&quot;,&quot;c&quot;,&quot;b&quot;,&quot;a&quot;)) b2=barplot(m2, axes=F, col=&quot;red&quot;, ylim=c(60,0), density = 20, # axisnames = F, las=1) axis(2,seq(0,50,10),las=1) text(b2,m2+sd2+5,c(&quot;e&quot;,&quot;d&quot;,&quot;c&quot;,&quot;b&quot;,&quot;a&quot;)) title(ylab = expression(MS~(g)),outer=T, line = 3) arrows(b2,m2+sd2,b2,m2-sd2,angle = 90,code=3, length = 0.05) abline(h=0) "],
["gráfico-de-barras-1.html", " 3 Gráfico de Barras", " 3 Gráfico de Barras O gráfico em barras consiste em construir retângulos, em que uma das dimensões é proporcional à magnitude a ser representada (\\(n_i\\) ou \\(f_i\\)), sendo a outra arbitrária, porém igual para todas as barras. Essas colunas são dispostas paralelamente umas às outras de forma horizontal. Além do título e fonte de referências deve-se observar o seguinte: as barras devem ter todas a mesma largura; a distância entre as barras deve ser constante e de preferência menor que a largura das barras. 3.0.1 Conjunto de dados tratamentos=rep(c(paste(&quot;T&quot;,1:5)),e=4) resposta=c(100,120,110,90,150,145,149,165,150,144,134,139,220,206,210,210,266,249,248,260) ## Média e Desvio-padrão (Por Tratamento) media=tapply(resposta,tratamentos, mean) desvio=tapply(resposta,tratamentos,sd) 3.0.2 Gráfico básico barplot(media, horiz = T) 3.0.3 Melhorias barplot(media, horiz = T, las=1, col=&quot;lightyellow&quot;, ylab=&quot;Resposta&quot;, xlab=&quot;Tratamentos&quot;, xlim=c(0,300)) abline(v=0) 3.0.4 Barras de desvio-padrão bar=barplot(media, las=1,horiz = T, col=&quot;lightyellow&quot;, ylab=&quot;Resposta&quot;, xlab=&quot;Tratamentos&quot;, xlim=c(0,300)) abline(v=0) arrows(media+desvio,bar,media-desvio,bar,length = 0.1,angle=90,code=3) 3.0.5 Unidade do eixo Y (Ex. \\(Kg\\ ha^{-1}\\)) bar=barplot(media, las=1,horiz = T, col=&quot;lightyellow&quot;, ylab=expression(&quot;Resposta&quot;*&quot; &quot;*(kg*&quot; &quot;*ha^-1)), xlab=&quot;Tratamentos&quot;, xlim=c(0,300)) abline(v=0) arrows(media+desvio,bar,media-desvio,bar,length = 0.1,angle=90,code=3) 3.0.6 Média acima das barras bar=barplot(media, las=1,horiz = T, col=&quot;lightyellow&quot;, ylab=expression(&quot;Resposta&quot;*&quot; &quot;*(kg*&quot; &quot;*ha^-1)), xlab=&quot;Tratamentos&quot;, xlim=c(0,300)) abline(v=0) text(media+desvio+20,bar,media) arrows(media+desvio,bar,media-desvio,bar,length = 0.1,angle=90,code=3) 3.0.7 Separação de casa decimal options(OutDec=&quot;,&quot;) bar=barplot(media, las=1,horiz = T, col=&quot;lightyellow&quot;, ylab=expression(&quot;Resposta&quot;*&quot; &quot;*(kg*&quot; &quot;*ha^-1)), xlab=&quot;Tratamentos&quot;, xlim=c(0,300)) abline(v=0) text(media+desvio+20,bar,media) arrows(media+desvio,bar,media-desvio,bar,length = 0.1,angle=90,code=3) 3.0.8 Letras do teste de comparação tukey=c(&quot;d&quot;,&quot;c&quot;,&quot;c&quot;,&quot;b&quot;,&quot;a&quot;) options(OutDec=&quot;,&quot;) bar=barplot(media, las=1,horiz = T, col=&quot;lightyellow&quot;, ylab=expression(&quot;Resposta&quot;*&quot; &quot;*(kg*&quot; &quot;*ha^-1)), xlab=&quot;Tratamentos&quot;, xlim=c(0,300)) abline(v=0) text(media+desvio+20,bar,paste(round(media,0),tukey)) arrows(media+desvio,bar,media-desvio,bar,length = 0.1,angle=90,code=3) "],
["caixas-boxplot.html", " 4 Caixas (Boxplot) 4.1 Pacote ggplot2 4.2 Utilizando o ggplot2 4.3 Package ggpubr", " 4 Caixas (Boxplot) O boxplot (gráfico de caixa) é um gráfico utilizado para avaliar a distribuição empírica do dados. O boxplot é formado pelo primeiro e terceiro quartil e pela mediana. As hastes inferiores e superiores se estendem, respectivamente, do quartil inferior até o menor valor não inferior ao limite inferior e do quartil superior até o maior valor não superior ao limite superior. Os limites são calculados da forma abaixo Limite inferior: \\(\\max\\{\\min(\\text{dados});Q_1-1,5(Q_3-Q_1)\\}\\). Limite superior: \\(\\min\\{\\max(\\text{dados});Q_3+1,5(Q_3-Q_1)\\}\\). Para este caso, os pontos fora destes limites são considerados valores discrepantes (outliers). A Figura a seguir apresenta um exemplo do formato de um boxplot. Existem várias formas de entrada ou leitura de dados no R. Para um conjunto de dados pequeno, pode-se entrar com as informações diretamente no console do programa. Considere um delineamento inteiramente ao acaso com 5 tratamentos e 4 repetições. A entrada dos dados, entre outras, poderia ser da forma: tratamentos=rep(c(paste(&quot;T&quot;, sep=&#39;&#39;, 1:5)), each=4) resposta = c(100, 120, 110, 90, 150, 145, 149, 165, 150, 144, 134, 139, 220, 206, 210, 210, 266, 249, 248, 260) ## Médias e Desvioss-padrão (por Tratamento) (Médias = tapply(resposta, tratamentos, mean)) ## T1 T2 T3 T4 T5 ## 105,00 152,25 141,75 211,50 255,75 (Desvios = tapply(resposta, tratamentos, sd)) ## T1 T2 T3 T4 T5 ## 12,909944 8,770215 6,849574 5,972158 8,732125 boxplot(resposta ~ tratamentos) # Ou, pode-se usar o comando ``Boxplot`` do pacote ``car`` require(car) Boxplot(resposta ~ tratamentos) Uma vantagem do comando Boxplot é que se houver outlier, ele já identifica a pposição do elemento discrepante. 4.0.1 Melhorias boxplot(resposta ~ tratamentos, las=1, col=&quot;lightyellow&quot;, xlab=&quot;Tratamentos&quot;, ylab=&quot;Resposta&quot;, ylim=c(0,300)) Comandos usados: las=1: mostrar a escala do eixo no sentido horizontal; col=\"cor\": mudar a cor das colunas (Ex. “red”, “blue”, “green” ou gray.colors(quantidade de tonalidades) para escala cinza ou rainbow(quantidade de cores) para escala colorida. Também é possível especificar a cor de cada coluna (col=c(“red”, “green”, “yellow”, “gray”, “blue”))); xlab e ylab: nomear os eixos \\(X\\) e \\(Y\\); xlim e xlim: mudar as escalas dos eixox \\(X\\) e \\(Y\\); 4.0.2 Plotando médias boxplot(resposta ~ tratamentos, las=1, col=&quot;lightyellow&quot;, xlab=&quot;Tratamentos&quot;, ylab=&quot;Resposta&quot;, ylim=c(50,300)) points(Médias, pch=&#39;+&#39;, col=&quot;red&quot;) 4.0.3 Unidade do eixo Y Caso a variável resposta seja Produção (\\(kg/ha\\)), inclui-se tal informação usando-se o comando expression. boxplot(resposta ~ tratamentos, las=1, col=&quot;lightyellow&quot;, xlab=&quot;Tratamentos&quot;, ylab=expression(Produção~~(kg~ha^-1)), ylim=c(50,300)) points(Médias, pch=&#39;+&#39;, col=&quot;red&quot;) 4.0.4 Limites superior e inferior limites = tapply(resposta, tratamentos, boxplot.stats) superior=c(limites$`T1`$stats[5], limites$`T2`$stats[5], limites$`T3`$stats[5], limites$`T4`$stats[5], limites$`T5`$stats[5]) 4.0.5 Média acima das barras boxplot(resposta ~ tratamentos, las=1, col=&quot;lightyellow&quot;, xlab=&quot;Tratamentos&quot;, ylab=expression(&quot;Produção&quot;~~(kg~ha^-1)), ylim=c(50,300)) points(Médias, pch=&#39;+&#39;, col=&quot;red&quot;) text(c(1:5), superior + 10, Médias) 4.0.6 Separação de casa decimal options(OutDec=&quot;,&quot;) boxplot(resposta ~ tratamentos, las=1, col=&quot;lightyellow&quot;, xlab=&quot;Tratamentos&quot;, ylab=expression(&quot;Produção&quot;~~(kg~ha^-1)), ylim=c(50,300)) points(Médias, pch=&#39;+&#39;, col=&quot;red&quot;) text(c(1:5), superior + 20, Médias) 4.0.7 Letras do teste de comparação tukey=c(&quot;d&quot;,&quot;c&quot;,&quot;c&quot;,&quot;b&quot;,&quot;a&quot;) options(OutDec=&quot;,&quot;) boxplot(resposta ~ tratamentos, las=1, col=&quot;lightyellow&quot;, xlab=&quot;Tratamentos&quot;, ylab=expression(&quot;Produção&quot;~(kg~ha^-1)), ylim=c(50,300)) points(Médias, pch=&#39;+&#39;, col=&quot;red&quot;) text(c(1:5), superior + 20, paste(round(Médias, 0), tukey)) 4.1 Pacote ggplot2 Vamos trabalhar com um experimento em DIC com quatro tratamentos e quatro repetições cada. exp1=c(17,22,13,14,18,19,16,21,9,16,15,8,25,26,23,40) Trat=rep(c(paste(&quot;T&quot;,1:4)),e=4) dados=data.frame(Trat,exp1) dados$Trat=as.factor(Trat) Obs. Para facilitar, vamos realizar a análise direto pelo pacote ExpDes.pt (é necessário instalar o pacote) 4.1.1 Análise de variância ExpDes.pt::dic(Trat,exp1) ## ------------------------------------------------------------------------ ## Quadro da analise de variancia ## ------------------------------------------------------------------------ ## GL SQ QM Fc Pr&gt;Fc ## Tratamento 3 582,75 7,9556 0,0034723 ## Residuo 12 293,00 ## Total 15 875,75 ## ------------------------------------------------------------------------ ## CV = 26,18 % ## ## ------------------------------------------------------------------------ ## Teste de normalidade dos residuos ## Valor-p: 0,06507919 ## De acordo com o teste de Shapiro-Wilk a 5% de significancia, os residuos podem ser considerados normais. ## ------------------------------------------------------------------------ ## ## ------------------------------------------------------------------------ ## Teste de homogeneidade de variancia ## valor-p: 0,237053 ## De acordo com o teste de bartlett a 5% de significancia, as variancias podem ser consideradas homogeneas. ## ------------------------------------------------------------------------ ## ## Teste de Tukey ## ------------------------------------------------------------------------ ## Grupos Tratamentos Medias ## a T 4 28,5 ## ab T 2 18,5 ## b T 1 16,5 ## b T 3 12 ## ------------------------------------------------------------------------ 4.2 Utilizando o ggplot2 library(ggplot2) 4.2.1 Gráfico básico ggplot(dados, aes(x=Trat,y=exp1))+ geom_boxplot() 4.2.2 Modificando cores ggplot(dados, aes(x=Trat,y=exp1))+ geom_boxplot(fill=&quot;lightgreen&quot;, # Cor da caixa colour=&quot;red&quot;, # cor do contorno outlier.colour = &quot;blue&quot;, # Cor do contorno do outlier outlier.shape = 10, # Formato do ponto do outlier outlier.size = 2) # Tamanho do outlier 4.2.3 Cor por tratamento ggplot(dados, aes(x=Trat,y=exp1))+ geom_boxplot(aes(fill=dados$Trat)) 4.2.4 Nome dos eixos ggplot(dados, aes(x=Trat,y=exp1))+ geom_boxplot(fill=&quot;lightgreen&quot;, colour=&quot;red&quot;, outlier.colour = &quot;blue&quot;, outlier.shape = 10, outlier.size = 2)+ ylab(&quot;Resposta&quot;)+ xlab(&quot;Tratamentos&quot;) 4.2.5 linha de grade e cor de fundo ggplot(dados, aes(x=Trat,y=exp1))+ geom_boxplot(fill=&quot;lightgreen&quot;, colour=&quot;black&quot;, outlier.colour = &quot;blue&quot;, outlier.shape = 10, outlier.size = 2)+ ylab(&quot;Resposta&quot;)+ xlab(&quot;Tratamentos&quot;)+ theme_bw()+ theme_classic() 4.2.6 Letras do teste de Tukey Obs. Neste exemplo vamos adicionar as letras abaixo das caixas e alinhado em y=1 a=data.frame(Trat=levels(as.factor(Trat)), exp1=c(1,1,1,1), # Deve ter o mesmo da variável # esse 1 é para Y=1 letra=c(&quot;b&quot;,&quot;ab&quot;,&quot;b&quot;,&quot;a&quot;)) ggplot(dados, aes(x=Trat,y=exp1))+ geom_boxplot(fill=&quot;lightgreen&quot;, colour=&quot;black&quot;, outlier.colour = &quot;blue&quot;, outlier.shape = 10, outlier.size = 2)+ ylab(&quot;Resposta&quot;)+ xlab(&quot;Tratamentos&quot;)+ theme_bw()+ theme_classic()+ geom_text(data = a, aes(label = letra)) 4.3 Package ggpubr library(ggpubr) ggboxplot(dados, # data.frame com os dados e tratamentos &#39;Trat&#39;, # Nome do tratamento entre aspas &#39;exp1&#39;) # Nome da resposta 4.3.1 Cor da caixa ggboxplot(dados, &#39;Trat&#39;, &#39;exp1&#39;, fill=&quot;red&quot;) 4.3.2 Cor de contorno ggboxplot(dados, &#39;Trat&#39;, &#39;exp1&#39;, fill=&quot;red&quot;, color = &quot;blue&quot;) 4.3.3 Inserindo título ggboxplot(dados, &#39;Trat&#39;, &#39;exp1&#39;, fill=&quot;red&quot;, color = &quot;blue&quot;, title=&quot;(A)&quot;) 4.3.4 Nome dos eixos X e Y ggboxplot(dados, &#39;Trat&#39;, &#39;exp1&#39;, fill=&quot;red&quot;, color = &quot;black&quot;, title=&quot;(A)&quot;, xlab=&quot;Tratamentos&quot;, ylab=&quot;Resposta&quot;) 4.3.5 Ponto da média ggboxplot(dados, &#39;Trat&#39;, &#39;exp1&#39;, fill=&quot;red&quot;, color = &quot;black&quot;, title=&quot;(A)&quot;, xlab=&quot;Tratamentos&quot;, ylab=&quot;Resposta&quot;, add=&quot;mean&quot;) Obs. Podemos usar ao invés de \"mean\", os seguintes argumentos: mean_se: Média e erro padrão mean_sd: Média e desvio-padrão mean_ci: Média e intervalo de confiança median: Mediana point: pontos referente às observações Para mais informações consultar atráves de: desc_stat 4.3.6 Letras do teste de Tukey a=data.frame(Trat=levels(as.factor(Trat)), exp1=c(1,1,1,1), # Deve ter o mesmo da variável # esse 1 é para Y=1 letra=c(&quot;b&quot;,&quot;ab&quot;,&quot;b&quot;,&quot;a&quot;)) ggboxplot(dados, &#39;Trat&#39;, &#39;exp1&#39;, fill=&quot;red&quot;, color = &quot;black&quot;, title=&quot;(A)&quot;, xlab=&quot;Tratamentos&quot;, ylab=&quot;Resposta&quot;, add=&quot;mean&quot;, ylim=c(0,40))+ geom_text(data = a, aes(label = letra)) "],
["regressão.html", " 5 Regressão 5.1 Usando o pacote ggplot2 5.2 Duas curvas", " 5 Regressão O gráfico de regressão pode ser construído utilizando um gráfico de dispersão. Assim, uma análise gráfica preliminar é realizada construindo-se o gráfico de dispersão entre as variáveis em questão. Este gráfico é importante em qualquer análise de regressão já que por meio dele é possível ter uma noção do tipo de relação existente entre as variáveis (relação linear, quadrática). Esta relação na maioria das vezes não é perfeita, ou seja, os pontos não estão dispostos perfeitamente sobre a função que relaciona as duas variáveis mas deseja-se que estes pontos estejam próximos. A curva da regressão é construída sobre o gráfico de dispersão mediante às respectivas análises a serem consideradas para definir o melhor modelo. 5.0.1 Conjunto de dados tratamentos=rep(c(0,2,4,8,16,32,64,128,256),e=4) resposta=c(0,1,2,4,8,7,9,10,15,17,18,20,25,26,24,28,36,39,38,40,60,68,65,70,100,110,104,107,150,155,156,159,120,130,126,124) ## Média e Desvio-padrão (Por Tratamento) Dose=c(0,2,4,8,16,32,64,128,256) media=tapply(resposta,tratamentos, mean) desvio=tapply(resposta,tratamentos,sd) 5.0.2 Gráfico básico plot(media~Dose) 5.0.3 Melhorias plot(media~Dose, las=1, ylab=&quot;Resposta&quot;, xlab=&quot;Dose&quot;) 5.0.4 Barras de desvio-padrão reg=plot(media~Dose, las=1, ylab=&quot;Resposta&quot;, xlab=&quot;Dose&quot;) arrows(Dose,media+desvio,Dose,media-desvio,length = 0.05,angle=90,code=3) Adicionando barras de desvio-padrão de largura 0.05 (length=0.05), com angulo de 90 graus e tipo de flecha 3 (T ou T invertido) 5.0.5 Unidade do eixo Y (Ex. \\(Kg\\ ha^{-1}\\)) e X(Ex.\\(Kg\\ ha^{-1}\\ ano^{-1}\\)) reg=plot(media~Dose, las=1, ylab=expression(&quot;Resposta&quot;~~(kg~ha^-1)), xlab=expression(&quot;Dose&quot;~(kg~ha^-1~ano^-1))) arrows(Dose,media+desvio,Dose,media-desvio,length = 0.02,angle=90,code=3) A função expression também pode ser usada para textos em gráficos (Função “text()” - veremos posteriormente). 5.0.6 Separação de casa decimal options(OutDec=&quot;,&quot;) reg=plot(media~Dose, las=1, ylab=expression(&quot;Resposta&quot;~~(kg~ha^-1)), xlab=expression(&quot;Dose&quot;~~(kg~ha^-1~ano^-1))) arrows(Dose,media+desvio,Dose,media-desvio,length = 0.02,angle=90,code=3) A função “options(OutDec=”,“)” converte a casa decimal de todas as saídas posteriores ao comando para vírgula, entretanto a função não altera para gráficos do pacote ggplot2. 5.0.7 Curva de Tendência modelo=lm(media~Dose+I(Dose^2)) summary(modelo) ## ## Call: ## lm(formula = media ~ Dose + I(Dose^2)) ## ## Residuals: ## Min 1Q Median 3Q Max ## -6,0101 -2,3298 0,5233 2,3045 3,4953 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 7,7601301 1,7653406 4,396 0,00459 ** ## Dose 1,8811023 0,0566083 33,230 4,94e-08 *** ## I(Dose^2) -0,0055671 0,0002241 -24,847 2,80e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 3,709 on 6 degrees of freedom ## Multiple R-squared: 0,9967, Adjusted R-squared: 0,9956 ## F-statistic: 899,4 on 2 and 6 DF, p-value: 3,674e-08 plot(media~Dose, las=1, ylim=c(0,200), col=&quot;red&quot;, pch=16, ylab=expression(&quot;Resposta&quot;~~(kg~ha^-1)), xlab=expression(&quot;Dose&quot;~~(kg~ha^-1~ano^-1))) arrows(Dose,media+desvio,Dose,media-desvio,length = 0.02,angle=90,code=3) curve(modelo$coefficients[1]+modelo$coefficients[2]*x+modelo$coefficients[3]*x^2, add=T,col=&quot;blue&quot;) 5.0.8 Pontos de máximo/mínimo ## Para encontrar o ponto de máximo ou mínimo em equação quadrática, fazer derivada primeira de Y=0 (x=-modelo$coefficients[2]/(2*modelo$coefficients[3])) ## Dose ## 168,9481 (y=modelo$coefficients[1]+modelo$coefficients[2]*x+modelo$coefficients[3]*x^2) ## (Intercept) ## 166,6644 plot(media~Dose, las=1, ylim=c(0,200), col=&quot;red&quot;, pch=16, ylab=expression(&quot;Resposta&quot;~~(kg~ha^-1)), xlab=expression(&quot;Dose&quot;~~(kg~ha^-1~ano^-1))) arrows(Dose,media+desvio,Dose,media-desvio,length = 0.02,angle=90,code=3) curve(modelo$coefficients[1]+modelo$coefficients[2]*x+modelo$coefficients[3]*x^2, add=T,col=&quot;blue&quot;) abline(h=y,col=&quot;red&quot;,lty=2) abline(v=x,col=&quot;red&quot;,lty=2) points(x,y,pch=8,col=&quot;black&quot;) 5.0.9 Equação e R^2 plot(media~Dose, las=1, ylim=c(0,200), col=&quot;red&quot;, pch=16, ylab=expression(&quot;Resposta&quot;~~(kg~ha^-1)), xlab=expression(&quot;Dose&quot;~~(kg~ha^-1~ano^-1))) arrows(Dose,media+desvio,Dose,media-desvio,length = 0.02,angle=90,code=3) curve(modelo$coefficients[1]+modelo$coefficients[2]*x+modelo$coefficients[3]*x^2, add=T,col=&quot;blue&quot;) abline(h=y,col=&quot;red&quot;,lty=2) abline(v=x,col=&quot;red&quot;,lty=2) points(x,y,pch=8,col=&quot;black&quot;) text(100,50,expression(Y==7.76013+1.881102*x-0.005567102 *x^2),cex=0.8) text(100,40,expression(R^2==1.00),cex=0.8) 5.1 Usando o pacote ggplot2 5.1.1 Gráfico básico library(ggplot2) dados=data.frame(Dose,media) ggplot(dados, aes(x=Dose, y=media)) + geom_point() 5.1.2 Editando gráfico (grafico=ggplot(dados, aes(x=Dose, y=media)) + geom_point(colour=&quot;red&quot;, size=3, shape=1)+ geom_smooth(method=&quot;lm&quot;, se = F, formula = y~poly(x,2), show.legend = T) + labs(title = &quot;Exemplo de gráfico de regressão no ggplot2&quot;, y = expression(Produtividade~~(Kg~ha^-1)), x = &quot;Dose&quot;, caption = &quot;Fonte: O autor&quot;)) geom_point(colour=“red”, size=3, shape=1): gráfico de dispersão, com pontos de cor vermelha, de tamanho 3 e formato 2 (Círculo sem preenchimento interno) geom_smooth(method=“lm”, se = F, formula = y~poly(x,2)): Comando para plotar curva de tendência para regressão polinomial de grau 2 (Quadrático) labs = nomear os eixos e títulos dos gráficos 5.1.3 Plotando equação texto &lt;- sprintf(&#39;y = %.2f + %.2fx %.2fx², r² = %.2f&#39;,modelo$coefficients[1],modelo$coefficients[2],modelo$coefficients[3],summary(modelo)$r.squared) 5.1.4 Plotando o texto (grafico=grafico+ geom_text(aes(x=x, y=y, label=texto), hjust=1, vjust=16)) 5.1.5 Removendo cor de fundo (grafico=grafico+ theme_bw()) 5.1.6 Removendo grade (grafico=grafico+ theme_classic()) (grafico=grafico+ theme(axis.title = element_text(size = 12), axis.text = element_text(size = 12))) 5.1.7 Ponto de máximo/mínimo (grafico=grafico+ geom_vline(xintercept = x, colour=&quot;red&quot;, linetype=&quot;dotted&quot;, size=1.2)+ geom_hline(yintercept =y,colour=&#39;red&#39;, linetype=&#39;dotted&#39;, size=1.3)) 5.1.8 Tipos de linhas d=data.frame(lt=c(&quot;blank&quot;, &quot;solid&quot;, &quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;, &quot;longdash&quot;, &quot;twodash&quot;, &quot;1F&quot;, &quot;F1&quot;, &quot;4C88C488&quot;, &quot;12345678&quot;)) ggplot()+ scale_x_continuous(name=&quot;&quot;,limits=c(0,1))+ scale_y_discrete(name=&quot;linetype&quot;)+ theme_bw()+ theme_classic()+ scale_linetype_identity()+ geom_segment(data=d, mapping=aes(x=0, xend=1, y=d$lt, yend=d$lt, linetype=d$lt)) 5.2 Duas curvas 5.2.1 Conjunto de dados Variável: resposta: Resposta do tratamento A resposta1: Resposta do tratamento B Doses: 0,2,4,8,16,32,64,128,256 dose=rep(c(0,2,4,8,16,32,64,128,256),e=4) resposta=c(0,1,2,4,8,7,9,10,15,17,18,20,25,26,24,28,36,39,38,40,60,68,65,70,100,110,104,107,150,155,156,159,120,130,126,124) resposta1=c(20,21,22,24,28,27,29,26,35,37,38,40,45,46,44,48,56,59,58,60,80,88,85,90,120,130,124,127,160,165,166,169,140,150,146,144) Dose=c(0,2,4,8,16,32,64,128,256) 5.2.2 Média e Desvio-padrão media=tapply(resposta,dose, mean) media1=tapply(resposta1,dose, mean) desvio=tapply(resposta,dose,sd) desvio1=tapply(resposta,dose,sd) 5.2.3 Tratamento A modelo=lm(media~Dose+I(Dose^2)) summary(modelo) ## ## Call: ## lm(formula = media ~ Dose + I(Dose^2)) ## ## Residuals: ## Min 1Q Median 3Q Max ## -6,0101 -2,3298 0,5233 2,3045 3,4953 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 7,7601301 1,7653406 4,396 0,00459 ** ## Dose 1,8811023 0,0566083 33,230 4,94e-08 *** ## I(Dose^2) -0,0055671 0,0002241 -24,847 2,80e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 3,709 on 6 degrees of freedom ## Multiple R-squared: 0,9967, Adjusted R-squared: 0,9956 ## F-statistic: 899,4 on 2 and 6 DF, p-value: 3,674e-08 plot(media~Dose, main=&quot;TRATAMENTO A&quot;, ylim=c(0,200), col=&quot;red&quot;, ylab=expression(Resposta~(kg~ha^-1)), xlab=expression(Dose~(kg~ha^-1~ano^-1))) curve(coef(modelo)[1]+coef(modelo)[2]*x+coef(modelo)[3]*x^2, add=T,col=&quot;red&quot;) legend(&quot;topleft&quot;,expression(Y==7.76013+1.88110*x-0.00557 *x^2, R^2==1.00), bty=&quot;n&quot;) 5.2.4 Tratamento B modelo1=lm(media1~Dose+I(Dose^2)) summary(modelo1) ## ## Call: ## lm(formula = media1 ~ Dose + I(Dose^2)) ## ## Residuals: ## Min 1Q Median 3Q Max ## -6,959 -4,745 1,761 3,147 5,451 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 28,7090755 2,5811396 11,12 3,15e-05 *** ## Dose 1,7782967 0,0827680 21,48 6,63e-07 *** ## I(Dose^2) -0,0051907 0,0003276 -15,85 4,01e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 5,423 on 6 degrees of freedom ## Multiple R-squared: 0,9924, Adjusted R-squared: 0,9898 ## F-statistic: 390,2 on 2 and 6 DF, p-value: 4,442e-07 plot(media1~Dose, main=&quot;TRATAMENTO B&quot;, ylim=c(0,200), col=&quot;blue&quot;, ylab=expression(Resposta~(kg~ha^-1)), xlab=expression(Dose~(kg~ha^-1~ano^-1))) curve(coef(modelo1)[1]+coef(modelo1)[2]*x+coef(modelo1)[3]*x^2, add=T,col=&quot;blue&quot;) legend(&quot;topleft&quot;,expression(Y==28.70908+1.77830*x-0.00520*x^2, R^2==0.99), bty=&quot;n&quot;) 5.2.5 Juntando os Gráficos 5.2.6 Gráfico de dispersão plot(media~Dose, ylim=c(0,250), col=&quot;red&quot;, ylab=expression(Resposta~(kg~ha^-1)), xlab=expression(Dose~(kg~ha^-1~ano^-1))) curve(coef(modelo)[1]+coef(modelo)[2]*x+coef(modelo)[3]*x^2, add=T,col=&quot;red&quot;) points(media1~Dose, col=&quot;blue&quot;) curve(coef(modelo1)[1]+coef(modelo1)[2]*x+coef(modelo1)[3]*x^2, add=T,col=&quot;blue&quot;) plot(media~Dose, ylim=c(0,250), col=&quot;red&quot;, ylab=expression(Resposta~(kg~ha^-1)), xlab=expression(Dose~(kg~ha^-1~ano^-1))) curve(coef(modelo)[1]+coef(modelo)[2]*x+coef(modelo)[3]*x^2, add=T,col=&quot;red&quot;) points(media1~Dose, col=&quot;blue&quot;) curve(coef(modelo1)[1]+coef(modelo1)[2]*x+coef(modelo1)[3]*x^2, add=T,col=&quot;blue&quot;) 5.2.7 Inserindo legenda plot(media~Dose, ylim=c(0,250), col=&quot;red&quot;, ylab=expression(Resposta~(kg~ha^-1)), xlab=expression(Dose~(kg~ha^-1~ano^-1))) points(media1~Dose,col=&quot;blue&quot;) legend(&quot;topleft&quot;, col=c(&quot;red&quot;,&quot;blue&quot;), bty=&quot;n&quot;, pch=1, c(expression(Y[A]==7.76013+1.88110*x-0.00557*x^2~~R^2*&quot;=1,00&quot;), expression(Y[B]==28.70908+1.77830*x-0.00519*x^2~~R^2*&quot;=0,99&quot;))) curve(coef(modelo)[1]+coef(modelo)[2]*x+coef(modelo)[3]*x^2, add=T,col=&quot;red&quot;) curve(coef(modelo1)[1]+coef(modelo1)[2]*x+coef(modelo1)[3]*x^2, add=T,col=&quot;blue&quot;) "],
["histograma.html", " 6 Histograma 6.1 Pacote ggplot2 6.2 Distribuição normal padrão (Z)", " 6 Histograma Histograma é uma representação gráfica (um gráfico de barras verticais ou barras horizontais) da distribuição de frequências de um conjunto de dados quantitativos contínuos. O histograma pode ser um gráfico por valores absolutos ou frequência relativa ou densidade. No caso de densidade, a frequência relativa do intervalo \\(i\\), (\\(fr_i\\)), é representada pela área de um retângulo que é colocado acima do ponto médio da classe i. Consequentemente, a área total do histograma (igual a soma das áreas de todos os retângulos) será igual a 1. Assim, ao construir o histograma, cada retângulo deverá ter área proporcional à frequência relativa (ou à frequência absoluta, o que é indiferente) correspondente. No caso em que os intervalos são de tamanhos (amplitudes) iguais, as alturas dos retângulos serão iguais às frequências relativas (ou iguais às frequências absolutas) dos intervalos correspondentes. 6.0.1 Conjunto de dados tratamentos=rep(c(paste(&quot;T&quot;,1:5)),e=8) resposta=c(100,170,160,90,150,145,179,165,180,144,184,139,220,206,187,210,166,235,220,190,100,120,110,190,140,145,149,165,150,144,134,139,188,206,190,140,166,224,148,160) data=data.frame(tratamentos, resposta) 6.0.2 Gráfico básico hist(resposta) 6.0.3 Melhorias hist(resposta, las=1, col=&quot;lightyellow&quot;, ylab=&quot;Frequência&quot;, xlab=&quot;Resposta&quot;, ylim=c(0,10), main=&quot;Histograma&quot;) abline(h=0) Comandos: las=1: deixar escala do eixo Y na vertical col=“cor”: mudar cor das barras (Ex. “red”,“blue”,“green” ou gray.colors(quantidade de tonalidades) para escala cinza ou rainbow(quantidade de cores) para escala colorida. Também é possível específicar a cor de cada barra (col=c(“red”,“green”,“yellow”,“gray”,“blue”))). xlab e ylab: nomear eixo X e Y xlim e ylim: escala do eixo X e Y main: Título abline(h=0): linha na horizontal em Y=0 (No caso de vertical, abline(v=0)). É possível alterar a cor pela função “col=”cor\"\" e o tracejado pelo “lty=número” (Ver o Help do comando) 6.0.4 Plotando curva normal histograma=hist(resposta, las=1, col=&quot;lightyellow&quot;, ylab=&quot;Frequência&quot;, xlab=&quot;Resposta&quot;, ylim=c(0,10), main=&quot;Histograma&quot;) abline(h=0) ## Criando sequência de dados quantitativos discretos entre o mínimo e o máximo da resposta xfit&lt;-seq(min(resposta),max(resposta)) ## dnorm (Função para encontrar os possíveis valores para Y e suas densidade de probabilidade) yfit&lt;-dnorm(xfit,mean=mean(resposta),sd=sd(resposta)) ## diff é o comando para diferença e length para comprimento yfit &lt;- yfit*diff(histograma$mids[1:2])*length(resposta) ## Plotando linha da curva normal lines(xfit, yfit, col=&quot;blue&quot;, lwd=2) 6.1 Pacote ggplot2 instalar pacote ggplot2: install.packages(\"ggplot2\") # Carregar pacote library(ggplot2) # Obs. Não esquecer de criar uma data.frame (Ex. chamei de data no início do material) # Criar histograma mean=mean(resposta);sd= sd(resposta);n=length(resposta); largura=20 ggplot(data, aes(data$resposta))+ geom_histogram(binwidth = 20, col=&quot;red&quot;, fill=&quot;green&quot;)+ labs(title=&quot;Histograma&quot;)+ labs(x=&quot;Resposta&quot;, y=&quot;Frequência&quot;)+ stat_function(fun = function(x) dnorm(x, mean = mean, sd = sd) * n * largura, color = &quot;red&quot;, size = 1) binwidth = largura de caixa col= cor do contorno das caixas fill= cor do interior das caixas Comando para plotar a curva normal: stat_function(fun = function(x) dnorm(x, mean = mean, sd = sd) * n * lagura,color = “red”, size = 1) 6.2 Distribuição normal padrão (Z) 6.2.1 Simulando dados x=seq(-3,3,length=400) y=dnorm(x,0,1) 6.2.2 gráfico simples plot(x, y, type=&quot;l&quot;, xlab=&quot;&quot;, ylim=c(-0.1,0.5), ylab=&quot;&quot;) 6.2.3 Removendo marca da escala plot(x,y,type=&quot;l&quot;,axes=F,xlab=&quot;&quot;,ylim=c(-0.1,0.5), ylab=&quot;&quot;) 6.2.4 Preenchimento tracejado plot(x,y,type=&quot;l&quot;,axes=F,xlab=&quot;&quot;,ylim=c(-0.1,0.5), ylab=&quot;&quot;,col=&quot;white&quot;) polygon(c(-3,x,3),c(0,y,0),density = 30) 6.2.5 Valor crítico (90%) plot(x,y,type=&quot;l&quot;,axes=F,xlab=&quot;&quot;,ylim=c(-0.1,0.5), ylab=&quot;&quot;,col=&quot;white&quot;) polygon(c(-3,x,3),c(0,y,0),density = 30) x1=seq(-1.645,1.645,length=100) # 90 y1=dnorm(x1) polygon(c(-1.645,x1,1.645),c(0,y1,0),col=&quot;white&quot;) abline(h=0); lines(x=c(0,0),y=c(0,max(y)),lty=2) 6.2.6 Valor crítico (95%) plot(x,y,type=&quot;l&quot;,axes=F,xlab=&quot;&quot;,ylim=c(-0.1,0.5), ylab=&quot;&quot;,col=&quot;white&quot;) polygon(c(-3,x,3),c(0,y,0),density = 30) x1=seq(-1.96,1.96,length=100) # 95% y1=dnorm(x1) polygon(c(-1.96,x1,1.96),c(0,y1,0),col=&quot;white&quot;) abline(h=0); lines(x=c(0,0),y=c(0,max(y)),lty=2) 6.2.7 Valor crítico (99%) plot(x,y,type=&quot;l&quot;,axes=F,xlab=&quot;&quot;,ylim=c(-0.1,0.5), ylab=&quot;&quot;,col=&quot;white&quot;) polygon(c(-3,x,3),c(0,y,0),density = 30) x1=seq(-2.575,2.575,length=100) # 99 y1=dnorm(x1) polygon(c(-2.575,x1,2.575),c(0,y1,0),col=&quot;white&quot;) abline(h=0); lines(x=c(0,0),y=c(0,max(y)),lty=2) 6.2.8 Adicionando legendas plot(x,y,type=&quot;l&quot;,axes=F,xlab=&quot;&quot;,ylim=c(-0.1,0.5), ylab=&quot;&quot;,col=&quot;white&quot;) polygon(c(-3,x,3),c(0,y,0),density = 30) x1=seq(-1.96,1.96,length=100) y1=dnorm(x1) polygon(c(-1.96,x1,1.96),c(0,y1,0),col=&quot;white&quot;) abline(h=0); lines(x=c(0,0),y=c(0,max(y)),lty=2) text(-1.96,-.05,expression(frac(-Z,(alpha/2)))) text(+1.96,-.05,expression(frac(Z,(alpha/2)))) text(-2.5,0.1,expression(frac(alpha,2))) text(+2.5,0.1,expression(frac(alpha,2))) axis(1) "],
["setores-circulares.html", " 7 Setores circulares 7.1 Gráfico de Setores Circulares 3D", " 7 Setores circulares O gráfico de Setores, também conhecido como gráfico de pizza ou gráfico circular é um diagrama circular onde os valores de cada categoria estatística representada são proporcionais às respectivas frequências. Este gráfico pode vir acompanhado de porcentagens. É utilizado para dados qualitativos nominais. Para construir um gráfico de setores é necessário determinar o ângulo dos setores circulares correspondentes à contribuição percentual de cada valor no total. 7.0.1 Conjunto de dados variedade=c(&quot;Hass&quot;,&quot;Breda&quot;,&quot;Quintal&quot;,&quot;Geada&quot;,&quot;Margarida&quot;,&quot;Hass&quot;,&quot;Geada&quot;,&quot;Margarida&quot;,&quot;Hass&quot;,&quot;Margarida&quot;,&quot;Hass&quot;,&quot;Breda&quot;,&quot;Quintal&quot;,&quot;Breda&quot;,&quot;Quintal&quot;,&quot;Geada&quot;,&quot;Margarida&quot;,&quot;Breda&quot;,&quot;Quintal&quot;,&quot;Hass&quot;,&quot;Margarida&quot;,&quot;Hass&quot;,&quot;Breda&quot;,&quot;Hass&quot;,&quot;Margarida&quot;,&quot;Hass&quot;,&quot;Breda&quot;,&quot;Quintal&quot;,&quot;Breda&quot;,&quot;Quintal&quot;,&quot;Geada&quot;,&quot;Margarida&quot;,&quot;Breda&quot;,&quot;Quintal&quot;,&quot;Hass&quot;,&quot;Margarida&quot;,&quot;Hass&quot;,&quot;Breda&quot;,&quot;Geada&quot;,&quot;Margarida&quot;,&quot;Breda&quot;,&quot;Quintal&quot;,&quot;Hass&quot;,&quot;Margarida&quot;,&quot;Hass&quot;,&quot;Breda&quot;,&quot;Hass&quot;,&quot;Margarida&quot;,&quot;Hass&quot;,&quot;Breda&quot;,&quot;Quintal&quot;,&quot;Breda&quot;,&quot;Quintal&quot;,&quot;Geada&quot;,&quot;Margarida&quot;,&quot;Breda&quot;,&quot;Quintal&quot;,&quot;Hass&quot;,&quot;Margarida&quot;,&quot;Hass&quot;,&quot;Breda&quot;,&quot;Hass&quot;,&quot;Margarida&quot;,&quot;Hass&quot;,&quot;Breda&quot;,&quot;Quintal&quot;,&quot;Breda&quot;,&quot;Quintal&quot;,&quot;Geada&quot;,&quot;Margarida&quot;,&quot;Breda&quot;,&quot;Quintal&quot;,&quot;Quintal&quot;,&quot;Breda&quot;,&quot;Quintal&quot;) 7.0.2 Frequências factor(variedade) ## [1] Hass Breda Quintal Geada Margarida Hass Geada ## [8] Margarida Hass Margarida Hass Breda Quintal Breda ## [15] Quintal Geada Margarida Breda Quintal Hass Margarida ## [22] Hass Breda Hass Margarida Hass Breda Quintal ## [29] Breda Quintal Geada Margarida Breda Quintal Hass ## [36] Margarida Hass Breda Geada Margarida Breda Quintal ## [43] Hass Margarida Hass Breda Hass Margarida Hass ## [50] Breda Quintal Breda Quintal Geada Margarida Breda ## [57] Quintal Hass Margarida Hass Breda Hass Margarida ## [64] Hass Breda Quintal Breda Quintal Geada Margarida ## [71] Breda Quintal Quintal Breda Quintal ## Levels: Breda Geada Hass Margarida Quintal n=length(variedade) table(variedade) ## variedade ## Breda Geada Hass Margarida Quintal ## 19 7 18 15 16 proporção = prop.table(table(variedade)) 7.0.3 Gráfico básico pie(proporção*100) 7.0.4 Melhorias pie(proporção*100, edges=400, radius=1, col=c(&quot;red&quot;,&quot;green&quot;,&quot;yellow&quot;,&quot;blue&quot;,&quot;orange&quot;), main=&quot;Variedades de abacate&quot;) 7.0.5 Plotando valores Obs. sem casa decimal pie(proporção*100, edges=400, radius=1, labels=paste(names(proporção),&quot;(&quot;,round(proporção*100,0),&quot;%&quot;,&quot;)&quot;), col=c(&quot;red&quot;,&quot;green&quot;,&quot;yellow&quot;,&quot;blue&quot;,&quot;orange&quot;), main=&quot;Variedades de abacate&quot;) 7.1 Gráfico de Setores Circulares 3D 7.1.1 Descobrindo as frequências factor(variedade) ## [1] Hass Breda Quintal Geada Margarida Hass Geada ## [8] Margarida Hass Margarida Hass Breda Quintal Breda ## [15] Quintal Geada Margarida Breda Quintal Hass Margarida ## [22] Hass Breda Hass Margarida Hass Breda Quintal ## [29] Breda Quintal Geada Margarida Breda Quintal Hass ## [36] Margarida Hass Breda Geada Margarida Breda Quintal ## [43] Hass Margarida Hass Breda Hass Margarida Hass ## [50] Breda Quintal Breda Quintal Geada Margarida Breda ## [57] Quintal Hass Margarida Hass Breda Hass Margarida ## [64] Hass Breda Quintal Breda Quintal Geada Margarida ## [71] Breda Quintal Quintal Breda Quintal ## Levels: Breda Geada Hass Margarida Quintal n=length(variedade) table(variedade) ## variedade ## Breda Geada Hass Margarida Quintal ## 19 7 18 15 16 proporção = prop.table(table(variedade)) 7.1.2 Gráfico em 3D library(plotrix) pie3D(proporção*100) 7.1.3 Separando os setores pie3D(proporção*100, explode=0.1, main=&quot;Variedades de abacate&quot;) 7.1.4 Adicionando nomes e frequências pie3D(proporção*100, explode=0.1, cex=0.8, labels=paste(names(proporção), &quot;(&quot;,round(proporção*100,0),&quot;%&quot;,&quot;)&quot;), main=&quot;Variedades de abacate&quot;) "],
["interação.html", " 8 Interação 8.1 Usando o interaction(s) 8.2 Pacote dae", " 8 Interação O gráfico de interações é usado quando temos ao menos dois fatores. Tem como função identificar visualmente se os fatores apresentam efeito conjunto ou se são independentes 8.0.1 Conjunto de dados Um experimento foi realizado com o intuito de avaliar 5 manejos na entrelinha do pomar de laranja Natal e sua influência em relação a linha de plantio. O experimento foi instalado em Delineamento em blocos casualizados com 12 repetições por tratamento em esquema de parcelas subdividida (2 [linha e entrelinha] x 5[ U. brizantha (T1),U. decumbens (T2), U. ruziziensis (T3), Glifosato (T4), Pousio (T5). Foi analisado o carbono da biomassa microbiana (CBM). RESP=c(224.92, 180.32, 130.19, 110.31, 163.74,193.03, 211.49, 137.65, 127.15, 203.39,182.36, 124.75, 177.70, 231.01, 202.14,214.89, 198.42, 267.85, 207.67, 176.74,162.18, 124.59, 158.99, 209.12, 128.14,113.95, 215.53, 190.51, 174.58, 148.70,150.90, 209.03, 210.40, 199.03, 237.05,196.97, 176.06, 263.27, 240.19, 160.72,239.90, 188.07, 251.35, 215.45, 198.50,271.42, 226.56, 217.65, 213.69, 101.26,115.41, 140.10, 117.67, 106.45, 139.34,104.22, 206.13, 195.89, 147.11, 122.93,176.55, 173.63, 112.83, 184.82, 178.18,115.85, 183.89, 134.92, 086.49, 103.96,096.33, 091.64, 157.76, 107.45, 106.61,095.28, 152.37, 066.02, 125.75, 075.34,088.64, 104.00, 066.38, 084.74, 101.76,173.70, 101.24, 143.71, 119.88, 157.79,070.42, 152.75, 111.65, 153.08, 146.64,142.57, 098.96, 065.92, 065.62, 063.26,095.72, 084.14, 054.92, 090.49, 112.11,102.68, 144.77, 122.58, 125.14, 127.61,117.14, 147.87, 156.18, 154.82, 183.91,159.11, 155.41, 184.55, 121.39, 155.77) FATOR1=rep(rep(c(&quot;L&quot;,&quot;EL&quot;), e=12),5); FATOR1=factor(FATOR1) FATOR2=rep(c(paste(&quot;T&quot;,1:5)),e=24); FATOR2=factor(FATOR2) repe=rep(c(paste(&quot;R&quot;,1:12)),10); repe=factor(repe) dados = data.frame(FATOR1,FATOR2,repe,RESP) 8.0.2 Fator1 x Fator 2 with(dados, interaction.plot(FATOR1, FATOR2, RESP)) 8.0.3 Editando o gráfico with(dados, interaction.plot(FATOR1, FATOR2, RESP, las=1, col=1:6, bty=&#39;l&#39;, ylab=&#39;CBM&#39;, trace.label=&quot;FATOR2&quot;)) 8.0.4 Fator2 x Fator 1 with(dados, interaction.plot(FATOR2, FATOR1, RESP)) 8.0.5 Editando o gráfico with(dados, interaction.plot(FATOR2,FATOR1, RESP, las=1, col=c(&quot;blue&quot;,&quot;red&quot;), bty=&#39;l&#39;,xlab=&#39;&#39;, ylab=&#39;CBM&#39;, trace.label=&quot;repe&quot;)) 8.1 Usando o interaction(s) 8.1.1 Conjunto de dados Este conjunto de dados pertence ao pacote ExpDes.pt (data6). Ao qual é composto de três fatores (fatorA, fatorB e fatorC), cuja resposta é nomeada como resp. x=scan(dec=&quot;,&quot;,text=&quot; 1 1 1 1 1 10,0 2 1 1 1 2 10,8 3 1 1 1 3 9,8 4 1 1 2 1 10,3 5 1 1 2 2 11,3 6 1 1 2 3 10,3 7 1 2 1 1 9,7 8 1 2 1 2 10,1 9 1 2 1 3 10,2 10 1 2 2 1 9,4 11 1 2 2 2 11,6 12 1 2 2 3 9,1 13 2 1 1 1 9,2 14 2 1 1 2 8,6 15 2 1 1 3 10,1 16 2 1 2 1 9,3 17 2 1 2 2 10,3 18 2 1 2 3 9,1 19 2 2 1 1 11,5 20 2 2 1 2 9,5 21 2 2 1 3 10,8 22 2 2 2 1 10,7 23 2 2 2 2 10,4 24 2 2 2 3 9,6 &quot;) data=data.frame(t(matrix(x,6,24))) colnames(data)=c(&quot;N&quot;,&quot;fatorA&quot;, &quot;fatorB&quot;, &quot;fatorC&quot;,&quot;rep&quot;,&quot;resp&quot;) data ## N fatorA fatorB fatorC rep resp ## 1 1 1 1 1 1 10,0 ## 2 2 1 1 1 2 10,8 ## 3 3 1 1 1 3 9,8 ## 4 4 1 1 2 1 10,3 ## 5 5 1 1 2 2 11,3 ## 6 6 1 1 2 3 10,3 ## 7 7 1 2 1 1 9,7 ## 8 8 1 2 1 2 10,1 ## 9 9 1 2 1 3 10,2 ## 10 10 1 2 2 1 9,4 ## 11 11 1 2 2 2 11,6 ## 12 12 1 2 2 3 9,1 ## 13 13 2 1 1 1 9,2 ## 14 14 2 1 1 2 8,6 ## 15 15 2 1 1 3 10,1 ## 16 16 2 1 2 1 9,3 ## 17 17 2 1 2 2 10,3 ## 18 18 2 1 2 3 9,1 ## 19 19 2 2 1 1 11,5 ## 20 20 2 2 1 2 9,5 ## 21 21 2 2 1 3 10,8 ## 22 22 2 2 2 1 10,7 ## 23 23 2 2 2 2 10,4 ## 24 24 2 2 2 3 9,6 8.1.2 Separado por Fator A par(mfrow=c(1,2)) interaction.plot(data$fatorB[data$fatorA==&quot;1&quot;], data$fatorC[data$fatorA==&quot;1&quot;], data$resp[data$fatorA==&quot;1&quot;]) interaction.plot(data$fatorB[data$fatorA==&quot;2&quot;], data$fatorC[data$fatorA==&quot;2&quot;], data$resp[data$fatorA==&quot;2&quot;]) 8.1.3 Alterando escala do eixo Y par(mfrow=c(1,2)) interaction.plot(data$fatorB[data$fatorA==&quot;1&quot;], data$fatorC[data$fatorA==&quot;1&quot;], data$resp[data$fatorA==&quot;1&quot;], las=1) interaction.plot(data$fatorB[data$fatorA==&quot;2&quot;], data$fatorC[data$fatorA==&quot;2&quot;], data$resp[data$fatorA==&quot;2&quot;], las=1) 8.1.4 Título do eixo x e y par(mfrow=c(1,2)) interaction.plot(data$fatorB[data$fatorA==&quot;1&quot;], data$fatorC[data$fatorA==&quot;1&quot;], data$resp[data$fatorA==&quot;1&quot;], las=1, xlab=&quot;Fator B&quot;, ylab=&quot;Resposta&quot;) interaction.plot(data$fatorB[data$fatorA==&quot;2&quot;], data$fatorC[data$fatorA==&quot;2&quot;], data$resp[data$fatorA==&quot;2&quot;], las=1, xlab=&quot;Fator B&quot;, ylab=&quot;Resposta&quot;) 8.1.5 Removendo linhas da caixa par(mfrow=c(1,2)) interaction.plot(data$fatorB[data$fatorA==&quot;1&quot;], data$fatorC[data$fatorA==&quot;1&quot;], data$resp[data$fatorA==&quot;1&quot;], las=1, xlab=&quot;Fator B&quot;, ylab=&quot;Resposta&quot;, bty=&quot;l&quot;) interaction.plot(data$fatorB[data$fatorA==&quot;2&quot;], data$fatorC[data$fatorA==&quot;2&quot;], data$resp[data$fatorA==&quot;2&quot;], las=1, xlab=&quot;Fator B&quot;, ylab=&quot;Resposta&quot;, bty=&quot;l&quot;) 8.1.6 Cor da linhas par(mfrow=c(1,2)) interaction.plot(data$fatorB[data$fatorA==&quot;1&quot;], data$fatorC[data$fatorA==&quot;1&quot;], data$resp[data$fatorA==&quot;1&quot;], las=1, xlab=&quot;Fator B&quot;, ylab=&quot;Resposta&quot;, bty=&quot;l&quot;, col = c(&quot;red&quot;,&quot;blue&quot;)) interaction.plot(data$fatorB[data$fatorA==&quot;2&quot;], data$fatorC[data$fatorA==&quot;2&quot;], data$resp[data$fatorA==&quot;2&quot;], las=1, xlab=&quot;Fator B&quot;, ylab=&quot;Resposta&quot;, bty=&quot;l&quot;, col = c(&quot;red&quot;,&quot;blue&quot;)) 8.1.7 Título dos gráficos par(mfrow=c(1,2)) interaction.plot(data$fatorB[data$fatorA==&quot;1&quot;], data$fatorC[data$fatorA==&quot;1&quot;], data$resp[data$fatorA==&quot;1&quot;], las=1, xlab=&quot;Fator B&quot;, ylab=&quot;Resposta&quot;, bty=&quot;l&quot;, col = c(&quot;red&quot;,&quot;blue&quot;), main=&quot;Fator A = 1&quot;) interaction.plot(data$fatorB[data$fatorA==&quot;2&quot;], data$fatorC[data$fatorA==&quot;2&quot;], data$resp[data$fatorA==&quot;2&quot;], las=1, xlab=&quot;Fator B&quot;, ylab=&quot;Resposta&quot;, bty=&quot;l&quot;, col = c(&quot;red&quot;,&quot;blue&quot;), main=&quot;Fator A = 2&quot;) 8.1.8 Título da legenda par(mfrow=c(1,2)) interaction.plot(data$fatorB[data$fatorA==&quot;1&quot;], data$fatorC[data$fatorA==&quot;1&quot;], data$resp[data$fatorA==&quot;1&quot;], las=1, xlab=&quot;Fator B&quot;, ylab=&quot;Resposta&quot;, bty=&quot;l&quot;, col = c(&quot;red&quot;,&quot;blue&quot;), main=&quot;Fator A = 1&quot;, trace.label = &quot;Fator C&quot;) interaction.plot(data$fatorB[data$fatorA==&quot;2&quot;], data$fatorC[data$fatorA==&quot;2&quot;], data$resp[data$fatorA==&quot;2&quot;], las=1, xlab=&quot;Fator B&quot;, ylab=&quot;Resposta&quot;, bty=&quot;l&quot;, col = c(&quot;red&quot;,&quot;blue&quot;), main=&quot;Fator A = 2&quot;, trace.label = &quot;Fator C&quot;) 8.1.9 Pontos da média Calculando as médias # Média para nível 1 do fator A media=with(data, tapply(resp[fatorA==&quot;1&quot;], list(fatorB[fatorA==&quot;1&quot;], fatorC[fatorA==&quot;1&quot;]), mean)) # Média e desvio-padrão para nível 2 do fator A media1=with(data, tapply(resp[fatorA==&quot;2&quot;], list(fatorB[fatorA==&quot;2&quot;], fatorC[fatorA==&quot;2&quot;]), mean)) par(mfrow=c(1,2)) interaction.plot(data$fatorB[data$fatorA==&quot;1&quot;], data$fatorC[data$fatorA==&quot;1&quot;], data$resp[data$fatorA==&quot;1&quot;], las=1, xlab=&quot;Fator B&quot;, ylab=&quot;Resposta&quot;, bty=&quot;l&quot;, col = c(&quot;red&quot;,&quot;blue&quot;), main=&quot;Fator A = 1&quot;, trace.label = &quot;Fator C&quot;) points(c(1,2,1,2),media, col=&quot;red&quot;, pch=16) interaction.plot(data$fatorB[data$fatorA==&quot;2&quot;], data$fatorC[data$fatorA==&quot;2&quot;], data$resp[data$fatorA==&quot;2&quot;], las=1, xlab=&quot;Fator B&quot;, ylab=&quot;Resposta&quot;, bty=&quot;l&quot;, col = c(&quot;red&quot;,&quot;blue&quot;), main=&quot;Fator A = 2&quot;, trace.label = &quot;Fator C&quot;) points(c(1,2,1,2),media1, col=&quot;red&quot;, pch=16) 8.1.10 Barras de desvio-padrão Calculando os desvios-padrões # Desvio-padrão para nível 1 do fator A desvio=with(data, tapply(resp[fatorA==&quot;1&quot;], list(fatorB[fatorA==&quot;1&quot;], fatorC[fatorA==&quot;1&quot;]), sd)) # Desvio-padrão para nível 2 do fator A desvio1=with(data, tapply(resp[fatorA==&quot;2&quot;], list(fatorB[fatorA==&quot;2&quot;], fatorC[fatorA==&quot;2&quot;]), sd)) par(mfrow=c(1,2)) interaction.plot(data$fatorB[data$fatorA==&quot;1&quot;], data$fatorC[data$fatorA==&quot;1&quot;], data$resp[data$fatorA==&quot;1&quot;], las=1, args.legend=list(x=&quot;topleft&quot;), xlab=&quot;Fator B&quot;, ylim=c(8,13), ylab=&quot;Resposta&quot;, bty=&quot;l&quot;, col = c(&quot;red&quot;,&quot;blue&quot;), main=&quot;Fator A = 1&quot;, trace.label = &quot;Fator C&quot;) points(c(1,2,1,2),media, col=&quot;red&quot;, pch=16) arrows(c(1,2,1,2), media+desvio,c(1,2,1,2),media-desvio, code=3,angle=90,length = 0.1, col=c(&quot;red&quot;,&quot;red&quot;,&quot;blue&quot;,&quot;blue&quot;)) interaction.plot(data$fatorB[data$fatorA==&quot;2&quot;], data$fatorC[data$fatorA==&quot;2&quot;], data$resp[data$fatorA==&quot;2&quot;], las=1, xlab=&quot;Fator B&quot;, ylim=c(8,13), ylab=&quot;Resposta&quot;, bty=&quot;l&quot;, col = c(&quot;red&quot;,&quot;blue&quot;), main=&quot;Fator A = 2&quot;, trace.label = &quot;Fator C&quot;) points(c(1,2,1,2),media1, col=&quot;red&quot;, pch=16) arrows(c(1,2,1,2), media1+desvio1,c(1,2,1,2),media1-desvio1, code=3,angle=90,length = 0.1, col=c(&quot;red&quot;,&quot;red&quot;,&quot;blue&quot;,&quot;blue&quot;)) 8.2 Pacote dae 8.2.1 Conjunto de dados resp=c(4599.55,6203.50,4566.02,5616.38,4978.35,5126.15,4816.23,4251.00,4106.79, 4600.58,4012.14,4623.41,4274.16,4683.50,4433.33,4326.16,4932.66,5066.67, 4697.29,5011.38,5156.72,4744.21,4826.80,4663.26,4807.19,4377.19,4442.07, 4685.58,5066.90,5317.66,5144.19,4580.18,4860.37,5204.21,5146.19,5015.67, 5801.99,4668.05,5393.16,5282.27,5369.41,5494.43,4980.32,5715.76,4754.54, 5000.83,4664.11,4969.41,5315.43,4872.29,5546.79,4765.79,4649.63,4899.31, 4890.89,5117.10,4942.97,4548.97,4916.97,4225.38,4820.21,4150.44,4648.46, 4271.57,5143.54,4808.97,5459.66,4928.35,5224.70,4900.90,4770.88,4977.68, 5816.80,5107.11,5555.80,5767.65,5117.10,5573.08,5673.87,4859.00,4687.26, 5055.22,5235.22,4961.72,4984.93,5425.67,4978.33,5172.60,5328.07,4973.87, 5296.55,4928.01,4528.12,5337.93,5809.20,4914.70,5191.89,5261.24,5287.53, 5680.55,5080.06,5425.53,4949.13,5300.57,4481.23,5039.54,5223.75,4581.65) FATOR1=rep(rep(c(&quot;A1&quot;,&quot;A2&quot;,&quot;A3&quot;), e=12),3) FATOR2=rep(c(&quot;B1&quot;,&quot;B2&quot;,&quot;B3&quot;), e=36) FATOR3=rep(rep(c(&quot;C1&quot;,&quot;c2&quot;,&quot;c3&quot;),e=4),9) dados=data.frame(FATOR1,FATOR2,FATOR3,resp) 8.2.2 Gráfico com a média Para se construir esse gráfico é necessário instalar o pacote dae library(dae) interaction.ABC.plot(resp,FATOR1,FATOR2,FATOR3,data=dados) interaction.ABC.plot(resp,FATOR1,FATOR3,FATOR2,data=dados) interaction.ABC.plot(resp,FATOR2,FATOR3,FATOR1,data=dados) interaction.ABC.plot(resp,FATOR2,FATOR1,FATOR3,data=dados) interaction.ABC.plot(resp,FATOR3,FATOR2,FATOR1,data=dados) interaction.ABC.plot(resp,FATOR3,FATOR1,FATOR2,data=dados) 8.2.3 Média e desvio-padrão media=tapply(resp, paste(FATOR1,FATOR2,FATOR3),mean) desvio=tapply(resp, paste(FATOR1,FATOR2,FATOR3),sd) (F1=rep(c(&quot;A1&quot;,&quot;A2&quot;,&quot;A3&quot;), e=9)) ## [1] &quot;A1&quot; &quot;A1&quot; &quot;A1&quot; &quot;A1&quot; &quot;A1&quot; &quot;A1&quot; &quot;A1&quot; &quot;A1&quot; &quot;A1&quot; &quot;A2&quot; &quot;A2&quot; &quot;A2&quot; &quot;A2&quot; &quot;A2&quot; &quot;A2&quot; ## [16] &quot;A2&quot; &quot;A2&quot; &quot;A2&quot; &quot;A3&quot; &quot;A3&quot; &quot;A3&quot; &quot;A3&quot; &quot;A3&quot; &quot;A3&quot; &quot;A3&quot; &quot;A3&quot; &quot;A3&quot; (F2=rep(rep(c(&quot;B1&quot;,&quot;B2&quot;,&quot;B3&quot;), e=3),3)) ## [1] &quot;B1&quot; &quot;B1&quot; &quot;B1&quot; &quot;B2&quot; &quot;B2&quot; &quot;B2&quot; &quot;B3&quot; &quot;B3&quot; &quot;B3&quot; &quot;B1&quot; &quot;B1&quot; &quot;B1&quot; &quot;B2&quot; &quot;B2&quot; &quot;B2&quot; ## [16] &quot;B3&quot; &quot;B3&quot; &quot;B3&quot; &quot;B1&quot; &quot;B1&quot; &quot;B1&quot; &quot;B2&quot; &quot;B2&quot; &quot;B2&quot; &quot;B3&quot; &quot;B3&quot; &quot;B3&quot; (F3=rep(c(&quot;C1&quot;,&quot;c2&quot;,&quot;c3&quot;),9)) ## [1] &quot;C1&quot; &quot;c2&quot; &quot;c3&quot; &quot;C1&quot; &quot;c2&quot; &quot;c3&quot; &quot;C1&quot; &quot;c2&quot; &quot;c3&quot; &quot;C1&quot; &quot;c2&quot; &quot;c3&quot; &quot;C1&quot; &quot;c2&quot; &quot;c3&quot; ## [16] &quot;C1&quot; &quot;c2&quot; &quot;c3&quot; &quot;C1&quot; &quot;c2&quot; &quot;c3&quot; &quot;C1&quot; &quot;c2&quot; &quot;c3&quot; &quot;C1&quot; &quot;c2&quot; &quot;c3&quot; paste(F1,F2,F3) # tratamentos ## [1] &quot;A1 B1 C1&quot; &quot;A1 B1 c2&quot; &quot;A1 B1 c3&quot; &quot;A1 B2 C1&quot; &quot;A1 B2 c2&quot; &quot;A1 B2 c3&quot; ## [7] &quot;A1 B3 C1&quot; &quot;A1 B3 c2&quot; &quot;A1 B3 c3&quot; &quot;A2 B1 C1&quot; &quot;A2 B1 c2&quot; &quot;A2 B1 c3&quot; ## [13] &quot;A2 B2 C1&quot; &quot;A2 B2 c2&quot; &quot;A2 B2 c3&quot; &quot;A2 B3 C1&quot; &quot;A2 B3 c2&quot; &quot;A2 B3 c3&quot; ## [19] &quot;A3 B1 C1&quot; &quot;A3 B1 c2&quot; &quot;A3 B1 c3&quot; &quot;A3 B2 C1&quot; &quot;A3 B2 c2&quot; &quot;A3 B2 c3&quot; ## [25] &quot;A3 B3 C1&quot; &quot;A3 B3 c2&quot; &quot;A3 B3 c3&quot; 8.2.4 Criando uma data.frame data=data.frame(F1,F2,F3,media,desvio) 8.2.5 Construindo o gráfico interaction.ABC.plot(media,F1,F2,F3,data=data, ggplotFunc= list(geom_errorbar(data=data, aes(ymax=media+desvio, ymin=media-desvio), width=0.2))) "],
["perfil-individual.html", " 9 Perfil Individual", " 9 Perfil Individual 9.0.1 Conjunto de dados Um experimento foi realizado com o intuito de avaliar 5 manejos na entrelinha do pomar de laranja Natal e sua influência em relação a linha de plantio. O experimento foi instalado em Delineamento em blocos casualizados com 12 repetições por tratamento em esquema de parcelas subdividida (2 [linha e entrelinha] x 5[ U. brizantha (T1),U. decumbens (T2), U. ruziziensis (T3), Glifosato (T4), Pousio (T5). Foi analisado o carbono da biomassa microbiana (CBM). RESP=c(224.92, 180.32, 130.19, 110.31, 163.74,193.03, 211.49, 137.65, 127.15, 203.39,182.36, 124.75, 177.70, 231.01, 202.14,214.89, 198.42, 267.85, 207.67, 176.74,162.18, 124.59, 158.99, 209.12, 128.14,113.95, 215.53, 190.51, 174.58, 148.70,150.90, 209.03, 210.40, 199.03, 237.05,196.97, 176.06, 263.27, 240.19, 160.72,239.90, 188.07, 251.35, 215.45, 198.50,271.42, 226.56, 217.65, 213.69, 101.26,115.41, 140.10, 117.67, 106.45, 139.34,104.22, 206.13, 195.89, 147.11, 122.93,176.55, 173.63, 112.83, 184.82, 178.18,115.85, 183.89, 134.92, 086.49, 103.96,096.33, 091.64, 157.76, 107.45, 106.61,095.28, 152.37, 066.02, 125.75, 075.34,088.64, 104.00, 066.38, 084.74, 101.76,173.70, 101.24, 143.71, 119.88, 157.79,070.42, 152.75, 111.65, 153.08, 146.64,142.57, 098.96, 065.92, 065.62, 063.26,095.72, 084.14, 054.92, 090.49, 112.11,102.68, 144.77, 122.58, 125.14, 127.61,117.14, 147.87, 156.18, 154.82, 183.91,159.11, 155.41, 184.55, 121.39, 155.77) FATOR1=rep(rep(c(&quot;L&quot;,&quot;EL&quot;), e=12),5); FATOR1=factor(FATOR1) FATOR2=rep(c(paste(&quot;T&quot;,1:5)),e=24); FATOR2=factor(FATOR2) repe=rep(c(paste(&quot;R&quot;,1:12)),10); repe=factor(repe) dados = data.frame(FATOR1,FATOR2,repe,RESP) 9.0.2 Fator 2 x Fator 1 library(lattice) with(dados, xyplot(RESP ~ FATOR1|FATOR2, groups=repe)) with(dados, xyplot(RESP ~ FATOR1|FATOR2, groups=repe, aspect=&quot;xy&quot;)) with(dados, xyplot(RESP ~ FATOR1|FATOR2, groups=repe, aspect=&quot;xy&quot;, type=&quot;o&quot;)) with(dados, xyplot(RESP ~ FATOR1|FATOR2, groups=repe, aspect=&quot;xy&quot;, type=&quot;o&quot;, ylab=&#39;CBM&#39;,strip=strip.custom(strip.names=TRUE, strip.levels=TRUE))) 9.0.3 Fator 1 x Fator 2 with(dados, xyplot(RESP ~ FATOR2|FATOR1, groups=repe, type=&quot;o&quot;, ylab=&#39;CBM&#39;, strip=strip.custom(strip.names=TRUE,strip.levels=TRUE))) "],
["linhas.html", " 10 Linhas 10.1 Eixo secundário 10.2 Usando o pacote ggplot2", " 10 Linhas Gráficos de linhas ou pontos são normalmente usados para controlar alterações ao longo do tempo e para facilitar a identificação de tendências ou de anomalias. 10.0.1 Conjunto de dados Esse conjunto de dados de Umidade relativa (UR) foi obtido no site do Instituto Agronômico do Paraná (http://www.iapar.br/modules/conteudo/conteudo.php?conteudo=1828) no período de 01/09/2018 a 21/02/2019. UR=c(68,93,86,55,54,51,45,43,55,54,58,57,64,89,73,80,96,71,86,95,74,62,49,43,51,62,86,73,64,95,68,77,86,93,76,63,69,94,88,89,88,67,76,84,71,88,83,83,74,54,51,61,74,97,94,97,66,58,65,56,82,93,66,64,67,65,67,67,63,62,76,51,57,54,80,65,65,65,93,88,63,68,65,98,83,64,67,62,59,78,75,70,63,62,53,46,42,55,60,51,51,47,42,60,62,77,74,58,63,67,66,83,81,87,95,80,71,68,74,69,75,74,75,90,86,91,91,98,84,81,74,82,69,77,84,78,74,87,75,80,89,90,77,73,82,80,82,75,79,70,61,63,74,63,58,62,76,76,74,69,64,56,61,86,94,85,78,91,82,80,81,85,89,84) TEMPO=c(1:174) 10.0.2 Gráfico de dispersão plot(UR~TEMPO, ylab=&quot;Umidade Relativa (%)&quot;, xlab=&quot;Tempo (Dias)&quot;, col=&quot;blue&quot;, las=1) 10.0.3 Gráfico com as linhas plot(UR~TEMPO, ylab=&quot;Umidade Relativa (%)&quot;, xlab=&quot;Tempo (Dias)&quot;, type=&quot;lines&quot;, col=&quot;blue&quot;, las=1) 10.0.4 Gráfico com linhas e pontos plot(UR~TEMPO, ylab=&quot;Umidade Relativa (%)&quot;, xlab=&quot;Tempo (Dias)&quot;, type=&quot;b&quot;, col=&quot;blue&quot;, las=1) plot(UR~TEMPO, ylab=&quot;Umidade Relativa (%)&quot;, xlab=&quot;Tempo (Dias)&quot;, type=&quot;o&quot;, col=&quot;blue&quot;, las=1) 10.0.5 Linhas verticais plot(UR~TEMPO, ylab=&quot;Umidade Relativa (%)&quot;, xlab=&quot;Tempo (Dias)&quot;, type=&quot;h&quot;, col=&quot;blue&quot;, las=1) 10.0.6 Formato em escada plot(UR~TEMPO, ylab=&quot;Umidade Relativa (%)&quot;, xlab=&quot;Tempo (Dias)&quot;, type=&quot;s&quot;, col=&quot;blue&quot;, las=1) 10.0.7 Juntando os 6 gráficos par(mfrow=c(2,3)) plot(UR~TEMPO,cex=0.5, ylab=&quot;Umidade Relativa (%)&quot;, xlab=&quot;Tempo (Dias)&quot;, col=&quot;blue&quot;, las=1) plot(UR~TEMPO,cex=0.5, ylab=&quot;Umidade Relativa (%)&quot;, xlab=&quot;Tempo (Dias)&quot;, type=&quot;lines&quot;, col=&quot;blue&quot;, las=1) plot(UR~TEMPO,cex=0.5, ylab=&quot;Umidade Relativa (%)&quot;, xlab=&quot;Tempo (Dias)&quot;, type=&quot;b&quot;, col=&quot;blue&quot;, las=1) plot(UR~TEMPO,cex=0.5, ylab=&quot;Umidade Relativa (%)&quot;, xlab=&quot;Tempo (Dias)&quot;, type=&quot;o&quot;, col=&quot;blue&quot;, las=1) plot(UR~TEMPO,cex=0.5, ylab=&quot;Umidade Relativa (%)&quot;, xlab=&quot;Tempo (Dias)&quot;, type=&quot;h&quot;, col=&quot;blue&quot;, las=1) plot(UR~TEMPO,cex=0.5, ylab=&quot;Umidade Relativa (%)&quot;, xlab=&quot;Tempo (Dias)&quot;, type=&quot;s&quot;, col=&quot;blue&quot;, las=1) 10.1 Eixo secundário 10.1.1 Conjunto de dados TM=c(23.4,19.8,12.8,16.3,20.8,17.4,20.0,21.8,21.8,20.6,20.3,20.6,20.4,18.1,20.2,19.3,17.2,20.8,20.7,17.4,21.8,23.8,25.8,26.3,25.3,24.5,21.4,23.3,24.3,21.2,24.3,23.6,23.5,22.3,21.4,19.7,22.1,20.5,22.3,21.8,18.0,21.3,24.1,23.9,23.6,23.3,23.2,22.0,22.4,20.8,20.2,22.6,23.7,19.9,19.7,21.4,22.5,21.4,20.4,24.5,22.7,20.3,23.7,24.0,23.6,21.6,22.0,22.6,21.3,22.5,22.2,26.3,27.2,28.3,25.9,25.8,26.6,24.9,20.8,19.4,21.6,22.2,23.8,20.9,22.9,25.0,23.7,23.8,24.8,24.8) UR=c(68,93,86,55,54,51,45,43,55,54,58,57,64,89,73,80,96,71,86,95,74,62,49,43,51,62,86,73,64,95,68,77,86,93,76,63,69,94,88,89,88,67,76,84,71,88,83,83,74,54,51,61,74,97,94,97,66,58,65,56,82,93,66,64,67,65,67,67,63,62,76,51,57,54,80,65,65,65,93,88,63,68,65,98,83,64,67,62,59,78) TEMPO=c(1:90) 10.1.2 Linhas individuais par(mfrow=c(1,2)) # mudando parâmetro gráfico para plotar dois graficos lado a lado plot(TM~TEMPO, ylab=&quot;Temperatura&quot;) plot(UR~TEMPO, ylab=&quot;Umidade relativa&quot;) 10.1.3 Editando gráficos par(mfrow=c(1,2)) plot(TM~TEMPO, ylim=c(0,50), # mudando escala de Y las=2, # deixando marcador de escala na vertical type=&quot;l&quot;, # mudando tipo de gráfico para linhas ylab=&#39;Temperatura&#39;, # modificando nome do eixo Y xlab=&quot;Tempo (minutos)&quot;) # modificando nome do eixo x plot(UR~TEMPO, ylim=c(0,100), las=2, type=&quot;l&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, lty=4) # modificando formato de linha 10.1.4 Sobrepor os gráficos par(mar=c(4,4,3,4)) # modificando a largura da margem (inferior, esquerda, superior, direita) plot(TM~TEMPO, ylim=c(0,50), las=2, type=&quot;l&quot;, ylab=&#39;Temperatura&#39;, xlab=&quot;Tempo (minutos)&quot;) par(new=T) # comando para sobrepor gráficos plot(UR~TEMPO, ylim=c(0,100), las=2, type=&quot;l&quot;, xlab=&quot;&quot;, ylab=&quot;&quot;, lty=4) 10.1.5 Marca das escalas par(mar=c(4,4,3,4)) plot(TM~TEMPO, ylim=c(0,50), las=2, type=&quot;l&quot;, axes=F, # argumento para remover as escalas ylab=&#39;Temperatura&#39;, xlab=&quot;Tempo (minutos)&quot;) par(new=T) plot(UR~TEMPO, ylim=c(0,100), las=2, type=&quot;l&quot;, axes=F, # argumento para remover as escalas xlab=&quot;&quot;, ylab=&quot;&quot;, lty=4) par(mar=c(4,4,3,4)) plot(TM~TEMPO, ylim=c(0,50), las=2, type=&quot;l&quot;, axes=F, lty=1, ylab=&#39;Temperatura&#39;, xlab=&quot;Tempo (minutos)&quot;) par(new=T) plot(UR~TEMPO, ylim=c(0,100), las=2, type=&quot;l&quot;, axes=F, xlab=&quot;&quot;, ylab=&quot;&quot;, lty=4) axis(2,las=2, ylim=c(0,50)) # escala do eixo y primário axis(4,las=2) # escala do eixo y secundário axis(side=1,las=1, at=seq(0, 100, by=10)) # escala do eixo x ## Obs. at=seq(0, 100, by=10) estou definindo um intervalo de 0 a 100 como marca a cada 10 unidades 10.1.6 Nome do eixo Y secundário par(mar=c(4,4,3,4)) plot(TM~TEMPO, ylim=c(0,50), las=2, type=&quot;l&quot;, axes=F, lty=1, ylab=&#39;Temperatura&#39;, xlab=&quot;Tempo (minutos)&quot;) par(new=T) plot(UR~TEMPO, ylim=c(0,100), las=2, type=&quot;l&quot;, axes=F, xlab=&quot;&quot;, ylab=&quot;&quot;, lty=4) axis(4,las=2) axis(2,las=2) axis(side=1,las=1, at=seq(0, 100, by=10)) text(par(&quot;usr&quot;)[2]*1.11,mean(par(&quot;usr&quot;)[3:4]), &quot;UR (%)&quot;, srt = -90, xpd = TRUE, pos = 4) 10.1.7 Adicionando legenda par(mar=c(4,4,3,4)) plot(TM~TEMPO, ylim=c(0,50), las=2, type=&quot;l&quot;, axes=F, lty=1, ylab=&#39;Temperatura&#39;, xlab=&quot;Tempo (minutos)&quot;) par(new=T) plot(UR~TEMPO, ylim=c(0,100), las=2, type=&quot;l&quot;, axes=F, xlab=&quot;&quot;, ylab=&quot;&quot;, lty=4) axis(4,las=2) axis(2,las=2) axis(side=1,las=1, at=seq(0, 100, by=10)) text(par(&quot;usr&quot;)[2]*1.11,mean(par(&quot;usr&quot;)[3:4]), &quot;UR (%)&quot;, srt = -90, xpd = TRUE, pos = 4) legend(&quot;bottomleft&quot;, # posição da legenda lty=c(1,4), # formato do tracejado legend=c(expression(&quot;Temperatura&quot;^&quot;o&quot;*C),&quot;Umidade Relativa (%)&quot;), bty=&quot;n&quot;) # caixa da legenda sem margem 10.1.8 Conjunto de dados Esse conjunto de dados de temperatura média (TM) e Umidade relativa (UR) foi obtido no site do Instituto Agronômico do Paraná (http://www.iapar.br/modules/conteudo/conteudo.php?conteudo=1828) no período de 01/09/2018 a 21/02/2019. TM=c(23.4,19.8,12.8,16.3,20.8,17.4,20.0,21.8,21.8,20.6,20.3,20.6,20.4,18.1,20.2,19.3,17.2,20.8,20.7,17.4,21.8,23.8,25.8,26.3,25.3,24.5,21.4,23.3,24.3,21.2,24.3,23.6,23.5,22.3,21.4,19.7,22.1,20.5,22.3,21.8,18.0,21.3,24.1,23.9,23.6,23.3,23.2,22.0,22.4,20.8,20.2,22.6,23.7,19.9,19.7,21.4,22.5,21.4,20.4,24.5,22.7,20.3,23.7,24.0,23.6,21.6,22.0,22.6,21.3,22.5,22.2,26.3,27.2,28.3,25.9,25.8,26.6,24.9,20.8,19.4,21.6,22.2,23.8,20.9,22.9,25.0,23.7,23.8,24.8,24.8,24.8,25.4,24.4,23.5,24.7,25.3,25.2,23.8,22.8,22.2,26.0,27.8,28.1,25.8,26.8,25.3,25.0,26.6,26.4,26.7,26.8,25.5,24.0,23.2,22.6,23.4,24.5,25.7,25.0,26.4,26.2,26.2,26.9,24.7,25.6,25.0,23.7,22.8,25.5,26.3,26.9,25.1,26.7,25.6,24.5,26.2,26.2,24.4,26.3,25.6,24.4,24.0,26.7,28.2,26.3,26.7,25.4,24.8,24.6,26.3,28.7,28.6,26.3,28.6,29.0,28.2,24.3,23.0,22.9,24.6,26.6,28.5,28.0,25.5,23.2,23.7,23.0,22.4,23.6,23.6,23.5,23.5,22.9,23.5) UR=c(68,93,86,55,54,51,45,43,55,54,58,57,64,89,73,80,96,71,86,95,74,62,49,43,51,62,86,73,64,95,68,77,86,93,76,63,69,94,88,89,88,67,76,84,71,88,83,83,74,54,51,61,74,97,94,97,66,58,65,56,82,93,66,64,67,65,67,67,63,62,76,51,57,54,80,65,65,65,93,88,63,68,65,98,83,64,67,62,59,78,75,70,63,62,53,46,42,55,60,51,51,47,42,60,62,77,74,58,63,67,66,83,81,87,95,80,71,68,74,69,75,74,75,90,86,91,91,98,84,81,74,82,69,77,84,78,74,87,75,80,89,90,77,73,82,80,82,75,79,70,61,63,74,63,58,62,76,76,74,69,64,56,61,86,94,85,78,91,82,80,81,85,89,84) TEMPO=c(1:174) 10.1.9 Linhas individuais Utilizando o comando plot do próprio pacote stats do R podemos fazer um gráfico de linhas para cada uma das variáveis. plot(TM~TEMPO, type=&quot;lines&quot;, col=&quot;red&quot;, las=1) plot(UR~TEMPO, type=&quot;lines&quot;, col=&quot;blue&quot;, las=1) 10.2 Usando o pacote ggplot2 Obs. Instalar pacote 10.2.1 Criando a data.frame data=data.frame(tempo=TEMPO,Umidade=UR,Temperatura=TM) attach(data) library(ggplot2) 10.2.2 Gráficos individuais ggplot(data, aes(x = tempo))+ geom_line(aes(y = Temperatura, colour = &quot;Temperatura&quot;), col=&quot;red&quot;)+ xlab(&quot;Tempo (dias)&quot;) ggplot(data, aes(x = tempo))+geom_line(aes(y = Umidade, colour = &quot;Umidade&quot;), col=&quot;blue&quot;)+ xlab(&quot;Tempo (dias)&quot;) 10.2.3 Juntandos os gráficos (plots=ggplot(data, aes(x = tempo)) + geom_line(aes(y = Umidade, colour = &quot;Umidade&quot;))+ scale_x_continuous() + geom_line(aes(y = Temperatura, colour = &quot;Temperatura&quot;))) 10.2.4 Eixo Y secundário (plots=plots + scale_y_continuous(sec.axis = sec_axis(~ . *1 ), limits = c(0, 100))) 10.2.5 Nomeando eixo Y (plots=plots+ scale_y_continuous(name = expression(&quot;Umidade (%)&quot;), sec.axis = sec_axis(~ . *1 , name = expression(&quot;Temperatura&quot;^o*&quot;C&quot;)))) 10.2.6 Organizando a legenda (plots=plots+ scale_colour_manual(&quot;&quot;, breaks = c(&quot;Umidade&quot;, &quot;Temperatura&quot;), values = c(&quot;red&quot;,&quot;blue&quot;))) 10.2.7 Linha de grade e cor de fundo (plots=plots+theme_bw()+ theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())) "],
["correlação.html", " 11 Correlação 11.1 Matriz de Correlação 11.2 Rede de correlação", " 11 Correlação A Matriz de Correlação possibilita a análise simultânea da associação entre variáveis, através do coeficiente de Pearson. Coeficiente de Pearson \\[\\rho = \\dfrac{\\sum_{i=1}^{n}(x_i-\\bar{x})(y_i-\\bar{y})}{\\sqrt{\\sum_{i=1}^n(x_i-\\bar{x})^2}\\sqrt{\\sum_{i=1}^{n}(y_i-\\bar{y})^2}}\\] 11.0.1 Conjunto de dados Variáveis: DPF: Dias para florescimento APF: Altura da planta no florescimento (cm) DPM: Dias para maturação APM: Altura da planta na maturação (cm) IPV: Inserção primeira vagem (cm) ACA: Acamamento PRO: Produtiviade de grãos em \\(Kg\\) \\(ha^-1\\) MCG: Massa de cem grãos (g) DPF=c(46.00,46.00,46.00,46.00,46.00,46.00,43.00,43.00,43.00,46.00,43.00,43.00,46.00,46.00,46.00,49.00,50.00,46.00,43.00,43.00,46.00,43.00,46.00,43.00,39.00,39.00,43.00,43.00,42.00,45.00,43.00,46.00,46.00,43.00,43.00,43.00,43.00,46.00,43.00,49.00,50.00,43.00,39.00,39.00,39.00) APF=c(58.33,55.00,50.00,41.00,35.67,43.33,35.67,36.00,35.33,46.67,36.67,49.00,38.33,43.67,44.33,41.00,48.00,43.67,32.67,28.67,36.67,38.33,46.33,53.33,38.00,33.00,32.67,45.67,48.33,46.67,33.67,36.67,42.67,37.00,43.67,35.33,42.33,47.00,47.00,59.67,59.00,48.33,32.33,36.33,33.33) DPM=c(105.00,105.00,102.00,110.00,110.00,112.00,110.00,110.00,105.00,112.00,112.00,110.00,110.00,112.00,112.00,112.00,112.00,112.00,110.00,105.00,105.00,110.00,102.00,102.00,110.00,105.00,110.00,110.00,110.00,104.00,105.00,105.00,104.00,104.00,104.00,102.00,104.00,105.00,102.00,110.00,112.00,112.00,102.00,102.00,102.00) APM=c(100.00,90.33,97.00,91.33,97.67,77.33,90.00,93.00,91.33,98.00,84.67,91.33,92.33,101.67,102.33,102.33,98.33,93.00,78.67,72.33,72.33,97.67,104.33,96.00,99.00,97.00,94.33,104.67,115.00,117.67,81.33,82.33,83.00,104.33,107.33,103.00,89.33,90.33,82.33,123.33,115.00,133.33,60.00,59.00,65.67) IPV=c(15.00,20.00,17.00,10.00,22.67,14.33,23.00,19.33,15.33,14.33,15.00,22.67,14.67,15.33,17.00,13.67,16.67,19.33,11.00,8.67,11.33,13.00,14.67,13.00,13.00,12.00,17.67,14.67,10.67,25.00,18.00,14.00,18.67,15.67,11.00,18.00,16.33,24.33,17.00,13.33,11.00,22.33,10.33,5.67,14.00) ACA=c(2.00,1.90,2.20,1.50,1.20,1.00,2.00,1.50,1.20,3.00,1.40,1.60,1.80,2.50,2.50,2.00,1.70,1.80,1.50,2.00,1.50,1.80,2.00,1.80,1.30,1.20,2.00,3.00,2.00,3.00,1.50,1.80,2.20,1.80,1.80,2.00,1.80,3.50,3.50,1.50,2.50,2.00,1.20,1.00,1.20) PRO=c(2444.44,2870.37,2314.81,2629.63,2444.44,2592.59,2962.96,3037.04,3037.04,2592.59,2296.30,2444.44,2370.37,3481.48,2555.56,1981.48,2611.11,1925.93,1870.37,2518.52,2370.37,2462.96,2351.85,2000.00,2703.70,2685.19,2166.67,2129.63,2222.22,1814.81,2537.04,2351.85,2333.33,3370.37,2462.96,3129.63,2666.67,2796.30,2055.56,2333.33,2240.74,2092.59,2703.70,2129.63,2740.74) MCG=c(10.78,10.96,10.07,10.77,11.17,11.24,12.57,13.35,13.77,14.23,13.61,13.30,11.85,11.80,12.04,10.10,10.19,9.97,12.15,11.35,11.70,12.83,11.52,11.10,10.95,11.14,10.26,12.51,11.87,12.30,14.20,13.13,14.70,13.08,12.76,13.74,14.59,13.98,13.52,12.72,12.22,12.63,10.93,10.65,10.67) dados=data.frame(DPF,APF,DPM,APM,IPV,ACA,PRO,MCG) 11.0.2 Matriz de correlação M&lt;-cor(dados) head(round(M,2)) ## DPF APF DPM APM IPV ACA PRO MCG ## DPF 1,00 0,56 0,39 0,39 0,21 0,33 -0,13 -0,04 ## APF 0,56 1,00 0,12 0,57 0,17 0,41 -0,23 -0,03 ## DPM 0,39 0,12 1,00 0,37 0,11 0,00 -0,08 -0,09 ## APM 0,39 0,57 0,37 1,00 0,32 0,35 -0,09 0,09 ## IPV 0,21 0,17 0,11 0,32 1,00 0,36 0,10 0,28 ## ACA 0,33 0,41 0,00 0,35 0,36 1,00 -0,14 0,30 Instalar pacote corrplot 11.0.3 Formato de Círculo library(corrplot) corrplot(M, method=&quot;circle&quot;) 11.0.4 Formato de quadrado preenchido corrplot(M, method=&quot;color&quot;) 11.0.5 Formato Numérico corrplot(M, method=&quot;number&quot;) 11.0.6 Circulo - matriz superior corrplot(M, type=&quot;upper&quot;) 11.0.7 Circulo - matriz inferior corrplot(M, type=&quot;lower&quot;) 11.0.8 Quadrado preenchido, número e sem a diagonal corrplot(M, method=&quot;color&quot;, type=&quot;upper&quot;, addCoef.col = &quot;black&quot;, insig = &quot;blank&quot;, diag=FALSE ) 11.0.9 Escala cinza corrplot(M, method=&quot;color&quot;, type=&quot;upper&quot;, col=gray.colors(100)[100:1], addCoef.col = &quot;black&quot;, insig = &quot;blank&quot;, diag=FALSE) 11.0.10 Cor da legenda corrplot(M, method=&quot;color&quot;, tl.col=&quot;black&quot;, type=&quot;upper&quot;, col=gray.colors(100)[100:1], addCoef.col = &quot;black&quot;, insig = &quot;blank&quot;, diag=FALSE ) 11.0.11 Modificando a fonte par(family=&quot;serif&quot;) corrplot(M, method=&quot;color&quot;, tl.col=&quot;black&quot;, type=&quot;upper&quot;, col=gray.colors(100)[100:1], addCoef.col = &quot;black&quot;, insig = &quot;blank&quot;, diag=FALSE ) 11.0.12 Cor do valor da correlação par(family=&quot;serif&quot;) corrplot(M, method=&quot;color&quot;, tl.col=&quot;black&quot;, type=&quot;upper&quot;, col=gray.colors(100)[100:1], addCoef.col = &quot;green&quot;, insig = &quot;blank&quot;, diag=FALSE ) 11.1 Matriz de Correlação 11.1.1 Conjunto de dados DPF=c(46.00,46.00,46.00,46.00,46.00,46.00,43.00,43.00,43.00,46.00,43.00,43.00,46.00,46.00,46.00,49.00,50.00,46.00,43.00,43.00,46.00,43.00,46.00,43.00,39.00,39.00,43.00,43.00,42.00,45.00,43.00,46.00,46.00,43.00,43.00,43.00,43.00,46.00,43.00,49.00,50.00,43.00,39.00,39.00,39.00) APF=c(58.33,55.00,50.00,41.00,35.67,43.33,35.67,36.00,35.33,46.67,36.67,49.00,38.33,43.67,44.33,41.00,48.00,43.67,32.67,28.67,36.67,38.33,46.33,53.33,38.00,33.00,32.67,45.67,48.33,46.67,33.67,36.67,42.67,37.00,43.67,35.33,42.33,47.00,47.00,59.67,59.00,48.33,32.33,36.33,33.33) DPM=c(105.00,105.00,102.00,110.00,110.00,112.00,110.00,110.00,105.00,112.00,112.00,110.00,110.00,112.00,112.00,112.00,112.00,112.00,110.00,105.00,105.00,110.00, 102.00,102.00,110.00,105.00,110.00,110.00,110.00,104.00,105.00,105.00,104.00,104.00,104.00,102.00,104.00,105.00,102.00,110.00,112.00,112.00,102.00,102.00,102.00) APM=c(100.00,90.33,97.00,91.33,97.67,77.33,90.00,93.00,91.33,98.00,84.67,91.33,92.33,101.67,102.33,102.33,98.33,93.00,78.67,72.33,72.33,97.67,104.33,96.00,99.00,97.00,94.33,104.67,115.00,117.67,81.33,82.33,83.00,104.33,107.33,103.00,89.33,90.33,82.33,123.33,115.00,133.33,60.00,59.00,65.67) IPV=c(15.00,20.00,17.00,10.00,22.67,14.33,23.00,19.33,15.33,14.33,15.00,22.67,14.67,15.33,17.00,13.67,16.67,19.33,11.00,8.67,11.33,13.00,14.67,13.00,13.00,12.00,17.67,14.67,10.67,25.00,18.00,14.00,18.67,15.67,11.00,18.00,16.33,24.33,17.00,13.33,11.00,22.33,10.33,5.67,14.00) ACA=c(2.00,1.90,2.20,1.50,1.20,1.00,2.00,1.50,1.20,3.00,1.40,1.60,1.80,2.50,2.50,2.00,1.70,1.80,1.50,2.00,1.50,1.80,2.00,1.80,1.30,1.20,2.00,3.00,2.00,3.00,1.50,1.80,2.20,1.80,1.80,2.00,1.80,3.50,3.50,1.50,2.50,2.00,1.20,1.00,1.20) PRO=c(2444.44,2870.37,2314.81,2629.63,2444.44,2592.59,2962.96,3037.04,3037.04,2592.59,2296.30,2444.44,2370.37,3481.48,2555.56,1981.48,2611.11,1925.93,1870.37,2518.52,2370.37,2462.96,2351.85,2000.00,2703.70,2685.19,2166.67,2129.63,2222.22,1814.81,2537.04,2351.85,2333.33,3370.37,2462.96,3129.63,2666.67,2796.30,2055.56,2333.33,2240.74,2092.59,2703.70,2129.63,2740.74) MCG=c(10.78,10.96,10.07,10.77,11.17,11.24,12.57,13.35,13.77,14.23,13.61,13.30,11.85,11.80,12.04,10.10,10.19,9.97,12.15,11.35,11.70,12.83,11.52,11.10,10.95,11.14,10.26,12.51,11.87,12.30,14.20,13.13,14.70,13.08,12.76,13.74,14.59,13.98,13.52,12.72,12.22,12.63,10.93,10.65,10.67) 11.1.2 Criando uma data.frame dados=data.frame(DPF,APF,DPM,APM,IPV,ACA,PRO,MCG) 11.1.3 Matriz de correlação corre=cor(dados[c(1:8),c(1:8)]) 11.1.4 Construindo o Gráfico Instalar pacote (PerformanceAnalytics) library(PerformanceAnalytics) chart.Correlation(dados, pch=19) 11.1.5 Conjunto de dados ph=c(5.4,6.7,6.8,5.9,6.3,6.2,6.3,6,6.1,5.8,6.7,5.7,6.8,6.9,6.5,6.9,6.8,6.7,6.5,6.5,6.7,6.7,6.5,6.7,6.6,6.8,6.4,4.6,6.5,6.6,6.3,6.2,5.5,4.5,5.2,6.5,6.3,6.6,6.4,6.6,6.6,6.5,6.5,6.4,6.5,6.8,6.7,6.6,5.9,6.1,6.3,6.3,6.2,5.3,5.8,6.1,6.7,6.7,6.6,6.6,6.6,6.8,6.8,6.7,6.9,7,7.1,7.1,6.7,6.7,6.6,6.6,6.3,5.8,6.2,6.3,6,5,6.3,5.3,5.4,6.4,6.7,6.5,6.5,6.4,6.7,6.5,6.8,6.2,6.1,6.2,6.8,6.7,6.6,6.4,6.7,6.6,6.4,5.9,6.5,6.6,5.9,6.8,6.8,6.7,6.5,6.7,6.9,6.5,6.8,6.7,6.8,6.6,6.7,6.7,6.9,6.9,6.7,6.8) HAL=c(4.6,2.7,2.7,3.9,3.4,3.6,3.4,3.9,3.6,3.9,2.5,4.2,2.5,2.5,3.1,2.5,2.5,2.9,3.1,3.1,2.7,2.9,2.9,2.9,3.1,2.7,3.4,8.3,2.9,2.9,3.6,3.1,4.9,8.3,5.3,3.1,2.7,2.7,2.7,2.7,3.1,3.1,2.7,3.1,2.5,2.5,2.9,2.9,3.9,3.9,3.6,3.4,3.9,5.3,3.9,3.9,2.9,2.7,2.9,3.1,2.7,2.1,2.3,2.3,2.3,2.1,2.0,2.1,2.5,2.3,2.5,2.5,3.1,3.6,2.9,2.9,3.4,4.9,2.5,4.6,4.2,2.5,2.3,2.5,2.7,2.5,2.1,2.5,2.1,2.9,2.9,2.9,2.1,2.3,2.5,2.7,2.5,2.5,2.7,3.6,2.7,2.5,3.4,2.0,2.3,2.3,2.7,2.3,2.1,2.5,2.1,2.3,2.3,2.5,2.5,2.3,2.1,2.3,2.3,2.1) K=c(0.5,0.7,0.7,0.9,0.9,0.8,0.6,0.9,0.8,0.6,0.5,0.4,2.0,1.9,1.0,1.2,1.2,1.6,1.5,0.9,2.0,1.2,1.6,1.4,0.9,0.8,0.8,1.0,0.9,1.1,1.2,1.1,0.6,0.5,0.6,0.9,1.4,1.6,1.3,1.5,0.9,1.2,1.3,1.0,1.4,0.7,0.7,1.0,1.0,0.7,0.8,1.3,0.7,0.7,0.8,0.8,1.3,0.9,1.2,0.8,1.5,1.4,0.8,1.0,1.4,1.1,1.6,1.0,0.9,1.1,1.1,0.9,1.0,0.7,0.6,1.0,1.0,0.7,1.0,0.6,0.9,1.2,0.8,0.8,0.8,0.7,1.1,1.2,0.8,0.9,0.9,1.2,1.1,1.1,1.2,0.9,0.8,0.7,0.9,0.7,0.8,0.9,0.5,0.8,1.0,0.7,0.8,0.7,1.4,0.9,1.4,0.9,1.0,1.3,0.7,1.3,1.4,0.9,0.8,1.4) P=c(13.7,14.5,65.7,20.5,20.7,19.3,16.2,14.6,15.8,8.7,8.9,7.7,20.0,18.4,9.4,14.8,17.5,11.7,11.2,11.1,51.4,20.4,27.3,14.1,20.1,18.1,23.5,36.4,16.9,18.6,29.0,20.9,16.8,16.8,8.6,11.3,17.5,17.0,30.9,17.2,10.7,17.2,10.9,14.5,26.6,42.1,10.5,13.5,16.4,13.3,34.7,20.0,12.8,15.1,15.8,14.1,26.9,33.2,25.4,25.1,14.1,17.7,12.6,12.9,27.5,18.6,16.9,15.5,16.2,17.6,17.5,14.5,12.6,10.5,10.6,10.5,14.7,10.1,10.7,9.6,17.9,23.9,22.4,22.0,14.2,15.8,12.8,17.8,16.0,10.5,9.6,13.8,17.5,17.7,10.0,10.1,29.0,16.8,18.6,31.7,17.2,40.2,9.8,14.5,28.8,13.0,13.1,18.6,22.0,36.0,19.5,25.2,14.2,15.8,11.9,16.7,20.0,14.7,11.7,17.9) Ca=c(3.43,4.24,5.37,4.13,4.48,4.65,4.33,4.19,3.91,3.23,4.01,2.98,4.55,4.53,3.91,4.33,4.62,4.54,3.38,3.87,3.85,3.91,3.79,4.57,4.71,4.75,4.93,4.32,4.08,3.73,3.30,3.88,2.59,1.99,2.27,3.68,4.94,5.29,5.69,5.67,4.55,5.01,4.85,4.76,4.99,5.13,4.40,4.38,3.05,3.78,4.21,4.22,3.55,2.81,2.98,3.35,4.03,3.80,3.88,3.97,4.32,4.81,5.06,4.98,5.46,4.88,5.37,5.36,5.41,5.05,5.22,4.95,6.06,3.51,3.72,3.25,2.74,1.78,2.86,2.31,3.63,4.91,4.47,4.85,4.78,6.76,4.31,4.62,4.54,3.10,2.88,3.66,5.56,5.08,4.89,4.67,5.71,5.47,4.68,4.72,4.45,4.23,3.36,4.27,4.31,3.48,3.42,4.38,5.37,7.21,5.40,5.71,4.53,4.35,3.87,3.68,4.18,4.95,4.40,4.84) Mg=c(2.24,3.22,3.20,2.46,2.51,2.65,2.84,2.80,2.56,2.56,3.45,2.43,3.17,3.25,2.89,3.30,3.34,3.28,2.91,3.00,3.29,2.83,2.89,2.86,2.82,3.15,2.49,2.65,2.95,3.20,2.88,3.10,2.28,1.92,2.05,3.18,3.19,3.13,3.35,3.44,3.27,3.18,3.35,3.24,3.29,3.37,3.21,3.19,2.50,2.01,2.61,2.74,2.42,2.05,2.29,2.36,3.33,3.30,3.03,2.90,2.99,3.34,3.33,3.35,3.30,3.10,3.47,3.30,3.30,3.23,3.25,3.23,3.49,2.40,2.70,2.83,2.78,1.98,2.89,2.30,2.35,3.20,3.45,2.74,2.97,4.56,3.28,2.80,3.03,2.79,2.68,2.95,3.43,3.38,3.30,3.13,3.25,3.06,2.99,2.49,2.84,2.81,2.22,3.48,3.08,2.80,2.62,2.79,3.30,3.39,3.23,3.14,3.31,2.94,3.03,3.17,2.98,3.38,3.13,3.21) V=c(57.27,75.06,77.30,65.31,69.75,68.82,69.49,66.52,66.47,61.75,75.94,57.72,79.32,79.29,71.24,77.71,78.33,76.18,71.19,71.14,76.94,72.96,73.78,75.10,72.70,76.02,70.72,48.85,73.04,73.25,66.68,71.78,52.34,34.52,48.24,70.98,77.75,78.59,79.11,79.57,73.40,74.76,77.59,73.97,79.17,78.45,73.85,74.40,62.52,62.12,67.51,70.86,62.69,51.35,60.67,62.34,74.62,74.63,73.41,70.85,76.35,81.43,79.59,79.78,81.17,80.69,83.74,81.62,79.09,79.87,79.09,78.23,76.80,64.16,70.53,70.54,65.82,47.34,72.73,53.10,61.80,78.52,78.78,76.85,75.73,82.58,80.00,77.24,79.24,69.95,68.90,72.68,82.19,80.29,78.75,76.06,79.42,78.49,75.87,68.39,74.74,75.88,64.04,80.92,78.00,74.94,71.55,76.95,82.11,81.94,82.16,80.58,78.89,77.11,75.13,77.63,79.68,79.73,77.91,81.24) dados=data.frame(ph,HAL,K,P,Ca,Mg,V) 11.1.6 Usando o GGally library(GGally) ggpairs(dados) 11.1.7 Usando a package psych library(psych) pairs.panels(dados) 11.2 Rede de correlação 11.2.1 Conjunto de dados DPF=c(46.00,46.00,46.00,46.00,46.00,46.00,43.00,43.00,43.00,46.00,43.00,43.00,46.00,46.00,46.00,49.00,50.00,46.00,43.00,43.00,46.00,43.00,46.00,43.00,39.00,39.00,43.00,43.00,42.00,45.00,43.00,46.00,46.00,43.00,43.00,43.00,43.00,46.00,43.00,49.00,50.00,43.00,39.00,39.00,39.00) APF=c(58.33,55.00,50.00,41.00,35.67,43.33,35.67,36.00,35.33,46.67,36.67,49.00,38.33,43.67,44.33,41.00,48.00,43.67,32.67,28.67,36.67,38.33,46.33,53.33,38.00,33.00,32.67,45.67,48.33,46.67,33.67,36.67,42.67,37.00,43.67,35.33,42.33,47.00,47.00,59.67,59.00,48.33,32.33,36.33,33.33) DPM=c(105.00,105.00,102.00,110.00,110.00,112.00,110.00,110.00,105.00,112.00,112.00,110.00,110.00,112.00,112.00,112.00,112.00,112.00,110.00,105.00,105.00,110.00,102.00,102.00,110.00,105.00,110.00,110.00,110.00,104.00,105.00,105.00,104.00,104.00,104.00,102.00,104.00,105.00,102.00,110.00,112.00,112.00,102.00,102.00,102.00) APM=c(100.00,90.33,97.00,91.33,97.67,77.33,90.00,93.00,91.33,98.00,84.67,91.33,92.33,101.67,102.33,102.33,98.33,93.00,78.67,72.33,72.33,97.67,104.33,96.00,99.00,97.00,94.33,104.67,115.00,117.67,81.33,82.33,83.00,104.33,107.33,103.00,89.33,90.33,82.33,123.33,115.00,133.33,60.00,59.00,65.67) IPV=c(15.00,20.00,17.00,10.00,22.67,14.33,23.00,19.33,15.33,14.33,15.00,22.67,14.67,15.33,17.00,13.67,16.67,19.33,11.00,8.67,11.33,13.00,14.67,13.00,13.00,12.00,17.67,14.67,10.67,25.00,18.00,14.00,18.67,15.67,11.00,18.00,16.33,24.33,17.00,13.33,11.00,22.33,10.33,5.67,14.00) ACA=c(2.00,1.90,2.20,1.50,1.20,1.00,2.00,1.50,1.20,3.00,1.40,1.60,1.80,2.50,2.50,2.00,1.70,1.80,1.50,2.00,1.50,1.80,2.00,1.80,1.30,1.20,2.00,3.00,2.00,3.00,1.50,1.80,2.20,1.80,1.80,2.00,1.80,3.50,3.50,1.50,2.50,2.00,1.20,1.00,1.20) PRO=c(2444.44,2870.37,2314.81,2629.63,2444.44,2592.59,2962.96,3037.04,3037.04,2592.59,2296.30,2444.44,2370.37,3481.48,2555.56,1981.48,2611.11,1925.93,1870.37,2518.52,2370.37,2462.96,2351.85,2000.00,2703.70,2685.19,2166.67,2129.63,2222.22,1814.81,2537.04,2351.85,2333.33,3370.37,2462.96,3129.63,2666.67,2796.30,2055.56,2333.33,2240.74,2092.59,2703.70,2129.63,2740.74) MCG=c(10.78,10.96,10.07,10.77,11.17,11.24,12.57,13.35,13.77,14.23,13.61,13.30,11.85,11.80,12.04,10.10,10.19,9.97,12.15,11.35,11.70,12.83,11.52,11.10,10.95,11.14,10.26,12.51,11.87,12.30,14.20,13.13,14.70,13.08,12.76,13.74,14.59,13.98,13.52,12.72,12.22,12.63,10.93,10.65,10.67) 11.2.2 Criando uma data.frame dados=data.frame(DPF,APF,DPM,APM,IPV,ACA,PRO,MCG) 11.2.3 Matriz de correlação (Pearson) corre=cor(dados[c(1:8),c(1:8)]) 11.2.4 Construindo o Gráfico Instalar pacote (qgraph) library(qgraph) ## Error : invalid version specification &#39;1,5&#39; qgraph(corre, shape=&quot;circle&quot;, posCol=&quot;darkgreen&quot;, negCol=&quot;darkred&quot;, layout=&quot;groups&quot;, vsize=10) 11.2.5 Matriz de correlação (Kendall) corre=cor(dados[c(1:8),c(1:8)], method = &quot;kendall&quot;) 11.2.6 Construindo o Gráfico Instalar pacote (qgraph) library(qgraph) qgraph(corre, shape=&quot;circle&quot;, posCol=&quot;darkgreen&quot;, negCol=&quot;darkred&quot;, layout=&quot;groups&quot;, vsize=10) 11.2.7 Matriz de correlação (Spearman) corre=cor(dados[c(1:8),c(1:8)], method = &quot;spearman&quot;) 11.2.8 Construindo o Gráfico Instalar pacote (qgraph) library(qgraph) qgraph(corre, shape=&quot;circle&quot;, posCol=&quot;darkgreen&quot;, negCol=&quot;darkred&quot;, layout=&quot;groups&quot;, vsize=10) "],
["radar.html", " 12 Radar", " 12 Radar Um gráfico de radar é um método gráfico de apresentar dados multivariáveis na forma de um gráfico bidimensional de três ou mais variáveis quantitativas representadas em eixos que partem do mesmo ponto. A posição relativa e o ãngulo dos eixos normalmente é pouco informativo. O gráfico de radar é também conhecido como gráfico de teia, gráfico de aranha, gráfico de estrela, polígono irregular, gráfico polar, ou diagrama Kiviat. 12.0.1 Conjunto de dados cor=c(6,6,6,7,7,7,3,4,3,3,3,3,6,6,7,6,6,7,6,7,5,6,5,3,3,5,5,5,3,3) aroma=c(6,7,5,6,6,7,3,3,3,3,5,3,4,6,6,6,5,7,5,6,5,3,3,6,4,4,5,5,4,3) sabor=c(5,6,6,6,5,6,3,4,3,4,2,2,3,6,7,6,7,7,6,6,5,4,5,3,6,6,5,5,4,6) corpo=c(6,5,4,6,4,5,4,4,4,5,2,4,6,6,5,6,6,7,5,6,4,5,5,4,4,5,5,4,2,4) global=c(5,6,6,7,5,6,3,4,3,3,2,3,4,6,6,6,6,7,6,6,5,6,5,5,4,5,5,4,3,5) (Amostra=rep(c(paste(&quot;A&quot;, 1:5)), e=6)) ## [1] &quot;A 1&quot; &quot;A 1&quot; &quot;A 1&quot; &quot;A 1&quot; &quot;A 1&quot; &quot;A 1&quot; &quot;A 2&quot; &quot;A 2&quot; &quot;A 2&quot; &quot;A 2&quot; &quot;A 2&quot; &quot;A 2&quot; ## [13] &quot;A 3&quot; &quot;A 3&quot; &quot;A 3&quot; &quot;A 3&quot; &quot;A 3&quot; &quot;A 3&quot; &quot;A 4&quot; &quot;A 4&quot; &quot;A 4&quot; &quot;A 4&quot; &quot;A 4&quot; &quot;A 4&quot; ## [25] &quot;A 5&quot; &quot;A 5&quot; &quot;A 5&quot; &quot;A 5&quot; &quot;A 5&quot; &quot;A 5&quot; dados=data.frame(Amostra, cor, aroma, sabor, corpo, global) Tratamentos: B100: 100% de B (Amostra A1) N100: 100% de N (Amostra A2) B75N25: 75% de B e 25% de N (Amostra A3) B50N50: 50% de B e 50% de N (Amostra A4) B25N75: 25% de B e 75% de N (Amostra A5) 12.0.2 Média por variável mediacor=tapply(cor, Amostra, mean) mediaaroma=tapply(aroma, Amostra, mean) mediasabor=tapply(sabor, Amostra, mean) mediacorpo=tapply(corpo, Amostra, mean) mediaglobal=tapply(global, Amostra, mean) medias=c(mediacor,mediaaroma, mediasabor,mediacorpo,mediaglobal) 12.0.3 Pacote radarchart 12.0.4 Lista com as médias labs=c(&quot;Cor&quot;,&quot;Aroma&quot;,&quot;Sabor&quot;,&quot;Corpo&quot;,&quot;Global&quot;) scores=list(&quot;B100&quot;=as.numeric(medias[c(1,6,11,16,21)]), &quot;N100&quot;=as.numeric(medias[c(2,7,12,17,22)]), &quot;B75N25&quot;=as.numeric(medias[c(3,8,13,18,23)]), &quot;B50N50&quot;=as.numeric(medias[c(4,9,14,19,24)]), &quot;B25N75&quot;=as.numeric(medias[c(5,10,15,20,25)])) Instalar pacote radarchart library(radarchart) chartJSRadar(scores = scores, labs=labs, plwd=4 , plty=1, axistype=0, maxmin=F, cglcol=&quot;grey&quot;, cglty=1, axislabcol=&quot;grey&quot;, caxislabels=seq(0,20,5), cglwd=0.8, vlcex=0.8) 12.0.5 Pacote plotly 12.0.6 Médias por tratamento B100=c(as.numeric(medias[c(1,6,11,16,21)])) N100=c(as.numeric(medias[c(2,7,12,17,22)])) B75N25=c(as.numeric(medias[c(3,8,13,18,23)])) B50N50=c(as.numeric(medias[c(4,9,14,19,24)])) B25N75=c(as.numeric(medias[c(5,10,15,20,25)])) 12.0.7 Pacote plotly library(plotly) (p &lt;- plot_ly(type = &#39;scatterpolar&#39;,fill = &#39;toself&#39;) %&gt;% add_trace(r = B100,theta = c(&#39;Cor&#39;,&#39;Aroma&#39;,&#39;Sabor&#39;, &#39;Corpo&#39;, &#39;Global&#39;),name = &#39;B100&#39;) %&gt;% add_trace(r = N100,theta = c(&#39;Cor&#39;,&#39;Aroma&#39;,&#39;Sabor&#39;, &#39;Corpo&#39;, &#39;Global&#39;),name = &#39;N100&#39;) %&gt;% add_trace(r = B75N25,theta = c(&#39;Cor&#39;,&#39;Aroma&#39;,&#39;Sabor&#39;, &#39;Corpo&#39;, &#39;Global&#39;),name = &#39;B75N25&#39;) %&gt;% add_trace(r = B50N50,theta = c(&#39;Cor&#39;,&#39;Aroma&#39;,&#39;Sabor&#39;, &#39;Corpo&#39;, &#39;Global&#39;),name = &#39;B50N50&#39;) %&gt;% add_trace(r = B25N75,theta = c(&#39;Cor&#39;,&#39;Aroma&#39;,&#39;Sabor&#39;, &#39;Corpo&#39;, &#39;Global&#39;),name = &#39;B25N75&#39;) %&gt;% layout(polar = list(radialaxis = list(visible = T)))) # library(fmsb) # data=rbind(round(B100,1), # round(N100,1), # round(B75N25,1), # round(B50N50,1), # round(B25N75,1)) # rownames(data)=c(&quot;B100&quot;,&quot;N100&quot;,&quot;B75N25&quot;,&quot;B50N50&quot;,&quot;B25N75&quot;) # colnames(data)=c(&#39;Cor&#39;,&#39;Aroma&#39;,&#39;Sabor&#39;, &#39;Corpo&#39;, &#39;Global&#39;) # data=data.frame(data) # radarchart(data,axistype = 2) "],
["intervalo-de-confiança.html", " 13 Intervalo de confiança", " 13 Intervalo de confiança 13.0.1 Conjunto de dados Um experimento foi realizado com o intuito de avaliar a massa seca da raiz de soja no munícipio de Londrina-PR. O experimento foi instalado em delineamento inteiramente casualizado (DIC), 5 repetições, no esquema fatorial 4 x 2 (4 aplicações de dicloroisocianurato de sódio (DUP) e 2 inoculações de Rhizobium). msraiz=c(4.87, 4.64, 3.71, 3.04, 4.57, 4.13, 3.8, 1.17, 3.28, 1.73, 1.87, 2.85, 3.32, 2.19, 2.33, 4.09, 2.85, 1.86, 2.17, 2.12, 3.03, 3.52, 3.72, 3.09, 5.11, 3.6, 2.14, 2.25, 1.93, 3.35, 2.03, 4.72, 3.39, 3.05, 2.98, 2.53, 5.61, 3.74, 2.89, 4.8) (Inoculação=rep(c(&quot;IN&quot;,&quot;NI&quot;),e=20)) ## [1] &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; ## [16] &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; ## [31] &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; (Época=rep(c(&quot;Plantio&quot;,&quot;V1+15&quot;,&quot;V3+15&quot;,&quot;R1+15&quot;),e=5,2)) ## [1] &quot;Plantio&quot; &quot;Plantio&quot; &quot;Plantio&quot; &quot;Plantio&quot; &quot;Plantio&quot; &quot;V1+15&quot; &quot;V1+15&quot; ## [8] &quot;V1+15&quot; &quot;V1+15&quot; &quot;V1+15&quot; &quot;V3+15&quot; &quot;V3+15&quot; &quot;V3+15&quot; &quot;V3+15&quot; ## [15] &quot;V3+15&quot; &quot;R1+15&quot; &quot;R1+15&quot; &quot;R1+15&quot; &quot;R1+15&quot; &quot;R1+15&quot; &quot;Plantio&quot; ## [22] &quot;Plantio&quot; &quot;Plantio&quot; &quot;Plantio&quot; &quot;Plantio&quot; &quot;V1+15&quot; &quot;V1+15&quot; &quot;V1+15&quot; ## [29] &quot;V1+15&quot; &quot;V1+15&quot; &quot;V3+15&quot; &quot;V3+15&quot; &quot;V3+15&quot; &quot;V3+15&quot; &quot;V3+15&quot; ## [36] &quot;R1+15&quot; &quot;R1+15&quot; &quot;R1+15&quot; &quot;R1+15&quot; &quot;R1+15&quot; F1=as.factor(Inoculação) F2=as.factor(Época) Trat=paste(F1,F2) dados=data.frame(Trat,resp=msraiz) 13.0.2 Gráfico de linhas sciplot::lineplot.CI(Trat,msraiz,type=&quot;l&quot;,las=2,xlab=&quot;&quot;,ylim=c(0,5), ylab=&quot;Massa seca da raiz (g)&quot;, cex.lab=1.25,cex.names=1) 13.0.3 Gráfico de pontos sciplot::lineplot.CI(Trat,msraiz,type=&quot;p&quot;,las=2,xlab=&quot;&quot;,ylim=c(0,5), ylab=&quot;Massa seca da raiz (g)&quot;, cex.lab=1.25,cex.names=1) 13.0.4 Gráfico de linhas e pontos sciplot::lineplot.CI(Trat,msraiz,type=&quot;b&quot;,las=2,xlab=&quot;&quot;,ylim=c(0,5), ylab=&quot;Massa seca da raiz (g)&quot;, cex.lab=1.25,cex.names=1) 13.0.5 Gráfico de barras e linhas sciplot::bargraph.CI(Trat,msraiz,las=2,xlab=&quot;&quot;, ylab=&quot;Massa seca da raiz (g)&quot;,ylim=c(0,5), cex.lab = 1.25,col = &quot;black&quot;, angle = 45, cex.names = 1,density = c(0,20)) abline(h=0) "],
["quantis-teóricos.html", " 14 Quantis Teóricos", " 14 Quantis Teóricos 14.0.1 Conjunto de dados Um experimento foi realizado com o intuito de avaliar a massa seca da raiz de soja no munícipio de Londrina-PR. O experimento foi instalado em delineamento inteiramente casualizado (DIC), 5 repetições, no esquema fatorial 4 x 2 (4 aplicações de dicloroisocianurato de sódio (DUP) e 2 inoculações de Rhizobium). msraiz=c(4.87, 4.64, 3.71, 3.04, 4.57, 4.13, 3.8, 1.17, 3.28, 1.73, 1.87, 2.85, 3.32, 2.19, 2.33, 4.09, 2.85, 1.86, 2.17, 2.12, 3.03, 3.52, 3.72, 3.09, 5.11, 3.6, 2.14, 2.25, 1.93, 3.35, 2.03, 4.72, 3.39, 3.05, 2.98, 2.53, 5.61, 3.74, 2.89, 4.8) (Inoculação=rep(c(&quot;IN&quot;,&quot;NI&quot;),e=20)) ## [1] &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; ## [16] &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;IN&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; ## [31] &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; &quot;NI&quot; (Época=rep(c(&quot;Plantio&quot;,&quot;V1+15&quot;,&quot;V3+15&quot;,&quot;R1+15&quot;),e=5,2)) ## [1] &quot;Plantio&quot; &quot;Plantio&quot; &quot;Plantio&quot; &quot;Plantio&quot; &quot;Plantio&quot; &quot;V1+15&quot; &quot;V1+15&quot; ## [8] &quot;V1+15&quot; &quot;V1+15&quot; &quot;V1+15&quot; &quot;V3+15&quot; &quot;V3+15&quot; &quot;V3+15&quot; &quot;V3+15&quot; ## [15] &quot;V3+15&quot; &quot;R1+15&quot; &quot;R1+15&quot; &quot;R1+15&quot; &quot;R1+15&quot; &quot;R1+15&quot; &quot;Plantio&quot; ## [22] &quot;Plantio&quot; &quot;Plantio&quot; &quot;Plantio&quot; &quot;Plantio&quot; &quot;V1+15&quot; &quot;V1+15&quot; &quot;V1+15&quot; ## [29] &quot;V1+15&quot; &quot;V1+15&quot; &quot;V3+15&quot; &quot;V3+15&quot; &quot;V3+15&quot; &quot;V3+15&quot; &quot;V3+15&quot; ## [36] &quot;R1+15&quot; &quot;R1+15&quot; &quot;R1+15&quot; &quot;R1+15&quot; &quot;R1+15&quot; F1=as.factor(Inoculação) F2=as.factor(Época) Trat=paste(F1,F2) dados=data.frame(Trat,resp=msraiz) 14.0.2 Análise de variância mod = with(dados, aov(msraiz~F1*F2)) anova(mod) ## Analysis of Variance Table ## ## Response: msraiz ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## F1 1 1,1868 1,18680 1,2950 0,26358 ## F2 3 8,5762 2,85872 3,1193 0,03961 * ## F1:F2 3 4,9430 1,64766 1,7978 0,16744 ## Residuals 32 29,3268 0,91646 ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 14.0.3 Envelope simulado hnp::hnp(mod, las=1, seed=1, pch=16) 14.0.4 Porcentagem de pontos fora hnp::hnp(mod, seed=1, las=1, pch=16, print.on=T) 14.0.5 Colorir pontos fora hnp::hnp(mod, seed=1, las=1, pch=16, print.on=T, paint.out=T, col.paint.out=&quot;red&quot;) "],
["componentes-principais.html", " 15 Componentes principais 15.1 Pacote ggforfity 15.2 factoextra e factomineR (Biplot) 15.3 factoextra (Gráficos separados) 15.4 Gráfico de CP (Manualmente) 15.5 Screeplot 15.6 Manualmente pelo stats 15.7 Correlação com variável latente 15.8 Pacote psych 15.9 Extraindo cluster de forma automática", " 15 Componentes principais A análise de Componentes Principais é um método utilizado para reduzir a dimensão do problema em componentes não correlacionadas que são combinações lineares das variáveis originais. O número dessas componentes é menor ou igual a quantidade de variáveis originais. Esse método é útil quando o número de variáveis em estudo é muito grande. 15.1 Pacote ggforfity 15.1.1 Conjunto de dados dados &lt;- iris[c(1, 2, 3, 4)] 15.1.2 Calculando a PCA (pca=prcomp(dados,scale. = T)) ## Standard deviations (1, .., p=4): ## [1] 1,7083611 0,9560494 0,3830886 0,1439265 ## ## Rotation (n x k) = (4 x 4): ## PC1 PC2 PC3 PC4 ## Sepal.Length 0,5210659 -0,37741762 0,7195664 0,2612863 ## Sepal.Width -0,2693474 -0,92329566 -0,2443818 -0,1235096 ## Petal.Length 0,5804131 -0,02449161 -0,1421264 -0,8014492 ## Petal.Width 0,5648565 -0,06694199 -0,6342727 0,5235971 15.1.3 Dispersão com os autovalores library(ggfortify) autoplot(pca,data=iris) 15.1.4 Agrupando por espécies Obs. a coluna de “Species” está na dataset iris library(ggfortify) autoplot(pca,data=iris,colour=&quot;Species&quot;) 15.1.5 Vetor das respostas library(ggfortify) autoplot(pca, data=iris, colour=&quot;Species&quot;, loadings=T) 15.1.6 Nome dos vetores library(ggfortify) autoplot(pca, data=iris, colour=&quot;Species&quot;, loadings=T, loadings.label=T) 15.1.7 Polígono de agrupamento library(ggfortify) autoplot(pca, data=iris, colour=&quot;Species&quot;, loadings=T, loadings.label=T, frame=T) 15.1.8 Modificando para elipse library(ggfortify) autoplot(pca, data=iris, colour=&quot;Species&quot;, loadings=T, loadings.label=T, frame=T, frame.type=&quot;norm&quot;) 15.1.9 Cor do vetor e do nome library(ggfortify) autoplot(pca, data=iris, colour=&quot;Species&quot;, loadings=T, loadings.label=T, frame=T, frame.type=&quot;norm&quot;, loadings.colour=&quot;black&quot;, loadings.label.colour=&quot;black&quot;) 15.1.10 fonte; linha de grade e cor de fundo library(ggfortify) autoplot(pca, data=iris, colour=&quot;Species&quot;, loadings=T, loadings.label=T, frame=T, frame.type=&quot;norm&quot;, loadings.colour=&quot;black&quot;, loadings.label.colour=&quot;black&quot;, loadings.label.family=&quot;serif&quot;)+theme_bw()+ theme(text = element_text(family=&quot;serif&quot;)) 15.1.11 Linha em Y=0 e X=0 library(ggfortify) autoplot(pca, data=iris, colour=&quot;Species&quot;, loadings=T, loadings.label=T, frame=T, frame.type=&quot;norm&quot;, loadings.colour=&quot;black&quot;, loadings.label.colour=&quot;black&quot;, loadings.label.family=&quot;serif&quot;)+theme_bw()+ theme(text = element_text(family=&quot;serif&quot;))+ geom_vline(,xintercept = 0,linetype=2)+ geom_hline(,yintercept = 0,linetype=2) 15.2 factoextra e factomineR (Biplot) rm(list=ls()) DPF=c(46.00,46.00,46.00,46.00,46.00,46.00,43.00,43.00,43.00,46.00,43.00,43.00,46.00,46.00,46.00,49.00,50.00,46.00,43.00,43.00,46.00,43.00,46.00,43.00,39.00,39.00,43.00,43.00,42.00,45.00,43.00,46.00,46.00,43.00,43.00,43.00,43.00,46.00,43.00,49.00,50.00,43.00,39.00,39.00,39.00) APF=c(58.33,55.00,50.00,41.00,35.67,43.33,35.67,36.00,35.33,46.67,36.67,49.00,38.33,43.67,44.33,41.00,48.00,43.67,32.67,28.67,36.67,38.33,46.33,53.33,38.00,33.00,32.67,45.67,48.33,46.67,33.67,36.67,42.67,37.00,43.67,35.33,42.33,47.00,47.00,59.67,59.00,48.33,32.33,36.33,33.33) DPM=c(105.00,105.00,102.00,110.00,110.00,112.00,110.00,110.00,105.00,112.00,112.00,110.00,110.00,112.00,112.00,112.00,112.00,112.00,110.00,105.00,105.00,110.00,102.00,102.00,110.00,105.00,110.00,110.00,110.00,104.00,105.00,105.00,104.00,104.00,104.00,102.00,104.00,105.00,102.00,110.00,112.00,112.00,102.00,102.00,102.00) APM=c(100.00,90.33,97.00,91.33,97.67,77.33,90.00,93.00,91.33,98.00,84.67,91.33,92.33,101.67,102.33,102.33,98.33,93.00,78.67,72.33,72.33,97.67,104.33,96.00,99.00,97.00,94.33,104.67,115.00,117.67,81.33,82.33,83.00,104.33,107.33,103.00,89.33,90.33,82.33,123.33,115.00,133.33,60.00,59.00,65.67) IPV=c(15.00,20.00,17.00,10.00,22.67,14.33,23.00,19.33,15.33,14.33,15.00,22.67,14.67,15.33,17.00,13.67,16.67,19.33,11.00,8.67,11.33,13.00,14.67,13.00,13.00,12.00,17.67,14.67,10.67,25.00,18.00,14.00,18.67,15.67,11.00,18.00,16.33,24.33,17.00,13.33,11.00,22.33,10.33,5.67,14.00) ACA=c(2.00,1.90,2.20,1.50,1.20,1.00,2.00,1.50,1.20,3.00,1.40,1.60,1.80,2.50,2.50,2.00,1.70,1.80,1.50,2.00,1.50,1.80,2.00,1.80,1.30,1.20,2.00,3.00,2.00,3.00,1.50,1.80,2.20,1.80,1.80,2.00,1.80,3.50,3.50,1.50,2.50,2.00,1.20,1.00,1.20) PRO=c(2444.44,2870.37,2314.81,2629.63,2444.44,2592.59,2962.96,3037.04,3037.04,2592.59,2296.30,2444.44,2370.37,3481.48,2555.56,1981.48,2611.11,1925.93,1870.37,2518.52,2370.37,2462.96,2351.85,2000.00,2703.70,2685.19,2166.67,2129.63,2222.22,1814.81,2537.04,2351.85,2333.33,3370.37,2462.96,3129.63,2666.67,2796.30,2055.56,2333.33,2240.74,2092.59,2703.70,2129.63,2740.74) MCG=c(10.78,10.96,10.07,10.77,11.17,11.24,12.57,13.35,13.77,14.23,13.61,13.30,11.85,11.80,12.04,10.10,10.19,9.97,12.15,11.35,11.70,12.83,11.52,11.10,10.95,11.14,10.26,12.51,11.87,12.30,14.20,13.13,14.70,13.08,12.76,13.74,14.59,13.98,13.52,12.72,12.22,12.63,10.93,10.65,10.67) Tratamento=rep(c(paste(&quot;T&quot;,1:5)),9) dados=data.frame(Tratamento,DPF,APF,DPM,APM,IPV,ACA,PRO,MCG) 15.2.1 Valores dos CP require(FactoMineR) pca=PCA(dados[c(2,3,4,5,6,7,9)],scale.unit=T,graph=F) round(pca$eig,3) ## eigenvalue percentage of variance cumulative percentage of variance ## comp 1 2,648 37,821 37,821 ## comp 2 1,411 20,152 57,974 ## comp 3 0,939 13,418 71,392 ## comp 4 0,650 9,282 80,673 ## comp 5 0,608 8,692 89,365 ## comp 6 0,479 6,842 96,207 ## comp 7 0,266 3,793 100,000 15.2.2 Gráfico básico require(factoextra) fviz_pca_biplot(pca,geom = c(&quot;point&quot;)) 15.2.3 Elipse geral require(factoextra) fviz_pca_biplot(pca,geom = c(&quot;point&quot;), addEllipses = T) 15.2.4 Elipse por Tratamentos require(factoextra) fviz_pca_biplot(pca,geom = c(&quot;point&quot;), addEllipses = T, fill.ind = dados$Tratamento) 15.2.5 Removendo título require(factoextra) fviz_pca_biplot(pca,geom = c(&quot;point&quot;), addEllipses = T, fill.ind = dados$Tratamento, title = &quot;&quot;) 15.2.6 Sobreposição de legendas require(factoextra) fviz_pca_biplot(pca,geom = c(&quot;point&quot;), addEllipses = T, ## adicionar elipse fill.ind = dados$Tratamento, title = &quot;&quot;, repel=T) 15.2.7 Tamanho do ponto, letra e a cor require(factoextra) fviz_pca_biplot(pca,geom = c(&quot;point&quot;), addEllipses = T, fill.ind = dados$Tratamento, title = &quot;&quot;, repel=T, pointshape=21,pointsize=2,textsize=0.5, col.var=&quot;black&quot;) 15.2.8 Título das ellipses require(factoextra) fviz_pca_biplot(pca,geom = c(&quot;point&quot;), addEllipses = T, fill.ind = dados$Tratamento, title = &quot;&quot;, repel=T, pointshape=21,pointsize=2,textsize=0.5, col.var=&quot;black&quot;,fill= &quot;Cultivares&quot;) 15.2.9 Título do 1 e 2 CP require(factoextra) fviz_pca_biplot(pca,geom = c(&quot;point&quot;), addEllipses = T, fill.ind = dados$Tratamento, title = &quot;&quot;, repel=T, pointshape=21,pointsize=2,textsize=0.5, col.var=&quot;black&quot;,fill= &quot;Cultivares&quot;)+ylab(&quot;CP2(20,2%)&quot;)+xlab(&quot;CP1(37,8%)&quot;) 15.3 factoextra (Gráficos separados) 15.3.1 Conjunto de dados ph=c(5.4,6.7,6.8,5.9,6.3,6.2,6.3,6,6.1,5.8,6.7,5.7,6.8,6.9,6.5,6.9,6.8,6.7,6.5,6.5,6.7,6.7,6.5,6.7,6.6,6.8,6.4,4.6,6.5,6.6,6.3,6.2,5.5,4.5,5.2,6.5,6.3,6.6,6.4,6.6,6.6,6.5,6.5,6.4,6.5,6.8,6.7,6.6,5.9,6.1,6.3,6.3,6.2,5.3,5.8,6.1,6.7,6.7,6.6,6.6,6.6,6.8,6.8,6.7,6.9,7,7.1,7.1,6.7,6.7,6.6,6.6,6.3,5.8,6.2,6.3,6,5,6.3,5.3,5.4,6.4,6.7,6.5,6.5,6.4,6.7,6.5,6.8,6.2,6.1,6.2,6.8,6.7,6.6,6.4,6.7,6.6,6.4,5.9,6.5,6.6,5.9,6.8,6.8,6.7,6.5,6.7,6.9,6.5,6.8,6.7,6.8,6.6,6.7,6.7,6.9,6.9,6.7,6.8) HAL=c(4.6,2.7,2.7,3.9,3.4,3.6,3.4,3.9,3.6,3.9,2.5,4.2,2.5,2.5,3.1,2.5,2.5,2.9,3.1,3.1,2.7,2.9,2.9,2.9,3.1,2.7,3.4,8.3,2.9,2.9,3.6,3.1,4.9,8.3,5.3,3.1,2.7,2.7,2.7,2.7,3.1,3.1,2.7,3.1,2.5,2.5,2.9,2.9,3.9,3.9,3.6,3.4,3.9,5.3,3.9,3.9,2.9,2.7,2.9,3.1,2.7,2.1,2.3,2.3,2.3,2.1,2.0,2.1,2.5,2.3,2.5,2.5,3.1,3.6,2.9,2.9,3.4,4.9,2.5,4.6,4.2,2.5,2.3,2.5,2.7,2.5,2.1,2.5,2.1,2.9,2.9,2.9,2.1,2.3,2.5,2.7,2.5,2.5,2.7,3.6,2.7,2.5,3.4,2.0,2.3,2.3,2.7,2.3,2.1,2.5,2.1,2.3,2.3,2.5,2.5,2.3,2.1,2.3,2.3,2.1) K=c(0.5,0.7,0.7,0.9,0.9,0.8,0.6,0.9,0.8,0.6,0.5,0.4,2.0,1.9,1.0,1.2,1.2,1.6,1.5,0.9,2.0,1.2,1.6,1.4,0.9,0.8,0.8,1.0,0.9,1.1,1.2,1.1,0.6,0.5,0.6,0.9,1.4,1.6,1.3,1.5,0.9,1.2,1.3,1.0,1.4,0.7,0.7,1.0,1.0,0.7,0.8,1.3,0.7,0.7,0.8,0.8,1.3,0.9,1.2,0.8,1.5,1.4,0.8,1.0,1.4,1.1,1.6,1.0,0.9,1.1,1.1,0.9,1.0,0.7,0.6,1.0,1.0,0.7,1.0,0.6,0.9,1.2,0.8,0.8,0.8,0.7,1.1,1.2,0.8,0.9,0.9,1.2,1.1,1.1,1.2,0.9,0.8,0.7,0.9,0.7,0.8,0.9,0.5,0.8,1.0,0.7,0.8,0.7,1.4,0.9,1.4,0.9,1.0,1.3,0.7,1.3,1.4,0.9,0.8,1.4) P=c(13.7,14.5,65.7,20.5,20.7,19.3,16.2,14.6,15.8,8.7,8.9,7.7,20.0,18.4,9.4,14.8,17.5,11.7,11.2,11.1,51.4,20.4,27.3,14.1,20.1,18.1,23.5,36.4,16.9,18.6,29.0,20.9,16.8,16.8,8.6,11.3,17.5,17.0,30.9,17.2,10.7,17.2,10.9,14.5,26.6,42.1,10.5,13.5,16.4,13.3,34.7,20.0,12.8,15.1,15.8,14.1,26.9,33.2,25.4,25.1,14.1,17.7,12.6,12.9,27.5,18.6,16.9,15.5,16.2,17.6,17.5,14.5,12.6,10.5,10.6,10.5,14.7,10.1,10.7,9.6,17.9,23.9,22.4,22.0,14.2,15.8,12.8,17.8,16.0,10.5,9.6,13.8,17.5,17.7,10.0,10.1,29.0,16.8,18.6,31.7,17.2,40.2,9.8,14.5,28.8,13.0,13.1,18.6,22.0,36.0,19.5,25.2,14.2,15.8,11.9,16.7,20.0,14.7,11.7,17.9) Ca=c(3.43,4.24,5.37,4.13,4.48,4.65,4.33,4.19,3.91,3.23,4.01,2.98,4.55,4.53,3.91,4.33,4.62,4.54,3.38,3.87,3.85,3.91,3.79,4.57,4.71,4.75,4.93,4.32,4.08,3.73,3.30,3.88,2.59,1.99,2.27,3.68,4.94,5.29,5.69,5.67,4.55,5.01,4.85,4.76,4.99,5.13,4.40,4.38,3.05,3.78,4.21,4.22,3.55,2.81,2.98,3.35,4.03,3.80,3.88,3.97,4.32,4.81,5.06,4.98,5.46,4.88,5.37,5.36,5.41,5.05,5.22,4.95,6.06,3.51,3.72,3.25,2.74,1.78,2.86,2.31,3.63,4.91,4.47,4.85,4.78,6.76,4.31,4.62,4.54,3.10,2.88,3.66,5.56,5.08,4.89,4.67,5.71,5.47,4.68,4.72,4.45,4.23,3.36,4.27,4.31,3.48,3.42,4.38,5.37,7.21,5.40,5.71,4.53,4.35,3.87,3.68,4.18,4.95,4.40,4.84) Mg=c(2.24,3.22,3.20,2.46,2.51,2.65,2.84,2.80,2.56,2.56,3.45,2.43,3.17,3.25,2.89,3.30,3.34,3.28,2.91,3.00,3.29,2.83,2.89,2.86,2.82,3.15,2.49,2.65,2.95,3.20,2.88,3.10,2.28,1.92,2.05,3.18,3.19,3.13,3.35,3.44,3.27,3.18,3.35,3.24,3.29,3.37,3.21,3.19,2.50,2.01,2.61,2.74,2.42,2.05,2.29,2.36,3.33,3.30,3.03,2.90,2.99,3.34,3.33,3.35,3.30,3.10,3.47,3.30,3.30,3.23,3.25,3.23,3.49,2.40,2.70,2.83,2.78,1.98,2.89,2.30,2.35,3.20,3.45,2.74,2.97,4.56,3.28,2.80,3.03,2.79,2.68,2.95,3.43,3.38,3.30,3.13,3.25,3.06,2.99,2.49,2.84,2.81, 2.22,3.48,3.08,2.80,2.62,2.79,3.30,3.39,3.23,3.14,3.31,2.94,3.03,3.17,2.98,3.38,3.13,3.21) V=c(57.27,75.06,77.30,65.31,69.75,68.82,69.49,66.52,66.47,61.75,75.94,57.72,79.32,79.29,71.24,77.71,78.33,76.18,71.19,71.14,76.94,72.96,73.78,75.10,72.70,76.02,70.72,48.85,73.04,73.25,66.68,71.78,52.34,34.52,48.24,70.98,77.75,78.59,79.11,79.57,73.40,74.76,77.59,73.97,79.17,78.45,73.85,74.40,62.52,62.12,67.51,70.86,62.69,51.35,60.67,62.34,74.62,74.63,73.41,70.85,76.35,81.43,79.59,79.78,81.17,80.69,83.74,81.62,79.09,79.87,79.09,78.23,76.80,64.16,70.53,70.54,65.82,47.34,72.73,53.10,61.80,78.52,78.78,76.85,75.73,82.58,80.00,77.24,79.24,69.95,68.90,72.68,82.19,80.29,78.75,76.06,79.42,78.49,75.87,68.39,74.74,75.88,64.04,80.92,78.00,74.94,71.55,76.95,82.11,81.94,82.16,80.58,78.89,77.11,75.13,77.63,79.68,79.73,77.91,81.24) Trat=rep(c(paste(&quot;T&quot;,1:10)), e=12) dados=data.frame(Trat,ph,HAL,K,P,Ca,Mg,V) 15.3.2 Calculando as médias mph=tapply(ph, Trat, mean) mHAL=tapply(HAL, Trat, mean) mK=tapply(K, Trat, mean) mP=tapply(P, Trat, mean) mCa=tapply(Ca, Trat, mean) mMg=tapply(Mg, Trat, mean) mV=tapply(V, Trat, mean) dadosm=data.frame(mph,mHAL,mK,mP,mCa,mMg,mV) 15.3.3 Dendograma (Definir Clusters) dend=as.dendrogram(hclust(dist(dadosm), method=&#39;average&#39;), hang = -1) plot(dend) abline(h=8, lty=2, col=&quot;red&quot;) ## Cluster 1: T8, T10, T6,T9,T2,T4 ## Cluster 2: T7, T3, T1, T5 15.3.4 Valores dos CP require(FactoMineR) pca=PCA(dadosm,scale.unit=T,graph=F) round(pca$eig,3) ## eigenvalue percentage of variance cumulative percentage of variance ## comp 1 5,057 72,243 72,243 ## comp 2 1,037 14,812 87,055 ## comp 3 0,639 9,128 96,183 ## comp 4 0,237 3,387 99,571 ## comp 5 0,022 0,312 99,883 ## comp 6 0,008 0,109 99,992 ## comp 7 0,001 0,008 100,000 15.3.5 Gráfico com os vetores library(factoextra) fviz_pca_var(pca) 15.3.6 Renomeando eixos fviz_pca_var(pca)+ylab(&quot;CP2 (14,9)&quot;)+xlab(&quot;CP1 (72,3%)&quot;) 15.3.7 Removendo título fviz_pca_var(pca, title=&quot;&quot;)+ylab(&quot;CP2 (14,9)&quot;)+xlab(&quot;CP1 (72,3%)&quot;) 15.3.8 Renomeando os vetores rownames(pca$var$coord)=c(&quot;pH&quot;,&quot;H+AL&quot;,&quot;K&quot;,&quot;P&quot;,&quot;Ca&quot;,&quot;Mg&quot;,&quot;V&quot;) fviz_pca_var(pca, title=&quot;&quot;)+ylab(&quot;CP2 (14,9)&quot;)+xlab(&quot;CP1 (72,3%)&quot;) 15.3.9 Sobreposição dos nomes rownames(pca$var$coord)=c(&quot;pH&quot;,&quot;H+AL&quot;,&quot;K&quot;,&quot;P&quot;,&quot;Ca&quot;,&quot;Mg&quot;,&quot;V&quot;) fviz_pca_var(pca, title=&quot;&quot;, repel=T)+ylab(&quot;CP2 (14,9)&quot;)+xlab(&quot;CP1 (72,3%)&quot;) 15.3.10 Removendo linhas de grade rownames(pca$var$coord)=c(&quot;pH&quot;,&quot;H+AL&quot;,&quot;K&quot;,&quot;P&quot;,&quot;Ca&quot;,&quot;Mg&quot;,&quot;V&quot;) fviz_pca_var(pca, title=&quot;&quot;, repel=T)+ ylab(&quot;CP2 (14,9)&quot;)+ xlab(&quot;CP1 (72,3%)&quot;)+ theme_classic() 15.3.11 Pontos dos scores fviz_pca_ind(pca) 15.3.12 Renomeando eixos e título fviz_pca_ind(pca, title=&quot;&quot;)+ylab(&quot;CP2 (14,9)&quot;)+xlab(&quot;CP1 (72,3%)&quot;) 15.3.13 Marcando os clusters (Por coloração) ## Cluster 1: T8, T10, T6,T9,T2,T4 ## Cluster 2: T7, T3, T1, T5 ## Construir vetor com o cluster (Nesse caso vamos chamar de A e B) cluster=c(&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;) fviz_pca_ind(pca, title=&quot;&quot;, col.ind = as.factor(cluster))+ ylab(&quot;CP2 (14,9)&quot;)+ xlab(&quot;CP1 (72,3%)&quot;) 15.3.14 Marcando os clusters (Por formato de ponto) ## Cluster 1: T8, T10, T6,T9,T2,T4 ## Cluster 2: T7, T3, T1, T5 ## Construir vetor com o cluster (Nesse caso vamos chamar de A e B) cluster=c(&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;) fviz_pca_ind(pca, title=&quot;&quot;, pointshape = as.factor(cluster), pointsize=2)+ ylab(&quot;CP2 (14,9)&quot;)+ xlab(&quot;CP1 (72,3%)&quot;) 15.3.15 Marcando os clusters (Por coloração e formato de ponto) ## Cluster 1: T8, T10, T6,T9,T2,T4 ## Cluster 2: T7, T3, T1, T5 ## Construir vetor com o cluster (Nesse caso vamos chamar de A e B) cluster=c(&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;) fviz_pca_ind(pca, title=&quot;&quot;, legend.title=&quot;Cluster&quot;, habillage = as.factor(cluster))+ ylab(&quot;CP2 (14,9)&quot;)+ xlab(&quot;CP1 (72,3%)&quot;) 15.3.16 Removendo linhas de grade ## Cluster 1: T8, T10, T6,T9,T2,T4 ## Cluster 2: T7, T3, T1, T5 ## Construir vetor com o cluster (Nesse caso vamos chamar de A e B) cluster=c(&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;) fviz_pca_ind(pca, title=&quot;&quot;, legend.title=&quot;Cluster&quot;, habillage = as.factor(cluster))+ ylab(&quot;CP2 (14,9)&quot;)+ xlab(&quot;CP1 (72,3%)&quot;)+theme_classic() a=fviz_pca_ind(pca, title=&quot;&quot;)+theme_classic() b=fviz_pca_var(pca, title=&quot;&quot;)+theme_classic() library(gridExtra) grid.arrange(a,b, ncol=2) 15.4 Gráfico de CP (Manualmente) 15.4.1 Calculando as médias mph=tapply(ph, Trat, mean) mHAL=tapply(HAL, Trat, mean) mK=tapply(K, Trat, mean) mP=tapply(P, Trat, mean) mCa=tapply(Ca, Trat, mean) mMg=tapply(Mg, Trat, mean) mV=tapply(V, Trat, mean) dadosm=data.frame(mph,mHAL,mK,mP,mCa,mMg,mV) 15.4.2 Dendograma (Definir Clusters) Obs. Fica a critério do pesquisador o valor do corte (Neste caso optei pelo corte em 8, formando assim dois clusters) Podemos fazer como neste exemplo abaixo: dend=as.dendrogram(hclust(dist(dadosm), method=&#39;average&#39;), hang = -1) plot(dend) abline(h=8, lty=2, col=&quot;red&quot;) ## Cluster 1: T8, T10, T6,T9,T2,T4 ## Cluster 2: T7, T3, T1, T5 ou, library(dendextend) dend=as.dendrogram(hclust(dist(dadosm), method=&#39;average&#39;)) dend=set(dend,&quot;branches_k_color&quot;, value = c(&quot;red&quot;, &quot;blue&quot;), k = 2) par(cex=0.7, mai=c(1.2,0.8,0.5,0.5)) plot(dend,las=1,ylab=&quot;Distância&quot;) par(cex=0.8) rect.dendrogram(dend, k=2,border = 8, lty = 5, lwd = 2) 15.4.3 Valores dos CP require(FactoMineR) pca=PCA(dadosm,scale.unit=T,graph=F) round(pca$eig,3) ## eigenvalue percentage of variance cumulative percentage of variance ## comp 1 5,057 72,243 72,243 ## comp 2 1,037 14,812 87,055 ## comp 3 0,639 9,128 96,183 ## comp 4 0,237 3,387 99,571 ## comp 5 0,022 0,312 99,883 ## comp 6 0,008 0,109 99,992 ## comp 7 0,001 0,008 100,000 15.4.4 Gráfico com os componentes plot(pca$eig[,2], type=&quot;b&quot;,ylab=&quot;Porcentagem de variância&quot;,xlab=&quot;CP&quot;) 15.4.5 Ponto dos scores plot(pca$ind$coord, # Extraindo da pca os valores das coordenadas em x e CP1 e y e CP2 xlab=&quot;CP1 (72.2 %)&quot;, # renomeando eixo x ylab=&quot;CP2 (14.8 %)&quot;, # renomeando eixo y pch=16) # alterando formato de ponto (&quot;Bolinha preenchida&quot;) abline(h=0,v=0, lty=2) # traçando linha em x e y = 0; lty=2 é linha tracejada 15.4.6 Identificando pontos plot(pca$ind$coord, # Extraindo da pca os valores das coordenadas em x e CP1 e y e CP2 xlab=&quot;CP1 (72.2 %)&quot;, # renomeando eixo x ylab=&quot;CP2 (14.8 %)&quot;, # renomeando eixo y pch=16) # alterando formato de ponto (&quot;Bolinha preenchida&quot;) abline(h=0,v=0, lty=2) # traçando linha em x e y = 0; lty=2 é linha tracejada text(pca$ind$coord[,1], pca$ind$coord[,2]-0.1, rownames(pca$ind$coord)) 15.4.7 Modificando nome dos pontos rownames(pca$ind$coord)=c(&quot;A&quot;,&quot;J&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;,&quot;I&quot;) plot(pca$ind$coord, # Extraindo da pca os valores das coordenadas em x e CP1 e y e CP2 xlab=&quot;CP1 (72.2 %)&quot;, # renomeando eixo x ylab=&quot;CP2 (14.8 %)&quot;, # renomeando eixo y pch=16) # alterando formato de ponto (&quot;Bolinha preenchida&quot;) abline(h=0,v=0, lty=2) # traçando linha em x e y = 0; lty=2 é linha tracejada text(pca$ind$coord[,1], pca$ind$coord[,2]-0.1, rownames(pca$ind$coord)) 15.4.8 Limite da seta dos vetores plot(pca$var$coord, # Extraindo da pca os valores da coordenadas em x e y dos vetores resposta xlab=&quot;CP1 (72.2 %)&quot;, # renomeando eixo x ylab=&quot;CP2 (14.8 %)&quot;, # renomeando eixo y pch=16, # alterando formato de ponto (&quot;Bolinha preenchida&quot;) ylim=c(-1,1), # Alterando escala de Y para -1 até 1 xlim=c(-1,1)) # Alterando escala de X para -1 até 1 abline(h=0,v=0, lty=2) # traçando linha em x e y = 0; lty=2 é linha tracejada 15.4.9 Convertendo o ponto para seta Neste caso, temos que criar setas individuais e plotar sobre o nosso gráfico. Ex. pca$var$coord[1,1]: extraindo de pca o valor da coordenada X para o vetor 1, em que de pca, localiza-se na linha 1 e coluna 1 pca$var$coord[1,2]: extraindo de pca o valor da coordenada y para o vetor 1, em que de pca, localiza-se na linha 1 e coluna 2 plot(pca$var$coord, xlab=&quot;CP1 (72.2 %)&quot;, ylab=&quot;CP2 (14.8 %)&quot;, col=&quot;white&quot;, # Estou definindo como branco para apagar os pontos ylim=c(-1.5,1.5), xlim=c(-1.5,1.5)) abline(h=0,v=0, lty=2) arrows(0,0,pca$var$coord[1,1],pca$var$coord[1,2], length = 0.1) # vetor 1 - pH arrows(0,0,pca$var$coord[2,1],pca$var$coord[2,2], length = 0.1) # vetor 2 - HAL arrows(0,0,pca$var$coord[3,1],pca$var$coord[3,2], length = 0.1) # vetor 3 - K arrows(0,0,pca$var$coord[4,1],pca$var$coord[4,2], length = 0.1) # vetor 4 - P arrows(0,0,pca$var$coord[5,1],pca$var$coord[5,2], length = 0.1) # vetor 5 - Ca arrows(0,0,pca$var$coord[6,1],pca$var$coord[6,2], length = 0.1) # vetor 6 - Mg arrows(0,0,pca$var$coord[7,1],pca$var$coord[7,2], length = 0.1) # vetor 7 - V text(pca$var$coord-0.01,rownames(pca$var$coord)) # Estou colocando os nomes dos vetores (-0.01 significa abaixo da coordenada a 0.01) 15.4.10 Alterando posição do nome do vetores Existem pesquisadores que preferem que o nome dos vetores quando x é positivo esteja a direita da extremidade da seta e quando x é negativo, o nome esteja a esquerda da seta. Neste caso, podemos utilizar a função ifelse dentro de text() plot(pca$var$coord, xlab=&quot;CP1 (72.2 %)&quot;, ylab=&quot;CP2 (14.8 %)&quot;, col=&quot;white&quot;, ylim=c(-0.5,1), xlim=c(-1.5,1.5)) abline(h=0,v=0, lty=2) arrows(0,0,pca$var$coord[1,1],pca$var$coord[1,2], length = 0.1) arrows(0,0,pca$var$coord[2,1],pca$var$coord[2,2], length = 0.1) arrows(0,0,pca$var$coord[3,1],pca$var$coord[3,2], length = 0.1) arrows(0,0,pca$var$coord[4,1],pca$var$coord[4,2], length = 0.1) arrows(0,0,pca$var$coord[5,1],pca$var$coord[5,2], length = 0.1) arrows(0,0,pca$var$coord[6,1],pca$var$coord[6,2], length = 0.1) arrows(0,0,pca$var$coord[7,1],pca$var$coord[7,2], length = 0.1) text(pca$var$coord[,1]+ ifelse(pca$var$coord[,1]&lt;0,-0.2,+0.2), pca$var$coord[,2],rownames(pca$var$coord)) ifelse(pca$var$coord[,1]&lt;0,-0.2,+0.2): estamos definindo que se pca$var$coord[,1] for menor que 0, irá adicionar -0.2, do contrário irá somar 0.2 Obs. Nessa caso estamos alterando apenas em X, este princípio também pode ser aplicado em Y. Também é possível estabelecer manualmente a localização do texto (Criar um vetor com as coordenadas) 15.4.11 Adicionando círculo com raio do maior vetor resposta library(plotrix) plot(pca$var$coord, xlab=&quot;CP1 (72.2 %)&quot;, ylab=&quot;CP2 (14.8 %)&quot;, col=&quot;white&quot;, ylim=c(-1,1), xlim=c(-1.5,1.5)) abline(h=0,v=0, lty=2) arrows(0,0,pca$var$coord[1,1],pca$var$coord[1,2], length = 0.1) arrows(0,0,pca$var$coord[2,1],pca$var$coord[2,2], length = 0.1) arrows(0,0,pca$var$coord[3,1],pca$var$coord[3,2], length = 0.1) arrows(0,0,pca$var$coord[4,1],pca$var$coord[4,2], length = 0.1) arrows(0,0,pca$var$coord[5,1],pca$var$coord[5,2], length = 0.1) arrows(0,0,pca$var$coord[6,1],pca$var$coord[6,2], length = 0.1) arrows(0,0,pca$var$coord[7,1],pca$var$coord[7,2], length = 0.1) text(pca$var$coord[,1]+ifelse(pca$var$coord[,1]&lt;0,-0.2,+0.2), pca$var$coord[,2],rownames(pca$var$coord)) draw.circle(0,0,max(ifelse(c(pca$var$coord[,1],pca$var$coord[,2])&lt;0, c(pca$var$coord[,1],pca$var$coord[,2])*-1, c(pca$var$coord[,1],pca$var$coord[,2])))) 15.4.12 Renomeando vetores rownames(pca$var$coord)=c(&quot;pH&quot;,&quot;H+AL&quot;,&quot;K&quot;,&quot;P&quot;,&quot;Ca&quot;,&quot;Mg&quot;,&quot;V%&quot;) # renomeando vetores library(plotrix) plot(pca$var$coord, xlab=&quot;CP1 (72.2 %)&quot;, ylab=&quot;CP2 (14.8 %)&quot;, col=&quot;white&quot;, ylim=c(-1,1), xlim=c(-1.5,1.5)) abline(h=0,v=0, lty=2) arrows(0,0,pca$var$coord[1,1],pca$var$coord[1,2], length = 0.1) arrows(0,0,pca$var$coord[2,1],pca$var$coord[2,2], length = 0.1) arrows(0,0,pca$var$coord[3,1],pca$var$coord[3,2], length = 0.1) arrows(0,0,pca$var$coord[4,1],pca$var$coord[4,2], length = 0.1) arrows(0,0,pca$var$coord[5,1],pca$var$coord[5,2], length = 0.1) arrows(0,0,pca$var$coord[6,1],pca$var$coord[6,2], length = 0.1) arrows(0,0,pca$var$coord[7,1],pca$var$coord[7,2], length = 0.1) text(c(1.05, -1.1, 0.8, -0.3, 1, 1.05, 1.1), c(0.3, 0.1, 0.3, 1, 0.06, -0.1, -0), rownames(pca$var$coord)) draw.circle(0,0,max(ifelse(c(pca$var$coord[,1],pca$var$coord[,2])&lt;0, c(pca$var$coord[,1],pca$var$coord[,2])*-1, c(pca$var$coord[,1],pca$var$coord[,2])))) 15.5 Screeplot 15.5.1 Conjunto de dados Trat=rep(c(paste(&quot;T&quot;,1:10)), e=12) dados=data.frame(Trat,ph,HAL,K,P,Ca,Mg,V) 15.5.2 Calculando as médias mph=tapply(ph, Trat, mean) mHAL=tapply(HAL, Trat, mean) mK=tapply(K, Trat, mean) mP=tapply(P, Trat, mean) mCa=tapply(Ca, Trat, mean) mMg=tapply(Mg, Trat, mean) mV=tapply(V, Trat, mean) dadosm=data.frame(mph,mHAL,mK,mP,mCa,mMg,mV) 15.5.3 Pacote FactomineR library(FactoMineR) pca=PCA(dadosm) 15.5.4 Screeplot do factoextra library(factoextra) fviz_screeplot(pca) fviz_screeplot(pca, title=&quot;&quot;, # removendo título font.family=&quot;serif&quot;, # fonte times new roman barcolor=&quot;black&quot;, # cor da borda preto addlabels=T, ggtheme=theme_classic())+ xlab(&quot;Componente Principal&quot;)+ # nomeando eixo x ylab(&quot;Porcentagem de explicação da variância&quot;) # nomeando eixo y 15.6 Manualmente pelo stats 15.6.1 Somente colunas par(family=&quot;serif&quot;) # fonte times new roman bar=barplot(pca$eig[,2], ylim=c(0,100)) 15.6.2 Com colunas, pontos e linhas par(family=&quot;serif&quot;) # fonte times new roman bar=barplot(pca$eig[,2], ylim=c(0,100)) points(bar, pca$eig[,2], type = &quot;o&quot;) 15.6.3 Com colunas, pontos, linhas e legenda par(family=&quot;serif&quot;) # fonte times new roman bar=barplot(pca$eig[,2], ylim=c(0,100)) points(bar, pca$eig[,2], type = &quot;o&quot;) text(bar, pca$eig[,2]+5, round(pca$eig[,2],2)) 15.6.4 Editando rownames(pca$eig)=c(paste(&quot;CP&quot;,1:length(pca$eig[,2]))) par(family=&quot;serif&quot;) # fonte times new roman bar=barplot(pca$eig[,2], ylim=c(0,100), las=1, col=&quot;darkblue&quot;, xlab=&quot;Componente principal&quot;, ylab=&quot;Porcentagem de explicação&quot;) abline(h=0) points(bar, pca$eig[,2], type = &quot;o&quot;) text(bar, pca$eig[,2]+5, round(pca$eig[,2],2)) 15.7 Correlação com variável latente 15.7.1 Calculando as médias mph=tapply(ph, Trat, mean) mHAL=tapply(HAL, Trat, mean) mK=tapply(K, Trat, mean) mP=tapply(P, Trat, mean) mCa=tapply(Ca, Trat, mean) mMg=tapply(Mg, Trat, mean) mV=tapply(V, Trat, mean) dadosm=data.frame(mph,mHAL,mK,mP,mCa,mMg,mV) 15.8 Pacote psych library(psych) pca.solo &lt;- principal(scale(dadosm), # scale é para padronizar dados nfactors=5, # Numero de componentes n.obs=10, # possui 10 observações/ variável rotate=&#39;none&#39;, scores=TRUE) pca.solo ## Principal Components Analysis ## Call: principal(r = scale(dadosm), nfactors = 5, rotate = &quot;none&quot;, n.obs = 10, ## scores = TRUE) ## Standardized loadings (pattern matrix) based upon correlation matrix ## PC1 PC2 PC3 PC4 PC5 h2 u2 com ## mph 0,95 0,26 -0,02 -0,14 0,12 1 3,1e-04 1,2 ## mHAL -0,93 0,09 0,20 0,28 0,06 1 5,4e-04 1,3 ## mK 0,69 0,24 0,69 -0,01 -0,02 1 7,4e-04 2,2 ## mP -0,27 0,95 -0,17 0,03 -0,04 1 5,4e-05 1,2 ## mCa 0,92 0,03 -0,28 0,28 0,02 1 2,9e-03 1,4 ## mMg 0,96 -0,09 0,08 0,24 -0,04 1 2,9e-03 1,2 ## mV 0,99 -0,01 -0,13 -0,08 -0,03 1 8,4e-04 1,1 ## ## PC1 PC2 PC3 PC4 PC5 ## SS loadings 5,06 1,04 0,64 0,24 0,02 ## Proportion Var 0,72 0,15 0,09 0,03 0,00 ## Cumulative Var 0,72 0,87 0,96 1,00 1,00 ## Proportion Explained 0,72 0,15 0,09 0,03 0,00 ## Cumulative Proportion 0,72 0,87 0,96 1,00 1,00 ## ## Mean item complexity = 1,4 ## Test of the hypothesis that 5 components are sufficient. ## ## The root mean square of the residuals (RMSR) is 0 ## with the empirical chi square 0 with prob &lt; NA ## ## Fit based upon off diagonal values = 1 15.8.1 Extraindo correlações (load &lt;- pca.solo$loadings) ## ## Loadings: ## PC1 PC2 PC3 PC4 PC5 ## mph 0,949 0,258 -0,137 0,116 ## mHAL -0,933 0,201 0,278 ## mK 0,687 0,240 0,685 ## mP -0,270 0,946 -0,171 ## mCa 0,918 -0,277 0,276 ## mMg 0,961 0,239 ## mV 0,987 -0,129 ## ## PC1 PC2 PC3 PC4 PC5 ## SS loadings 5,057 1,037 0,639 0,237 0,022 ## Proportion Var 0,722 0,148 0,091 0,034 0,003 ## Cumulative Var 0,722 0,871 0,962 0,996 0,999 15.8.2 Correlação com a variável latente CP1 library(lattice) sorted.loadings1 &lt;- load[order(load[,1]),1] (load1 &lt;- dotplot(sorted.loadings1, cex=1.5, xlab=&quot;Correlação com a variável latente&quot;, col=&quot;black&quot;, scales=list(fontfamily=&quot;serif&quot;,cex=1.2), auto.key=list(cex=1.2), pch=16)) 15.8.3 Correlação com a variável latente CP2 sorted.loadings2 &lt;- load[order(load[,2]),2] (load2 &lt;- dotplot(sorted.loadings2, cex=1.5, xlab=&quot;Correlação com a variável latente&quot;, col=&quot;black&quot;, scales=list(fontfamily=&quot;serif&quot;,cex=1.2), pch=16)) 15.8.4 Correlação com a variável latente CP3 sorted.loadings3 &lt;- load[order(load[,3]),3] (load3 &lt;- dotplot(sorted.loadings3, cex=1.5, xlab=&quot;Correlação com a variável latente&quot;, col=&quot;black&quot;, scales=list(fontfamily=&quot;serif&quot;,cex=1.2), pch=16)) 15.9 Extraindo cluster de forma automática 15.9.1 Conjunto de dados var1=c(rnorm(20,10,2),rnorm(20,20,2),rnorm(20,15,2)) var2=c(rnorm(20,20,2),rnorm(20,18,2),rnorm(20,15,2)) var3=c(rnorm(20,100,2),rnorm(20,60,2),rnorm(20,80,2)) var4=c(rnorm(20,150,2),rnorm(20,160,2),rnorm(20,140,2)) trat=paste(&quot;T&quot;,1:60) dados=data.frame(trat,var1,var2,var3,var4) 15.9.2 Construindo Dendrograma Obs. método UPGMA - average dend=as.dendrogram(hclust(dist(scale(dados[,2:5])),method = &quot;average&quot;)) library(dendextend) dend=set(dend, &quot;branches_k_color&quot;, value = 1:3, k = 3) 15.9.3 Extraindo cluster cluster=as.factor(as.vector(cutree(dend,k=3))) 15.9.4 PCA Obs. Não editado library(factoextra);library(FactoMineR) data=dados[,2:5] rownames(data)=dados$trat fviz_pca_biplot(PCA(data),col.ind = cluster, addEllipses = T) # default e padronizado "],
["dendograma.html", " 16 Dendograma", " 16 Dendograma 16.0.1 Conjunto de dados Violent Crime Rates by US State Description This data set contains statistics, in arrests per 100,000 residents for assault, murder, and rape in each of the 50 US states in 1973. Also given is the percent of the population living in urban areas. McNeil, D. R. (1977) Interactive Data Analysis. New York: Wiley. data(&quot;USArrests&quot;) USArrests ## Murder Assault UrbanPop Rape ## Alabama 13,2 236 58 21,2 ## Alaska 10,0 263 48 44,5 ## Arizona 8,1 294 80 31,0 ## Arkansas 8,8 190 50 19,5 ## California 9,0 276 91 40,6 ## Colorado 7,9 204 78 38,7 ## Connecticut 3,3 110 77 11,1 ## Delaware 5,9 238 72 15,8 ## Florida 15,4 335 80 31,9 ## Georgia 17,4 211 60 25,8 ## Hawaii 5,3 46 83 20,2 ## Idaho 2,6 120 54 14,2 ## Illinois 10,4 249 83 24,0 ## Indiana 7,2 113 65 21,0 ## Iowa 2,2 56 57 11,3 ## Kansas 6,0 115 66 18,0 ## Kentucky 9,7 109 52 16,3 ## Louisiana 15,4 249 66 22,2 ## Maine 2,1 83 51 7,8 ## Maryland 11,3 300 67 27,8 ## Massachusetts 4,4 149 85 16,3 ## Michigan 12,1 255 74 35,1 ## Minnesota 2,7 72 66 14,9 ## Mississippi 16,1 259 44 17,1 ## Missouri 9,0 178 70 28,2 ## Montana 6,0 109 53 16,4 ## Nebraska 4,3 102 62 16,5 ## Nevada 12,2 252 81 46,0 ## New Hampshire 2,1 57 56 9,5 ## New Jersey 7,4 159 89 18,8 ## New Mexico 11,4 285 70 32,1 ## New York 11,1 254 86 26,1 ## North Carolina 13,0 337 45 16,1 ## North Dakota 0,8 45 44 7,3 ## Ohio 7,3 120 75 21,4 ## Oklahoma 6,6 151 68 20,0 ## Oregon 4,9 159 67 29,3 ## Pennsylvania 6,3 106 72 14,9 ## Rhode Island 3,4 174 87 8,3 ## South Carolina 14,4 279 48 22,5 ## South Dakota 3,8 86 45 12,8 ## Tennessee 13,2 188 59 26,9 ## Texas 12,7 201 80 25,5 ## Utah 3,2 120 80 22,9 ## Vermont 2,2 48 32 11,2 ## Virginia 8,5 156 63 20,7 ## Washington 4,0 145 73 26,2 ## West Virginia 5,7 81 39 9,3 ## Wisconsin 2,6 53 66 10,8 ## Wyoming 6,8 161 60 15,6 16.0.2 Calculando as distâncias d=dist(USArrests) R=hclust(d) 16.0.3 Dendograma plot(R) 16.0.4 Altura dos rótulos plot(R, hang=-1) 16.0.5 Editando argumentos plot(R, las=1, # Escala do eixo na horizontal hang=-1, # alinhas altura dos rótulos main=&quot;&quot;, # Título vazio ylab=&quot;Dist?ncia&quot;) # Título do eixo Y 16.0.6 Separando em grupos Neste exemplo vamos considerar dois grupos # Chamando package dendextend library(dendextend) # Construindo o dendograma dend=as.dendrogram(hclust(dist(USArrests), method=&#39;average&#39;)) # Definindo cores e grupos para o dendograma dend=set(dend,&quot;branches_k_color&quot;, value = c(&quot;red&quot;, &quot;blue&quot;), k = 2) # Plotando o gráfico par(cex=0.7) plot(dend, las=1, ylab=&quot;Distância&quot;) 16.0.7 Caixas separando grupos library(dendextend) dend=as.dendrogram(hclust(dist(USArrests), method=&#39;average&#39;)) dend=set(dend, &quot;branches_k_color&quot;, value = c(&quot;red&quot;, &quot;blue&quot;), k = 2) par(cex=0.7, mai=c(1.2,0.8,0,0)) plot(dend, las=1, ylab=&quot;Distância&quot;) par(cex=0.8) # Construindo caixa de separação entre os grupos rect.dendrogram(dend, k=2, # Dois grupos border = 8, # cor da borda (8: cinza) lty = 5, # formato da linha lwd = 2) # espessura da linha 16.0.8 Árvore filogenética (Em círculo) library(ape) par(mar=c(0,0,1,0)) plot(as.phylo(R), cex=0.7, hang=-1, type=&quot;fan&quot;) 16.0.9 Cor e separando por grupo par(mar=c(0,0,1,0)) clus=cutree(R,2) colors=c(&quot;red&quot;,&quot;blue&quot;) plot(as.phylo(R), cex=0.7, hang=-1, type=&quot;fan&quot;, tip.color=colors[clus]) 16.0.10 Formato radial par(mar=c(0,0,1,0)) plot(as.phylo(R), cex=0.7, hang=-1, type=&quot;radial&quot;) "],
["expression.html", " 17 Expression()", " 17 Expression() Durante a elaboração de gráficos no R, os títulos são inseridos conforme o nome da variável em que está analisando. Muitas vezes é necessário editar esses nomes no gráfico, entretanto, existem casos complexos em que é necessário inserir uma série de comandos para conseguir o desejado. Neste tutorial, iremos abordar a função expression() e alguns exemplos. Não iremos trabalhar com um conjunto de dados neste exemplo, dessa forma, a linha respectiva ao plot(1,1,axes=F, col=\"white\", ylab=\"\",xlab=\"\") serve apenas para utilizar a função legend() posteriormente. Lembrando que, a função expression() pode ser usada para todos os argumentos de renomeação (ylab, xlab, main, title, etc…) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=&quot;Resposta&quot;, bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(sum()==&quot;sum()&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(delta == &quot;delta&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(alpha == &quot;alpha&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(beta ==&quot;beta&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(gamma == &quot;gamma&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(mu == &quot;mu&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(sigma == &quot;sigma&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(pi == &quot;pi&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(epsilon == &quot;epsilon&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(lambda == &quot;lambda&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(italic(A) == &quot;italic(A)&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;,legend= expression(bold(A) == &quot;bold(A)&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend = expression(sigma^2==frac(sum((X[i]-mu)^2,i==1,n),N)), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(hat(Y) == &quot;hat(y)&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(bar(x) ==&quot;bar(x)&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(sqrt(Y)==&quot;sqrt(Y)&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(x^2 == &quot;x^2&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(x[2] == &quot;x[2]&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;,legend= expression(&quot;nome\\nresposta&quot;==&quot;nome\\\\nresposta&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(hat(Y)==ax^2+bx+c,R^2==0.99), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(hat(Y)==ax^2+bx+c,R^2==0.99,italic(p-valor)==0.0001), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(Produtividade~(kg~ha^-1)), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;,legend= expression(H[2]*0[2]~(mu*&quot;mol&quot;~g^-1~MFPA)), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(MSPA~(g~kg^-1)), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;,legend= expression(bold(italic(A)) == &quot;bold(italic(A))&quot;), bty=&quot;n&quot;, cex=2) plot(1,1,axes=F, col=&quot;white&quot;, ylab=&quot;&quot;,xlab=&quot;&quot;) legend(&quot;center&quot;, legend=expression(hat(Y)==ax^2+bx+c), bty=&quot;n&quot;, cex=2) "],
["layout-graphics.html", " 18 layout (graphics)", " 18 layout (graphics) 18.0.1 Como modificar o layout do R graphics Durante a elaboração de gráficos no R, muitas vezes nos deparamos com problemas na margem (Títulos ou escalas ficam cortados) ou querem elaborar dois ou mais gráficos em uma única saída. Neste sentido, o presente tutorial irá abordar algumas funções para modificar o layout do gráfico base do R. Não iremos trabalhar com um conjunto de dados neste exemplo, dessa forma, a linha respectiva ao plot(1,1,axes=F, col=\"white\", ylab=\"\",xlab=\"\") serve apenas para demonstrar como alterar os parâmetros gráficos. 18.0.1 Gráfico Simples plot(1,1, ylab=&quot;Eixo Y&quot;,xlab=&quot;Eixo X&quot;) 18.0.1 Parâmetros de margem O comando par(…) é utilizado para alterar os parâmetros gráficos e deve ser executando antes do gráfico. Entretanto, uma vez executado essa linha de comando, todos os outros gráficos irão apresentar o mesmo layout, exceto se fechar o Rstudio ou limpar todos os gráficos. O comando mai representa o tamanho de margem e deve-se digitar um vetor numérico com quatro valores, sendo respectivamente em ordem, inferior, esquerda, superior e direita (mai=c(bottom, left, top, right)). par(mai=c(1,1,1,1)) plot(1,1, ylab=&quot;Eixo Y&quot;,xlab=&quot;Eixo X&quot;) 18.0.1 Fonte do gráfico O comando para alterar a fonte do gráfico também é realizada dentro de par(…). Os argumentos do comando é family=\"fonte\". par(family=\"serif\"): Times New Roman par(family=&quot;serif&quot;) plot(1,1, ylab=&quot;Eixo Y&quot;,xlab=&quot;Eixo X&quot;) 18.0.1 Cor do gráfico Especificando a cor do gráfico (Geral, exceto eixos) par(col=&quot;red&quot;) plot(1,1, ylab=&quot;Eixo Y&quot;,xlab=&quot;Eixo X&quot;) Especificando a cor da escala dos eixos do gráfico par(col.axis=&quot;red&quot;) plot(1,1, ylab=&quot;&quot;,xlab=&quot;&quot;) Especificando cor do nome dos eixos par(col.lab=&quot;red&quot;) plot(1,1, ylab=&quot;Eixo Y&quot;,xlab=&quot;Eixo X&quot;) Especificando cor do título par(col.main=&quot;red&quot;) plot(1,1, ylab=&quot;Eixo Y&quot;,xlab=&quot;Eixo X&quot;,main=&quot;title&quot;) 18.0.1 Tamanho de letra par(cex=1.3) plot(1,1, ylab=&quot;Eixo Y&quot;,xlab=&quot;Eixo X&quot;,main=&quot;title&quot;) cex.axis : Tamanho da fonte das escalas de Y e X cex.lab : Tamaho da fonte do nome dos eixos cex.main : Tamanho da fonte do título 18.0.1 Sobrepor gráficos plot(c(1,2,3,4,5,6), ylab=&quot;Eixo Y&quot;,xlab=&quot;Eixo X&quot;,main=&quot;title&quot;, type=&quot;o&quot;,col=&quot;red&quot;) par(new=T) plot(c(6,5,4,3,2,1), ylab=&quot;&quot;,xlab=&quot;&quot;,main=&quot;&quot;, type=&quot;o&quot;,col=&quot;blue&quot;) 18.0.1 Dois ou mais gráficos em uma saída mfrow=c(1,2): vetor de dados em que o primeiro representa o número de linhas e o segundo o número de colunas (Neste caso, uma linha e duas colunas) par(mfrow=c(1,2)) plot(c(1,2,3,4,5,6), ylab=&quot;Eixo Y&quot;,xlab=&quot;Eixo X&quot;,main=&quot;title&quot;, type=&quot;o&quot;,col=&quot;red&quot;) plot(c(6,5,4,3,2,1), ylab=&quot;Eixo Y&quot;,xlab=&quot;Eixo X&quot;,main=&quot;title&quot;, type=&quot;o&quot;,col=&quot;blue&quot;) 18.0.1 Saída com dois gráficas na primeira linha e um gráfico na segunda linha Saída com dois gráficas na primeira linha e um gráfico na segunda linha e necessário criar uma matriz com as posições. Exemplo de matriz: Matriz com quatro valores (c(1,3,2,3)) e duas colunas (ncol=2). Neste caso, a linha 1 apresenta os valores 1 e 2, que representam o primeiro e o segundo plot. A linha 2 apresenta os valores 3 e 3 que representa o terceiro plot. matrix(c(1,3,2,3), ncol=2) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 3 layout(matrix(c(1,3,2,3), ncol=2)) plot(c(1,2,3,4,5,6), ylab=&quot;Eixo Y&quot;,xlab=&quot;Eixo X&quot;,main=&quot;title&quot;, type=&quot;o&quot;,col=&quot;red&quot;) plot(c(6,5,4,3,2,1), ylab=&quot;Eixo Y&quot;,xlab=&quot;Eixo X&quot;,main=&quot;title&quot;, type=&quot;o&quot;,col=&quot;blue&quot;) plot(c(1,6,1,6,1,6), ylab=&quot;Eixo Y&quot;,xlab=&quot;Eixo X&quot;,main=&quot;title&quot;, type=&quot;o&quot;,col=&quot;blue&quot;) "],
["ggplot2.html", " 19 ggplot2", " 19 ggplot2 Em construção 19.0.1 Como juntar vários gráficos do ggplot2 No tutorial abaixo apresentamos uma das formas de juntar vários gráficos do ggplot2 em uma única figura. Obs.: Estamos usando o gráfico de colunas como exemplo, todavia, esses mesmos comandos funcionam para todos os gráficos do ggplot2 e de outros pacotes que utilizam o ggplot2. 19.0.1.1 Conjunto de dados Vamos trabalhar com três experimentos em DIC com quatro tratamentos e três repetições cada. exp1=c(10,12,13,18,19,16,5,6,5,25,26,28) exp2=c(9,12,11,18,20,16,7,6,9,25,28,28) exp3=c(9,12,13,18,22,15,3,6,4,25,30,28) Trat=rep(c(paste(&quot;T&quot;,1:4)),e=3) dados=data.frame(Trat,exp1,exp2,exp3) dados$Trat=as.factor(Trat) 19.0.2 Juntando três gráficos do ggplot2 Obs Para edição do gráfico ver tutorial sobre gráfico de colunas usando o ggplot2 library(ggplot2) m1=tapply(exp1, Trat, mean);d1=tapply(exp1, Trat, sd) dados1=data.frame(Trat=rownames(m1),m1,d1) a=ggplot(dados1, aes(x=Trat,y=m1))+geom_col()+theme_bw()+ geom_errorbar(aes(ymax=m1+d1, ymin=m1-d1), width=0.25) m2=tapply(exp2, Trat, mean);d2=tapply(exp2, Trat, sd) dados2=data.frame(Trat=rownames(m2),m2,d2) b=ggplot(dados2, aes(x=Trat,y=m2))+geom_col()+theme_bw()+ geom_errorbar(aes(ymax=m2+d2,ymin=m2-d2), width=0.25) m3=tapply(exp3, Trat, mean);d3=tapply(exp3, Trat, sd) dados3=data.frame(Trat=rownames(m3),m3,d3) c=ggplot(dados3, aes(x=Trat,y=m3))+geom_col()+theme_bw()+ geom_errorbar(aes(ymax=m3+d3,ymin=m3-d3),width=0.25) 19.0.3 Gráficos lado a lado library(gridExtra) grid.arrange(a,b,c,ncol=3) 19.0.4 Gráficos um abaixo do outro library(gridExtra) grid.arrange(a,b,c,ncol=1) 19.0.5 Dois na primeira linha e uma no lado esquerdo da segunda linha library(gridExtra) grid.arrange(a,b,c,ncol=2) 19.0.6 Dois na primeira linha e uma centralizado na segunda linha library(gridExtra) grid.arrange(a,b,c, layout_matrix = rbind(c(1,1,2,2), c(NA,3,3,NA))) 19.0.7 Dois na primeira linha e uma a direita na segunda linha library(gridExtra) grid.arrange(a,b,c, layout_matrix = rbind(c(1,1,2,2), c(NA,NA,3,3))) "],
["análise-de-regressão-linear-e-não-linear.html", " 20 Análise de regressão linear e não-linear 20.1 Conjunto de dados 20.2 Linear Simples 20.3 Quadrático 20.4 Cúbico 20.5 Logarítmico 20.6 Michaelis-Menten (MM) 20.7 MM Modificado 20.8 Segmentada linear 20.9 Segmentada quadrático 20.10 Mitscherlich 20.11 Logística de 3 termos 20.12 Logística de 4 termos 20.13 Yield Loss 20.14 Weibull 3 20.15 Weibul 4 20.16 Assintótica 2 20.17 Assintótica 3 20.18 Brain-Counsens 4 20.19 Brain-Counsens 5 20.20 Cedergreen-Ritz-Streibig 3 20.21 Cedergreen-Ritz-Streibig 4 20.22 Modelo exponencial 20.23 Modelo loess 20.24 Coef. de determinação (\\(R^2\\)) 20.25 AIC 20.26 BIC", " 20 Análise de regressão linear e não-linear Nas mais diversas áreas da pesquisa, seja ela na área médica, biológica, industrial, química entre outras, é de grande interesse verificar se duas ou mais variáveis estão relacionadas de alguma forma. Para expressar esta relação é muito importante estabelecer um modelo matemático. Este tipo de modelagem é chamado de regressão, e ajuda a entender como determinadas variáveis influenciam outra variável, ou seja, verifica como o comportamento de uma ou mais variáveis podem mudar o comportamento de outra. Na agronomia, a análise de regressão é muito utilizada por exemplo, para estabelecer doses de máxima resposta de produtos fitossanitários, adubos, populações de plantas, etc..; ou mesmo no estudo do desenvolvimento de uma planta, o que chamamos de curva de crescimento. Popularmente, é comum a utilização de curva do tipo polinomial, visto a facilidade de sua utilização e explicação. Todavia, muito dos dados não se comportam dessa forma, ainda que o ajuste seja significativo, podendo assim, levar a conclusões limitadas em função da análise inadequada. Logo, o presente tutorial apresenta diferentes ajustes de regressão linear e não-linear de um mesmo conjunto de dados. Neste tutorial, você irá reparar que em quase todos os modelos, o coeficientes serão significativos, demonstrando que quase todos os modelos são válidos para explicar o comportamento dos dados. A questão é, qual o melhor modelo? Obs. Este é um tutorial para demonstração dos modelos de regressão. Alguns casos ele não é significativo ou uma das pressuposições não é atendida. É um tutorial apenas para fins didáticos. 20.1 Conjunto de dados O conjunto de dados é de um experimento cujo objetivo foi avaliar a perda de massa da casca de romã em estufa a \\(60^oC\\). Foi utilizado oito repetições em oito avaliações (60, 210,390, 720, 930, 1410, 1890 e 2370 minutos) `PERDA DE MASSA CAA`=c(18.15810,17.99376,14.81450,15.39822,21.62234,20.45106,18.65319,20.96547,36.77274,39.92503,34.60874,35.70286,43.57189,42.19460,39.23367,43.36169,52.90384,52.64886,45.61431,47.81200,44.41734,47.40493,46.15373,47.12330,65.29474,67.78859,64.60738,66.24453,63.97464,66.77636,65.37446,65.11912,67.86385,70.68877,69.45271,70.33895,69.43583,71.56150,69.73480,69.97407,69.02813,71.28882,71.17485,71.22420,71.32344,72.46687,71.17063,72.07550,69.16576,71.44176,71.30762,71.34075,71.42775,72.59710,71.28255,72.19996,69.30339,71.59471,71.44040,71.45729,71.53206,72.72733,71.39446,72.32441) TEMPO=rep(c(60,210,390,720,930,1410,1890,2370),e=8) dados=data.frame(TEMPO,`PERDA DE MASSA CAA`) y=c(`PERDA DE MASSA CAA`) x=c(TEMPO) data=data.frame(y,x) 20.1.1 Média e desvio-padrão amostral (media=tapply(y,x, mean)) ## 60 210 390 720 930 1410 1890 2370 ## 18,50708 39,42140 48,00979 65,64748 69,88131 71,21905 71,34541 71,47176 (desvio=tapply(y,x, sd)) ## 60 210 390 720 930 1410 1890 2370 ## 2,485224 3,479257 3,133973 1,229025 1,080134 1,007882 1,004939 1,002227 (tempo=c(60,210,390,720,930,1410,1890,2370)) ## [1] 60 210 390 720 930 1410 1890 2370 20.1.2 Gráficos exploratórios 20.1.3 Gráfico de caixas boxplot(y~x) 20.1.4 Gráfico de dispersão plot(y~x) 20.1.5 Gráfico de dispersão com médias plot(y~x) points(media~tempo,pch=16,col=&quot;red&quot;) 20.1.6 Gráfico de linhas com as médias par(mfrow=c(1,2)) plot(media~tempo, type=&quot;b&quot;) plot(media~tempo, type=&quot;l&quot;) 20.1.7 Histograma hist(y) 20.2 Linear Simples O modelo de regressão linear simples (MRLS) se define uma relação linear entre a variável dependente e uma variável independente. \\[Y=\\beta_1x+\\beta_0\\] 20.2.1 Criando o modelo de regressão modl=lm(y~x) summary(modl) ## ## Call: ## lm(formula = y ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -24,4181 -8,1253 0,4191 8,8542 16,0914 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 38,099512 2,368998 16,08 &lt; 2e-16 *** ## x 0,018886 0,001876 10,07 1,15e-14 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 11,62 on 62 degrees of freedom ## Multiple R-squared: 0,6205, Adjusted R-squared: 0,6144 ## F-statistic: 101,4 on 1 and 62 DF, p-value: 1,147e-14 20.2.2 Diagnóstico 20.2.3 Normalidade dos erros hnp::hnp(modl) ## Gaussian model (lm object) shapiro.test(resid(modl)) # erros não normais ## ## Shapiro-Wilk normality test ## ## data: resid(modl) ## W = 0,94067, p-value = 0,004079 20.2.4 Falta de ajuste (Desvio da regressão) modq=aov(y~as.factor(x)) anova(modl,modq) ## Analysis of Variance Table ## ## Model 1: y ~ x ## Model 2: y ~ as.factor(x) ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 62 8377,2 ## 2 56 236,7 6 8140,5 321,02 &lt; 2,2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 20.2.5 Construindo gráfico par(family=&quot;serif&quot;) plot(media~tempo, main=&quot;Linear Simples&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlim=c(0,2500), xlab=&quot;Time (Minutes)&quot;, pch=16, ylim=c(0,80)) curve(coef(modl)[1]+coef(modl)[2]*x, add=TRUE, lty=2) legend(&quot;topleft&quot;, cex=1, bty=&quot;n&quot;, legend = c(expression(hat(Y)==38.09951+0.01889*x))) 20.2.6 ggplot2 library(ggplot2) da=data.frame(media,tempo) ggplot(da,aes(y=media,x=tempo))+ geom_point()+ geom_smooth(method=&quot;lm&quot;,se = F,col=&quot;black&quot;,size=0.1,lty=2)+ theme_classic()+ ylab(&quot;Weight loss (%)&quot;)+ xlab(&quot;Time (Minutes)&quot;) 20.3 Quadrático \\[Y=\\beta_2x^2+\\beta_1x+\\beta_0\\] 20.3.1 Criando modelo de regressão mod1=lm(y~x+I(x^2)) summary(mod1) ## ## Call: ## lm(formula = y ~ x + I(x^2)) ## ## Residuals: ## Min 1Q Median 3Q Max ## -11,428 -5,288 1,756 4,360 8,018 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 2,226e+01 1,528e+00 14,57 &lt;2e-16 *** ## x 6,763e-02 3,367e-03 20,09 &lt;2e-16 *** ## I(x^2) -2,055e-05 1,371e-06 -14,99 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 5,415 on 61 degrees of freedom ## Multiple R-squared: 0,919, Adjusted R-squared: 0,9163 ## F-statistic: 345,9 on 2 and 61 DF, p-value: &lt; 2,2e-16 20.3.2 Diagnóstico do modelo 20.3.3 Normalidade dos erros hnp::hnp(mod1) ## Gaussian model (lm object) shapiro.test(resid(mod1)) # erros nao normais ## ## Shapiro-Wilk normality test ## ## data: resid(mod1) ## W = 0,92285, p-value = 0,000655 20.3.4 Fator de inflação de variância (Multicolinearidade) car::vif(mod1) # problema de multicolinearidade ## x I(x^2) ## 14,84834 14,84834 20.3.5 Falta de ajuste (Desvio da regressão) modq=aov(y~as.factor(x)) anova(mod1,modq) ## Analysis of Variance Table ## ## Model 1: y ~ x + I(x^2) ## Model 2: y ~ as.factor(x) ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 61 1788,55 ## 2 56 236,68 5 1551,9 73,438 &lt; 2,2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 20.3.6 Construindo gráfico par(family=&quot;serif&quot;) plot(media~tempo, main=&quot;Quadrático&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlim=c(0,2500), xlab=&quot;Time (Minutes)&quot;, pch=16, ylim=c(0,80)) curve(coef(mod1)[1]+coef(mod1)[2]*x+coef(mod1)[3]*x^2, add=TRUE, lty=2) legend(&quot;topleft&quot;, cex=1, bty=&quot;n&quot;, legend = c(expression(hat(Y)==22.26+0.006763*x-0.00002055*x^2))) 20.3.7 Ponto de máximo (Ou mínimo) O ponto de máximo ou mínimo podem ser encontrados de várias formas 20.3.8 Manualmente (xmax=-coef(mod1)[2]/(2*coef(mod1)[3])) ## x ## 1645,317 (ymax=coef(mod1)[1]+coef(mod1)[2]*xmax+coef(mod1)[3]*xmax^2) ## (Intercept) ## 77,89475 20.3.9 Usando o which.max ou which.min plot(y~x) tend=curve(coef(mod1)[1]+coef(mod1)[2]*x+coef(mod1)[3]*x^2,add=T) tend$x[which.max(tend$y)] ## [1] 1653,9 # tend$x[which.min(tend$y)] # no caso de mínimo 20.3.10 ggplot2 library(ggplot2) da=data.frame(media,tempo) ggplot(da,aes(y=media,x=tempo))+ geom_point()+ geom_smooth(method=&quot;lm&quot;,formula = y~poly(x,2), se = F,col=&quot;black&quot;,size=0.1,lty=2)+ theme_classic()+ ylab(&quot;Weight loss (%)&quot;)+ xlab(&quot;Time (Minutes)&quot;) 20.4 Cúbico \\[Y=\\beta_3x^3+\\beta_2x^2+\\beta_1x+\\beta_0\\] 20.4.1 Construindo o modelo mod2=lm(y~x+I(x^2)+I(x^3)) summary(mod2) ## ## Call: ## lm(formula = y ~ x + I(x^2) + I(x^3)) ## ## Residuals: ## Min 1Q Median 3Q Max ## -6,0186 -1,3299 -0,3928 1,3155 8,0377 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1,406e+01 9,927e-01 14,16 &lt;2e-16 *** ## x 1,174e-01 4,125e-03 28,47 &lt;2e-16 *** ## I(x^2) -7,536e-05 4,189e-06 -17,99 &lt;2e-16 *** ## I(x^3) 1,524e-08 1,149e-09 13,27 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 2,753 on 60 degrees of freedom ## Multiple R-squared: 0,9794, Adjusted R-squared: 0,9784 ## F-statistic: 951,1 on 3 and 60 DF, p-value: &lt; 2,2e-16 20.4.2 Diagnóstico do modelo 20.4.3 Normalidade dos erros hnp::hnp(mod2) ## Gaussian model (lm object) shapiro.test(resid(mod2)) # Erros nao normais ## ## Shapiro-Wilk normality test ## ## data: resid(mod2) ## W = 0,94796, p-value = 0,009093 20.4.4 Fator de inflação de variância (Multicolinearidade) car::vif(mod2) # alta multicolinearidade ## x I(x^2) I(x^3) ## 86,25922 536,46498 221,25164 20.4.5 Falta de ajuste (Desvio da regressão) modq=aov(y~as.factor(x)) anova(mod2,modq) ## Analysis of Variance Table ## ## Model 1: y ~ x + I(x^2) + I(x^3) ## Model 2: y ~ as.factor(x) ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 60 454,60 ## 2 56 236,68 4 217,93 12,891 1,666e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 20.4.6 Construindo o gráfico par(family=&quot;serif&quot;) plot(media~tempo, main=&quot;Cúbico&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlim=c(0,2500), xlab=&quot;Time (Minutes)&quot;, pch=16, ylim=c(0,80)) curve(coef(mod2)[1]+coef(mod2)[2]*x+coef(mod2)[3]*x^2+coef(mod2)[4]*x^3, add=TRUE, lty=2) legend(&quot;topleft&quot;, cex=1, bty=&quot;n&quot;, legend = c(expression(hat(Y)==14.06+0.01174*x-0.00007536*x^2+0.00000001524*x^3))) 20.4.7 ponto de máximo, mínimo e inflexão plot(media~tempo) curva=curve(coef(mod2)[1]+coef(mod2)[2]*x+coef(mod2)[3]*x^2+coef(mod2)[4]*x^3, add=TRUE, lty=2) # ponto de inflexão pi=-(2*coef(mod2)[3])/(3*2*coef(mod2)[4]) # ponto de máximo anterior ao ponto de inflexão xmax=curva$x[which.max(curva$y[curva$x&lt;pi])] # ponto de mínimo posterior ao ponto de inflexão xmin=curva$x[which.max(curva$y[curva$x&lt;pi])+which.min(curva$y[curva$x&gt;xmax])] plot(media~tempo) curva=curve(coef(mod2)[1]+coef(mod2)[2]*x+coef(mod2)[3]*x^2+coef(mod2)[4]*x^3, add=TRUE, lty=1) abline(v=c(xmax,xmin,pi),lty=2) 20.4.8 ggplot2 library(ggplot2) da=data.frame(media,tempo) ggplot(da,aes(y=media,x=tempo))+ geom_point()+ geom_smooth(method=&quot;lm&quot;,formula = y~poly(x,3), se = F,col=&quot;black&quot;,size=0.1,lty=2)+ theme_classic()+ ylab(&quot;Weight loss (%)&quot;)+ xlab(&quot;Time (Minutes)&quot;) 20.5 Logarítmico \\[Y=\\beta_{0}+\\beta_{1}\\log(x)\\] 20.5.1 Construindo modelo modelog=lm(y~log(x)) summary(modelog) ## ## Call: ## lm(formula = y ~ log(x)) ## ## Residuals: ## Min 1Q Median 3Q Max ## -8,5359 -3,5194 -0,5506 3,6366 8,4348 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -42,7285 3,3261 -12,85 &lt;2e-16 *** ## log(x) 15,5158 0,5096 30,45 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 4,724 on 62 degrees of freedom ## Multiple R-squared: 0,9373, Adjusted R-squared: 0,9363 ## F-statistic: 927,1 on 1 and 62 DF, p-value: &lt; 2,2e-16 20.5.2 Diagnóstico do modelo hnp::hnp(modelog) ## Gaussian model (lm object) shapiro.test(resid(modelog)) ## ## Shapiro-Wilk normality test ## ## data: resid(modelog) ## W = 0,94476, p-value = 0,006371 20.5.3 Construindo gráfico plot(media~tempo, main=&quot;Log&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlim=c(0,2500), xlab=&quot;Time (Minutes)&quot;, pch=16, ylim=c(0,80)) curve(-42.73+15.52*log(x),add=T,lty=2) legend(&quot;topleft&quot;, cex=1, bty=&quot;n&quot;, legend = c(expression(hat(Y)==-42.73+15.52*log(x)))) 20.6 Michaelis-Menten (MM) \\[Y=\\frac{A\\times x}{V+x}\\] 20.6.1 Construindo o modelo data=data.frame(y,x) n0 &lt;- nls(formula=y~A*x/(V+x), data=data, start=list(A=max(y), V=100), trace=TRUE) ## 2726,427 : 72,72733 100,00000 ## 820,4424 : 78,84265 179,59765 ## 691,338 : 80,90678 212,88993 ## 690,8008 : 81,02471 215,24858 ## 690,8006 : 81,02129 215,20409 ## 690,8006 : 81,02137 215,20519 summary(n0) ## ## Formula: y ~ A * x/(V + x) ## ## Parameters: ## Estimate Std. Error t value Pr(&gt;|t|) ## A 81,021 1,004 80,67 &lt;2e-16 *** ## V 215,205 11,711 18,38 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 3,338 on 62 degrees of freedom ## ## Number of iterations to convergence: 5 ## Achieved convergence tolerance: 3,035e-07 20.6.2 Diagnóstico do modelo shapiro.test(resid(n0)) ## ## Shapiro-Wilk normality test ## ## data: resid(n0) ## W = 0,9717, p-value = 0,1482 20.6.3 Construindo o gráfico A &lt;- coef(n0)[1]; V &lt;- coef(n0)[2] par(family=&quot;serif&quot;) plot(media~tempo, main=&quot;Michaelis Menten&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlim=c(0,2500), xlab=&quot;Time (Minutes)&quot;, pch=16, ylim=c(0,80)) curve(A*x/(V+x), add=TRUE, lty=2) legend(&quot;topleft&quot;, cex=1, bty=&quot;n&quot;, legend = c(expression(hat(Y)==frac(81.021*x,(215.205+x))))) 20.6.4 Utilizando outro método m.m &lt;- nls(y ~ SSmicmen(x, Vm, K), data = data) m.m ## Nonlinear regression model ## model: y ~ SSmicmen(x, Vm, K) ## data: data ## Vm K ## 81,02 215,20 ## residual sum-of-squares: 690,8 ## ## Number of iterations to convergence: 0 ## Achieved convergence tolerance: 2,047e-06 plot(media~tempo, main=&quot;Michaelis-Menten&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlim=c(0,2500), xlab=&quot;Time (Minutes)&quot;, pch=16, ylim=c(0,80)) curve((81.02135*x)/(215.20499+x), add=T) 20.7 MM Modificado \\[Y=\\frac{A\\times x}{V+x}+D\\times x \\] 20.7.1 Construindo modelo data=data.frame(y,x) n1 &lt;- nls(formula=y~A*x/(V+x)+D*x, data=data, start=list(A=max(y), V=100,D=10), trace=TRUE) ## 10206286603 : 72,72733 100,00000 10,00000 ## 802,0047 : 8,061554e+01 1,857416e+02 -9,194725e-04 ## 545,3405 : 91,710079373 263,748404929 -0,004630648 ## 521,8705 : 96,954052340 297,103221016 -0,006224234 ## 521,0745 : 98,085315801 303,935203239 -0,006567869 ## 521,0613 : 98,241471280 304,881731574 -0,006617559 ## 521,0611 : 98,261118528 305,001695810 -0,006623916 ## 521,0611 : 98,263575225 305,016711452 -0,006624713 summary(n1) ## ## Formula: y ~ A * x/(V + x) + D * x ## ## Parameters: ## Estimate Std. Error t value Pr(&gt;|t|) ## A 98,263575 4,439290 22,135 &lt; 2e-16 *** ## V 305,016711 25,778649 11,832 &lt; 2e-16 *** ## D -0,006625 0,001563 -4,239 7,73e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 2,923 on 61 degrees of freedom ## ## Number of iterations to convergence: 7 ## Achieved convergence tolerance: 9,342e-06 20.7.2 Construindo gráfico A &lt;- coef(n1)[1]; V &lt;- coef(n1)[2]; D&lt;-coef(n1)[3] par(family=&quot;serif&quot;) plot(media~tempo, main=&quot;Michaelis Menten (Corrigido)&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlim=c(0,2500), xlab=&quot;Time (Minutes)&quot;, pch=16, ylim=c(0,80)) curve(A*x/(V+x)+D*x, add=TRUE, lty=2) legend(&quot;topleft&quot;, cex=1, bty=&quot;n&quot;, legend = c(expression(hat(Y)==frac(98.263572*x,(305.016698+x))-0.006625*x))) 20.8 Segmentada linear \\[Y=\\beta_{1}X+\\beta_{0} (if\\leq X_1)\\] 20.8.1 Construindo o modelo linear modelo_linear&lt;- lm(y~x) summary(modelo_linear) ## ## Call: ## lm(formula = y ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -24,4181 -8,1253 0,4191 8,8542 16,0914 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 38,099512 2,368998 16,08 &lt; 2e-16 *** ## x 0,018886 0,001876 10,07 1,15e-14 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 11,62 on 62 degrees of freedom ## Multiple R-squared: 0,6205, Adjusted R-squared: 0,6144 ## F-statistic: 101,4 on 1 and 62 DF, p-value: 1,147e-14 20.8.2 Construindo o modelo segmentado library(segmented) modelo_pieciwise&lt;- segmented(modelo_linear, seg.Z = ~x, psi=1000) modelo_pieciwise ## Call: segmented.lm(obj = modelo_linear, seg.Z = ~x, psi = 1000) ## ## Meaningful coefficients of the linear terms: ## (Intercept) x U1.x ## 19,83682 0,06684 -0,06582 ## ## Estimated Break-Point(s): ## psi1.x ## 751,4 summary(modelo_pieciwise) ## ## ***Regression Model with Segmented Relationship(s)*** ## ## Call: ## segmented.lm(obj = modelo_linear, seg.Z = ~x, psi = 1000) ## ## Estimated Break-Point(s): ## Est. St.Err ## psi1.x 751,438 26,797 ## ## Meaningful coefficients of the linear terms: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 19,836818 1,106834 17,92 &lt;2e-16 *** ## x 0,066839 0,002612 25,59 &lt;2e-16 *** ## U1.x -0,065819 0,002873 -22,91 NA ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 3,635 on 60 degrees of freedom ## Multiple R-Squared: 0,9641, Adjusted R-squared: 0,9623 ## ## Convergence attained in 2 iter. (rel. change 0) 20.8.3 Definindo limite com base no platô y1=y[x&lt;=modelo_pieciwise$psi[2]] x11=x[x&lt;=modelo_pieciwise$psi[2]] 20.8.4 Curva do primeiro segmento mod=lm(y1~x11) summary(mod) ## ## Call: ## lm(formula = y1 ~ x11) ## ## Residuals: ## Min 1Q Median 3Q Max ## -9,0327 -2,9998 -0,7374 2,1557 9,6988 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 19,836818 1,532481 12,94 8,22e-14 *** ## x11 0,066839 0,003617 18,48 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 5,033 on 30 degrees of freedom ## Multiple R-squared: 0,9193, Adjusted R-squared: 0,9166 ## F-statistic: 341,6 on 1 and 30 DF, p-value: &lt; 2,2e-16 20.8.5 Construindo gráfico par(pch=16,las=1); par(family=&quot;serif&quot;) plot(media~tempo, las=1, cex=1.3, main=&quot;Segmentado Linear&quot;, ylab=&quot;Weight loss (%)&quot;, xlim=c(0,2500), xlab=&quot;Time (Minutes)&quot;, pch=16, ylim=c(0,80)) a=curve(coef(mod)[1]+coef(mod)[2]*x, to=modelo_pieciwise$psi[2], lty=2,add=T) plato=a$y[round(a$x,3)==round(modelo_pieciwise$psi[2],3)] lines(c(modelo_pieciwise$psi[2],max(x)), c(plato,plato),lty=2) legend(&quot;topleft&quot;, cex=1, legend=expression(hat(Y)==19.836817+0.066839*x~(&quot;if&quot;~x~&quot;&lt;&quot;~751.4)), bty=&quot;n&quot;) 20.9 Segmentada quadrático \\[Y=\\beta_{2}X^2+\\beta_{1}X+\\beta_{0} (if\\leq X_1)\\] 20.9.1 Construindo o modelo quadrático modelo_linear&lt;- lm(y~x+I(x^2)) summary(modelo_linear) ## ## Call: ## lm(formula = y ~ x + I(x^2)) ## ## Residuals: ## Min 1Q Median 3Q Max ## -11,428 -5,288 1,756 4,360 8,018 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 2,226e+01 1,528e+00 14,57 &lt;2e-16 *** ## x 6,763e-02 3,367e-03 20,09 &lt;2e-16 *** ## I(x^2) -2,055e-05 1,371e-06 -14,99 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 5,415 on 61 degrees of freedom ## Multiple R-squared: 0,919, Adjusted R-squared: 0,9163 ## F-statistic: 345,9 on 2 and 61 DF, p-value: &lt; 2,2e-16 20.9.2 Construindo o modelo segmentado library(segmented) modelo_pieciwise1&lt;- segmented(modelo_linear) modelo_pieciwise1 ## Call: segmented.lm(obj = modelo_linear) ## ## Meaningful coefficients of the linear terms: ## (Intercept) x I(x^2) U1.x ## 1,580e+01 9,004e-02 -4,424e-06 -7,368e-02 ## ## Estimated Break-Point(s): ## psi1.x ## 560,2 summary(modelo_pieciwise1) ## ## ***Regression Model with Segmented Relationship(s)*** ## ## Call: ## segmented.lm(obj = modelo_linear) ## ## Estimated Break-Point(s): ## Est. St.Err ## psi1.x 560,234 28,392 ## ## Meaningful coefficients of the linear terms: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1,580e+01 1,201e+00 13,151 &lt;2e-16 *** ## x 9,004e-02 4,718e-03 19,083 &lt;2e-16 *** ## I(x^2) -4,424e-06 1,764e-06 -2,508 0,0149 * ## U1.x -7,368e-02 6,596e-03 -11,171 NA ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 3,073 on 59 degrees of freedom ## Multiple R-Squared: 0,9748, Adjusted R-squared: 0,973 ## ## Convergence attained in 2 iter. (rel. change 0) 20.9.3 Valores para o primeiro segmento Obs. No caso do linear simples, podemo usar apenas os pontos abaixo do platô, no caso do segmentado quadrático aconselho englobar o ponto acima do acusado no platô. No meu caso é o ponto 930. y1=y[x&lt;=930] x11=x[x&lt;=930] mod=lm(y1~x11+I(x11^2)) summary(mod) ## ## Call: ## lm(formula = y1 ~ x11 + I(x11^2)) ## ## Residuals: ## Min 1Q Median 3Q Max ## -5,5773 -2,1731 0,0432 1,2608 8,0591 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1,357e+01 1,379e+00 9,839 7,13e-12 *** ## x11 1,175e-01 7,321e-03 16,047 &lt; 2e-16 *** ## I(x11^2) -6,173e-05 7,151e-06 -8,632 2,15e-10 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 3,293 on 37 degrees of freedom ## Multiple R-squared: 0,9715, Adjusted R-squared: 0,97 ## F-statistic: 630,9 on 2 and 37 DF, p-value: &lt; 2,2e-16 20.9.4 Construindo o gráfico par(pch=16,las=1); par(family=&quot;serif&quot;) plot(media~tempo, main=&quot;Segmentado Quadrático&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlim=c(0,2500), xlab=&quot;Time (Minutes)&quot;, pch=16, ylim=c(0,80)) maximo=-coef(mod)[2]/(2*coef(mod)[3]) a=curve(coef(mod)[1]+coef(mod)[2]*x+coef(mod)[3]*x^2, to=maximo, lty=2, add=T) plato=a$y[round(a$x,3)==round(maximo,3)] lines(c(maximo,max(x)), c(plato,plato),lty=2) legend(&quot;topleft&quot;, legend=expression(Y==13.57+0.1175*x-0.00006173*x^2~(&quot;if&quot;~x~&quot;&lt;&quot;~951.5095)), bty=&quot;n&quot;) 20.10 Mitscherlich \\[Y=A \\times(1-exp((B\\times C)-(C \\times X)\\] modelo2=nls(y~A*(1-exp((B*C)-(C*x))), start = list(A=80,B=-10,C=0.01),data=data) summary(modelo2) ## ## Formula: y ~ A * (1 - exp((B * C) - (C * x))) ## ## Parameters: ## Estimate Std. Error t value Pr(&gt;|t|) ## A 7,232e+01 5,606e-01 129,004 &lt; 2e-16 *** ## B -4,438e+01 8,610e+00 -5,155 2,9e-06 *** ## C 2,874e-03 1,302e-04 22,066 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 2,63 on 61 degrees of freedom ## ## Number of iterations to convergence: 7 ## Achieved convergence tolerance: 8,634e-07 par(pch=16,las=1); par(family=&quot;serif&quot;) plot(media~tempo,main=&quot;Mitscherlich&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlim=c(0,2500), xlab=&quot;Time (Minutes)&quot;, pch=16, ylim=c(0,80)) b=summary(modelo2) A=b$coefficients[1,1] B=b$coefficients[2,1] C=b$coefficients[3,1] a=curve(A*(1-exp((B*C)-(C*x))),lty=2,add=T) legend(&quot;topleft&quot;,expression(Y==72.31912*(1-e^{(-44.382759*0.002873)-(0.002873*x)})),bty=&quot;n&quot;) 20.11 Logística de 3 termos \\[Y = \\frac{d}{1+exp(b(x-e))}\\] library(drc) model &lt;- drm(y ~ x, fct = LL.3(), data = data) summary(model) ## ## Model fitted: Log-logistic (ED50 as parameter) with lower limit at 0 (3 parms) ## ## Parameter estimates: ## ## Estimate Std. Error t-value p-value ## b:(Intercept) -1,058194 0,062275 -16,992 &lt; 2,2e-16 *** ## d:(Intercept) 79,599836 1,684582 47,252 &lt; 2,2e-16 *** ## e:(Intercept) 208,408451 12,445682 16,745 &lt; 2,2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: ## ## 3,340759 (61 degrees of freedom) par(family=&quot;serif&quot;) plot(model,main=&quot;Logístico LL.3&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlab=&quot;Time (Minutes)&quot;, pch=16,lty=2) legend(&quot;topleft&quot;, legend=expression(hat(Y)==frac(79.599836, 1+exp(-1.058194(x-208.408455)))), bty=&quot;n&quot;) 20.11.1 ED, DL ou EC ED(model,10) ## Ed10 ## ## Estimated effective doses ## ## Estimate Std. Error ## e:1:10 26,131 2,755 ED(model,50) ## ED50 ## ## Estimated effective doses ## ## Estimate Std. Error ## e:1:50 208,408 12,446 ED(model,90) ## ED90 ## ## Estimated effective doses ## ## Estimate Std. Error ## e:1:90 1662,2 267,4 20.12 Logística de 4 termos \\[Y = c-\\frac{d-c}{1+exp(b(x-e))}\\] model1 &lt;- drm(y ~ x, fct = LL.4(), data = data) summary(model1) ## ## Model fitted: Log-logistic (ED50 as parameter) (4 parms) ## ## Parameter estimates: ## ## Estimate Std. Error t-value p-value ## b:(Intercept) -1,6960 0,1552 -10,9279 6,668e-16 *** ## c:(Intercept) 15,1899 1,9728 7,6995 1,597e-10 *** ## d:(Intercept) 74,5348 1,0697 69,6796 &lt; 2,2e-16 *** ## e:(Intercept) 289,3971 16,5292 17,5082 &lt; 2,2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: ## ## 2,950196 (60 degrees of freedom) par(family=&quot;serif&quot;) plot(model,main=&quot;Logístico LL.4&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlab=&quot;Time (Minutes)&quot;, pch=16,lty=2) legend(&quot;topleft&quot;, legend=expression(hat(Y)==15.1899+frac(74.59984-15.1899, 1+exp(-1.6960(x-289.3971)))), bty=&quot;n&quot;) 20.12.1 ED, DL ou EC ED(model,10) ## Ed10 ## ## Estimated effective doses ## ## Estimate Std. Error ## e:1:10 26,131 2,755 ED(model,50) ## ED50 ## ## Estimated effective doses ## ## Estimate Std. Error ## e:1:50 208,408 12,446 ED(model,90) ## ED90 ## ## Estimated effective doses ## ## Estimate Std. Error ## e:1:90 1662,2 267,4 20.13 Yield Loss \\[\\hat{Y}=\\frac{i\\times x}{1+\\frac{i\\times x}{A}}\\] #library(devtools) #install_github(&quot;OnofriAndreaPG/aomisc&quot;) par(family=&quot;serif&quot;) library(aomisc) model2 &lt;- drm(y ~ x, fct = DRC.YL(), data = data) summary(model2) ## ## Model fitted: Yield-Loss function (Cousens, 1985) (2 parms) ## ## Parameter estimates: ## ## Estimate Std. Error t-value p-value ## i:(Intercept) 0,376483 0,016637 22,629 &lt; 2,2e-16 *** ## A:(Intercept) 81,021404 0,996137 81,336 &lt; 2,2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: ## ## 3,337955 (62 degrees of freedom) plot(model2,main=&quot;Yield Loss&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlab=&quot;Time (Minutes)&quot;, pch=16,lty=2) legend(&quot;topleft&quot;, legend=expression(hat(YL)==frac(0.376483*x, 1+frac(0.376483*x,81.021705))), bty=&quot;n&quot;) 20.14 Weibull 3 \\[\\hat{Y}=d\\times e^{-e^{b\\times log(x)-e}}\\] par(family=&quot;serif&quot;) model3 &lt;- drm(y ~ x, fct = w3(), data = data) summary(model3) ## ## Model fitted: Weibull (type 1) with lower limit at 0 (3 parms) ## ## Parameter estimates: ## ## Estimate Std. Error t-value p-value ## b:(Intercept) -0,621433 0,051944 -11,963 &lt; 2,2e-16 *** ## d:(Intercept) 88,316665 3,466514 25,477 &lt; 2,2e-16 *** ## e:(Intercept) 135,558602 10,937572 12,394 &lt; 2,2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: ## ## 3,702132 (61 degrees of freedom) plot(model3,main=&quot;Weibull 3&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlab=&quot;Time (Minutes)&quot;, pch=16,lty=2) legend(&quot;topleft&quot;, legend=expression(hat(YL)==88.316665*e^(-e^{(-0.621433*(log(x)-135.558606))})), bty=&quot;n&quot;) 20.15 Weibul 4 \\[\\hat{Y} = c + (d − c)(1 − exp(− exp(b(log(x) − log(e)))))\\] par(family=&quot;serif&quot;) model4 &lt;- drm(y ~ x, fct = w4(), data = data) summary(model4) ## ## Model fitted: Weibull (type 1) (4 parms) ## ## Parameter estimates: ## ## Estimate Std. Error t-value p-value ## b:(Intercept) -1,2171 0,1156 -10,528 2,911e-15 *** ## c:(Intercept) 18,4270 1,2668 14,546 &lt; 2,2e-16 *** ## d:(Intercept) 76,5754 1,5142 50,571 &lt; 2,2e-16 *** ## e:(Intercept) 230,4661 11,7439 19,624 &lt; 2,2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: ## ## 3,134519 (60 degrees of freedom) plot(model4,main=&quot;Weibull 4&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlab=&quot;Time (Minutes)&quot;, pch=16,lty=2) legend(&quot;topleft&quot;, legend=expression(hat(YL)==18.4270+(76.5754-18.4270)(1-e^(-e^(-1.2171*(log(x)-log(230.4661)))))), bty=&quot;n&quot;) 20.16 Assintótica 2 par(family=&quot;serif&quot;) model5 &lt;- drm(y ~ x, fct = drc::AR.2(), data = data) summary(model5) ## ## Model fitted: Asymptotic regression with lower limit at 0 (2 parms) ## ## Parameter estimates: ## ## Estimate Std. Error t-value p-value ## d:(Intercept) 71,36776 0,64016 111,484 &lt; 2,2e-16 *** ## e:(Intercept) 285,21787 10,77269 26,476 &lt; 2,2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: ## ## 3,364715 (62 degrees of freedom) plot(model5,main=&quot;Assintótica 2&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlab=&quot;Time (Minutes)&quot;, pch=16,lty=2) 20.17 Assintótica 3 par(family=&quot;serif&quot;) model6 &lt;- drm(y ~ x, fct = drc::AR.3(), data = data) summary(model6) ## ## Model fitted: Shifted asymptotic regression (3 parms) ## ## Parameter estimates: ## ## Estimate Std. Error t-value p-value ## c:(Intercept) 8,65955 1,29240 6,7003 7,565e-09 *** ## d:(Intercept) 72,31924 0,55231 130,9390 &lt; 2,2e-16 *** ## e:(Intercept) 348,01446 15,20460 22,8888 &lt; 2,2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: ## ## 2,630211 (61 degrees of freedom) plot(model6,main=&quot;Assintótica 3&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlab=&quot;Time (Minutes)&quot;, pch=16,lty=2) 20.18 Brain-Counsens 4 model7 &lt;- drm(y ~ x, fct = drc::BC.4(), data = data) summary(model7) ## ## Model fitted: Brain-Cousens (hormesis) with lower limit fixed at 0 (4 parms) ## ## Parameter estimates: ## ## Estimate Std. Error t-value p-value ## b:(Intercept) -0,7419957 0,0628498 -11,8059 &lt; 2,2e-16 *** ## d:(Intercept) 149,6381450 28,0543384 5,3339 1,539e-06 *** ## e:(Intercept) 842,5975169 384,1854662 2,1932 0,032179 * ## f:(Intercept) -0,0196017 0,0066143 -2,9635 0,004356 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: ## ## 2,642605 (60 degrees of freedom) par(family=&quot;serif&quot;) plot(model,main=&quot;Brain-Counsens 4&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlab=&quot;Time (Minutes)&quot;, pch=16,lty=2) 20.19 Brain-Counsens 5 par(family=&quot;serif&quot;) model8 &lt;- drm(y ~ x, fct = drc::BC.5(), data = data) summary(model8) ## ## Model fitted: Brain-Cousens (hormesis) (5 parms) ## ## Parameter estimates: ## ## Estimate Std. Error t-value p-value ## b:(Intercept) -1,0445094 0,2286639 -4,5679 2,561e-05 *** ## c:(Intercept) 8,7627115 4,7730274 1,8359 0,071416 . ## d:(Intercept) 109,0339449 20,0242731 5,4451 1,055e-06 *** ## e:(Intercept) 486,0685001 143,3483090 3,3908 0,001248 ** ## f:(Intercept) -0,0112154 0,0051383 -2,1827 0,033048 * ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: ## ## 2,632805 (59 degrees of freedom) plot(model8,main=&quot;Brain-Cousens 5&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlab=&quot;Time (Minutes)&quot;, pch=16,lty=2) 20.20 Cedergreen-Ritz-Streibig 3 par(family=&quot;serif&quot;) model9 &lt;- drm(y ~ x, fct = drc::uml3a(), data = data) summary(model9) ## ## Model fitted: U-shaped Cedergreen-Ritz-Streibig (4 parms) ## ## Parameter estimates: ## ## Estimate Std. Error t-value p-value ## b:(Intercept) 1,70356 0,15617 10,9084 6,917e-16 *** ## d:(Intercept) 74,51053 1,06473 69,9805 &lt; 2,2e-16 *** ## e:(Intercept) 291,21663 16,71405 17,4235 &lt; 2,2e-16 *** ## f:(Intercept) -15,54808 1,99553 -7,7915 1,112e-10 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: ## ## 2,947189 (60 degrees of freedom) plot(model9,main=&quot;Cedergreen-Ritz-Streibig 3&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlab=&quot;Time (Minutes)&quot;, pch=16,lty=2) 20.21 Cedergreen-Ritz-Streibig 4 par(family=&quot;serif&quot;) model10 &lt;- drm(y ~ x, fct = drc::uml4a(), data = data) summary(model10) ## ## Model fitted: U-shaped Cedergreen-Ritz-Streibig (5 parms) ## ## Parameter estimates: ## ## Estimate Std. Error t-value p-value ## b:(Intercept) 4,64106 0,47568 9,7568 6,416e-14 *** ## c:(Intercept) -1701,15137 94,96264 -17,9139 &lt; 2,2e-16 *** ## d:(Intercept) 71,53869 0,42799 167,1489 &lt; 2,2e-16 *** ## e:(Intercept) 544,23492 21,39639 25,4358 &lt; 2,2e-16 *** ## f:(Intercept) -1748,54548 96,09285 -18,1964 &lt; 2,2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: ## ## 2,008856 (59 degrees of freedom) plot(model,main=&quot;Cedergreen-Ritz-Streibig 4&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlab=&quot;Time (Minutes)&quot;, pch=16,lty=2) 20.22 Modelo exponencial modelexp=lm(log(y)~x);summary(modelexp) ## ## Call: ## lm(formula = log(y) ~ x) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0,8722 -0,1354 0,1129 0,2682 0,3722 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3,543e+00 6,534e-02 54,216 &lt; 2e-16 *** ## x 4,188e-04 5,174e-05 8,095 2,71e-11 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 0,3206 on 62 degrees of freedom ## Multiple R-squared: 0,5138, Adjusted R-squared: 0,506 ## F-statistic: 65,52 on 1 and 62 DF, p-value: 2,711e-11 alpha=exp(modelexp$coefficients[1]) beta=modelexp$coefficients[2] model11=nls(y~A*exp(x*B),start=list(A=alpha,B=beta)) summary(model11) ## ## Formula: y ~ A * exp(x * B) ## ## Parameters: ## Estimate Std. Error t value Pr(&gt;|t|) ## A 4,237e+01 2,255e+00 18,790 &lt; 2e-16 *** ## B 2,762e-04 3,386e-05 8,156 2,12e-11 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## Residual standard error: 12,77 on 62 degrees of freedom ## ## Number of iterations to convergence: 6 ## Achieved convergence tolerance: 5,434e-06 plot(y~x) lines(seq(min(x), max(x), length.out = 100), predict(model11, newdata = data.frame(x = seq(min(x), max(x), length.out = 100))), col=&quot;red&quot;,lwd=2,lty=2) 20.23 Modelo loess model12=loess(y~x) summary(model12) ## Call: ## loess(formula = y ~ x) ## ## Number of Observations: 64 ## Equivalent Number of Parameters: 4,94 ## Residual Standard Error: 2,7 ## Trace of smoother matrix: 5,42 (exact) ## ## Control settings: ## span : 0,75 ## degree : 2 ## family : gaussian ## surface : interpolate cell = 0,2 ## normalize: TRUE ## parametric: FALSE ## drop.square: FALSE par(pch=16,las=1); par(family=&quot;serif&quot;) plot(media~tempo, main=&quot;Modelo Loess&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlim=c(0,2500), xlab=&quot;Time (Minutes)&quot;, pch=16, ylim=c(0,80)) lines(x,predict(model12,x),lty=2) ## ou par(pch=16,las=1); par(family=&quot;serif&quot;) plot(media~tempo, main=&quot;modelo loess&quot;, las=1, cex=1.3, ylab=&quot;Weight loss (%)&quot;, xlim=c(0,2500), xlab=&quot;Time (Minutes)&quot;, pch=16, ylim=c(0,80)) lines(seq(60,2370,5),predict(model12,seq(60,2370,5)),lty=2) ## ou library(ggplot2) ggplot(data,aes(y=y,x=x))+ geom_point()+ geom_smooth()+ theme_bw()+ theme_classic()+ xlab(&quot;Time (minutes)&quot;)+ ylab(&quot;Weight loss (%)&quot;) 20.24 Coef. de determinação (\\(R^2\\)) r2=c(1-var(residuals(modl))/var(residuals(lm(y~1))), 1-var(residuals(mod1))/var(residuals(lm(y~1))), 1-var(residuals(mod2))/var(residuals(lm(y~1))), 1-var(residuals(modelog))/var(residuals(lm(y~1))), 1-var(residuals(n0))/var(residuals(lm(y~1))), 1-var(residuals(n1))/var(residuals(lm(y~1))), 1-var(residuals(modelo_pieciwise))/var(residuals(lm(y~1))), 1-var(residuals(modelo_pieciwise1))/var(residuals(lm(y~1))), 1-var(residuals(modelo2))/var(residuals(lm(y~1))), 1-var(residuals(model))/var(residuals(lm(y~1))), 1-var(residuals(model1))/var(residuals(lm(y~1))), 1-var(residuals(model2))/var(residuals(lm(y~1))), 1-var(residuals(model3))/var(residuals(lm(y~1))), 1-var(residuals(model4))/var(residuals(lm(y~1))), 1-var(residuals(model5))/var(residuals(lm(y~1))), 1-var(residuals(model6))/var(residuals(lm(y~1))), 1-var(residuals(model7))/var(residuals(lm(y~1))), 1-var(residuals(model8))/var(residuals(lm(y~1))), 1-var(residuals(model9))/var(residuals(lm(y~1))), 1-var(residuals(model10))/var(residuals(lm(y~1))), 1-var(residuals(model11))/var(residuals(lm(y~1)))) 20.25 AIC aic=c(AIC(modl), AIC(mod1), AIC(mod2), AIC(modelog), AIC(n0), AIC(n1), AIC(modelo_pieciwise), AIC(modelo_pieciwise1), AIC(modelo2), AIC(model), AIC(model1), AIC(model2), AIC(model3), AIC(model4), AIC(model5), AIC(model6), AIC(model7), AIC(model8), AIC(model9), AIC(model10), AIC(model11)) 20.26 BIC bic=c(BIC(modl), BIC(mod1), BIC(mod2), BIC(modelog), BIC(n0), BIC(n1), BIC(modelo_pieciwise), BIC(modelo_pieciwise1), BIC(modelo2), BIC(model), BIC(model1), BIC(model2), BIC(model3), BIC(model4), BIC(model5), BIC(model6), BIC(model7), BIC(model8), BIC(model9), BIC(model10), BIC(model11)) analise=cbind(aic,bic,r2) rownames(analise)=c(&quot;Linear&quot;,&quot;Quadrático&quot;,&quot;Cúbico&quot;,&quot;Log&quot;, &quot;Michaelis-Mente&quot;,&quot;Michaelis Menten (Corrigido)&quot;, &quot;Segmentada Linear&quot;,&quot;Segmentada Quadrática&quot;, &quot;Mitscherlich&quot;,&quot;Logístico LL.3&quot;,&quot;Logístico LL.4&quot;, &quot;Yield Loss&quot;, &quot;Weibull 3&quot;,&quot;Weibull 4&quot;, &quot;Assintótica 2&quot;,&quot;Assintótica 3&quot;, &quot;Brain-Counsens 4&quot;,&quot;Brain-Counsens 5&quot;, &quot;Cedergreen-Ritz-Streibig 3&quot;, &quot;Cedergreen-Ritz-Streibig 4&quot;, &quot;Exponencial&quot;) knitr::kable(analise) aic bic r2 Linear 499,5847 506,0614 0,6204884 Quadrático 402,7620 411,3975 0,9189732 Cúbico 317,0989 327,8933 0,9794051 Log 384,3339 390,8105 0,9373170 Michaelis-Mente 339,8781 346,3547 0,9687055 Michaelis Menten (Corrigido) 323,8311 332,4667 0,9765013 Segmentada Linear 352,6998 363,4943 0,9640795 Segmentada Quadrática 332,1142 345,0675 0,9747606 Mitscherlich 310,3357 318,9713 0,9808822 Logístico LL.3 340,9449 349,5804 0,9691758 Logístico LL.4 325,9732 336,7677 0,9763419 Yield Loss 339,8781 346,3547 0,9687055 Weibull 3 354,0919 362,7274 0,9621318 Weibull 4 333,7306 344,5250 0,9732933 Assintótica 2 340,9002 347,3768 0,9688639 Assintótica 3 310,3357 318,9713 0,9808822 Brain-Counsens 4 311,8796 322,6740 0,9810184 Brain-Counsens 5 312,3284 325,2817 0,9814725 Cedergreen-Ritz-Streibig 3 325,8427 336,6371 0,9763901 Cedergreen-Ritz-Streibig 4 277,7064 290,6597 0,9892136 Exponencial 511,5978 518,0744 0,5422488 "],
["análise-de-sobrevivência.html", " 21 Análise de sobrevivência 21.1 Conjunto de dados 21.2 Histograma 21.3 Método não-paramétrico de Kaplan-meier 21.4 Modelo paramétrico 21.5 Distribuição gaussiano 21.6 Distribuição logistico 21.7 Distribuição Log normal 21.8 Distribuição Log-Logístico 21.9 Distribuição Weibull (default) 21.10 Gompertz 21.11 Gamma 21.12 Método semi-paramétrico de Cox 21.13 Modelo de riscos proporcionais de COX 21.14 Critério de inferência de Akaike 21.15 Resíduo", " 21 Análise de sobrevivência Análise de sobrevivência, também denominada análise de sobrevida, é um ramo da estatística que estuda o tempo de duração esperado até a ocorrência de um ou mais eventos, tais como morte em organismos biológicos ou falha em sistemas mecânicos. Na agronomia, tem sido bastante utilizada na avaliação residual de produtos fitossanitários em insetos, tempo até a morte em função de um doença, etc. 21.1 Conjunto de dados O conjunto de dados é de um experimento cujo objetivo é avaliar a mortalidade de insetos em função de alguns produtos comerciais. tempo=c(10,10,10,10,10,10,10,24,24,24,24,48,10,10,10,10,10,10,10,10,10,10,10,10,24,24,48,48,72,72,72,72,72,72,72,72,10,10,24,24,72,72,72,72,72,72,96,96,10,10,10,48,96,96,144,144,168,168,168,168,10,10,24,24,72,72,72,96,96,120,168,168,10,10,10,10,10,10,10,24,24,24,24,48,10,10,10,24,24,120,120,144,144,144,144,144,10,10,144,144,168,168,168,168,168,168,168,168,24,72,96,96,120,144,168,168,168,168,168,168,24,72,96,120,144,168,168,168,168,168,168,168,10,10,10,10,10,10,24,72,96,168,168,168) # criando vetor de status (Ocorreu ou nao o evento) status=c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0) trat=rep(c(&quot;T1&quot;,&quot;T2&quot;,&#39;T3&#39;),e=48) dados=data.frame(trat,tempo,status) 21.2 Histograma hist(tempo) 21.3 Método não-paramétrico de Kaplan-meier 21.3.1 Sem considerar tratamentos Somente uma análise exploratória geral library(survival) library(survminer) KM &lt;- survfit(Surv(tempo,status) ~ 1, type=&quot;kaplan-meier&quot;) summary(KM) ## Call: survfit(formula = Surv(tempo, status) ~ 1, type = &quot;kaplan-meier&quot;) ## ## time n.risk n.event survival std.err lower 95% CI upper 95% CI ## 10 144 44 0,694 0,0384 0,6231 0,774 ## 24 100 19 0,562 0,0413 0,4870 0,650 ## 48 81 5 0,528 0,0416 0,4522 0,616 ## 72 76 20 0,389 0,0406 0,3169 0,477 ## 96 56 10 0,319 0,0389 0,2517 0,405 ## 120 46 5 0,285 0,0376 0,2198 0,369 ## 144 41 11 0,208 0,0338 0,1515 0,286 ## 168 30 12 0,125 0,0276 0,0811 0,193 ggsurvplot( fit = survfit(Surv(tempo, status) ~ 1),data=dados, xlab = &quot;Time (hours)&quot;, ylab = &quot;Overall survival probability&quot;) 21.3.2 Tempo médio de sobrevivência a=survival:::survmean(KM, rmean=48) a$matrix[5] ## *rmean ## 33,22222 21.3.3 Considerando tratamentos 21.3.4 Conferindo diferenças par a par pvalor=pairwise_survdiff(Surv(tempo,status)~trat,data=dados, rho=0) knitr::kable(pvalor$p.value) T1 T2 T2 0,0003111 T3 0,0000000 0,0006521 Todos diferem entre si 21.3.5 Grafico por tratamento usando o método de Kaplan-Meier KM1 &lt;- survfit(Surv(tempo,status) ~ trat, type=&quot;kaplan-meier&quot;) ggsurvplot( fit = survfit(Surv(tempo, status) ~ trat),data=dados, xlab = &quot;Time (hours)&quot;, ylab = &quot;Overall survival probability&quot;) 21.3.6 Tempo médio de sobrevivência survival:::survmean(KM1, rmean=48)$matrix[,5] ## trat=T1 trat=T2 trat=T3 ## 27,37500 32,12500 40,16667 21.4 Modelo paramétrico 21.4.1 Distribuição exponencial 21.4.2 Sem considerar tratamentos KM &lt;- survreg(Surv(tempo,status) ~ 1, dist=&quot;exponential&quot;) summary(KM) ## ## Call: ## survreg(formula = Surv(tempo, status) ~ 1, dist = &quot;exponential&quot;) ## Value Std. Error z p ## (Intercept) 4,4473 0,0891 49,9 &lt;2e-16 ## ## Scale fixed at 1 ## ## Exponential distribution ## Loglik(model)= -686,4 Loglik(intercept only)= -686,4 ## Number of Newton-Raphson Iterations: 4 ## n= 144 s &lt;- seq(.01, .99, by = .01) t_0 &lt;- predict(KM, newdata = data.frame(trat=paste(&quot;T1&quot;,&quot;T2&quot;,&quot;T3&quot;)), type = &quot;quantile&quot;, p = s) smod &lt;- data.frame(time = c(t_0), # acrescentar os tratamentos surv = rep(1 - s, times = 1), # mudar o times upper = NA, lower = NA) ggsurvplot(smod) 21.4.3 Considerando tratamentos library(survival) library(survminer) KM2 &lt;- survreg(Surv(tempo,status) ~ trat, dist=&quot;exponential&quot;) summary(KM) ## ## Call: ## survreg(formula = Surv(tempo, status) ~ 1, dist = &quot;exponential&quot;) ## Value Std. Error z p ## (Intercept) 4,4473 0,0891 49,9 &lt;2e-16 ## ## Scale fixed at 1 ## ## Exponential distribution ## Loglik(model)= -686,4 Loglik(intercept only)= -686,4 ## Number of Newton-Raphson Iterations: 4 ## n= 144 anova(KM2) ## Df Deviance Resid. Df -2*LL Pr(&gt;Chi) ## NULL NA NA 143 1372,722 NA ## trat 2 44,24522 141 1328,477 2,467593e-10 s &lt;- seq(.01, .99, by = .01) t_0 &lt;- predict(KM2, newdata = data.frame(trat = &quot;T1&quot;), type = &quot;quantile&quot;, p = s) t_1 &lt;- predict(KM2, newdata = data.frame(trat = &quot;T2&quot;), type = &quot;quantile&quot;, p = s) t_2 &lt;- predict(KM2, newdata = data.frame(trat = &quot;T3&quot;), type = &quot;quantile&quot;, p = s) smod &lt;- data.frame(time = c(t_0, t_1, t_2), # acrescentar os tratamentos surv = rep(1 - s, times = 3), # mudar o times strata = rep(c(&quot;T1&quot;, &quot;T2&quot;, &quot;T3&quot;), each = length(s)), upper = NA, lower = NA) ggsurvplot(smod) 21.5 Distribuição gaussiano 21.5.1 Sem considerar tratamentos KM &lt;- survreg(Surv(tempo,status) ~ 1, dist=&quot;gaussian&quot;) summary(KM) ## ## Call: ## survreg(formula = Surv(tempo, status) ~ 1, dist = &quot;gaussian&quot;) ## Value Std. Error z p ## (Intercept) 78,8982 5,9303 13,3 &lt;2e-16 ## Log(scale) 4,2519 0,0652 65,2 &lt;2e-16 ## ## Scale= 70,2 ## ## Gaussian distribution ## Loglik(model)= -735,6 Loglik(intercept only)= -735,6 ## Number of Newton-Raphson Iterations: 5 ## n= 144 21.5.2 Considerando tratamentos KM3 &lt;- survreg(Surv(tempo,status) ~ trat, dist=&quot;gaussian&quot;) summary(KM3) ## ## Call: ## survreg(formula = Surv(tempo, status) ~ trat, dist = &quot;gaussian&quot;) ## Value Std. Error z p ## (Intercept) 36,3750 8,5829 4,24 2,3e-05 ## tratT2 37,3906 12,1867 3,07 0,0022 ## tratT3 89,7879 12,3737 7,26 4,0e-13 ## Log(scale) 4,0854 0,0649 62,96 &lt; 2e-16 ## ## Scale= 59,5 ## ## Gaussian distribution ## Loglik(model)= -712,5 Loglik(intercept only)= -735,6 ## Chisq= 46,23 on 2 degrees of freedom, p= 9,2e-11 ## Number of Newton-Raphson Iterations: 4 ## n= 144 anova(KM3) ## Df Deviance Resid. Df -2*LL Pr(&gt;Chi) ## NULL NA NA 142 1471,295 NA ## trat 2 46,22645 140 1425,069 9,163355e-11 t_0 &lt;- predict(KM3, newdata = data.frame(trat = &quot;T1&quot;), type = &quot;lp&quot;) t_1 &lt;- predict(KM3, newdata = data.frame(trat = &quot;T2&quot;),type = &quot;lp&quot;) t_2 &lt;- predict(KM3, newdata = data.frame(trat = &quot;T3&quot;),type = &quot;lp&quot;) x_grid &lt;- 1:400 sur_curves &lt;- sapply(t_0, function(x)survreg.distributions[[KM3$dist]]$density((x - x_grid)/KM3$scale)[, 1]) sur_curves1 &lt;- sapply(t_1, function(x)survreg.distributions[[KM3$dist]]$density((x - x_grid)/KM3$scale)[, 1]) sur_curves2 &lt;- sapply(t_2, function(x)survreg.distributions[[KM3$dist]]$density((x - x_grid)/KM3$scale)[, 1]) matplot(x_grid, sur_curves, type = &quot;l&quot;, lty = 1,ylim=c(0,1)) lines(x_grid,sur_curves1,col=&quot;red&quot;) lines(x_grid,sur_curves2,col=&quot;blue&quot;) 21.6 Distribuição logistico 21.6.1 Sem considerar tratamentos KM &lt;- survreg(Surv(tempo,status) ~ 1, dist=&quot;logistic&quot;) summary(KM) ## ## Call: ## survreg(formula = Surv(tempo, status) ~ 1, dist = &quot;logistic&quot;) ## Value Std. Error z p ## (Intercept) 72,5020 6,3768 11,4 &lt;2e-16 ## Log(scale) 3,7594 0,0722 52,0 &lt;2e-16 ## ## Scale= 42,9 ## ## Logistic distribution ## Loglik(model)= -739,5 Loglik(intercept only)= -739,5 ## Number of Newton-Raphson Iterations: 5 ## n= 144 21.6.2 Considerando tratamentos KM4 &lt;- survreg(Surv(tempo,status) ~ trat, dist=&quot;logistic&quot;) summary(KM4) ## ## Call: ## survreg(formula = Surv(tempo, status) ~ trat, dist = &quot;logistic&quot;) ## Value Std. Error z p ## (Intercept) 35,4968 7,7296 4,59 4,4e-06 ## tratT2 31,3587 12,2695 2,56 0,011 ## tratT3 98,9211 12,4589 7,94 2,0e-15 ## Log(scale) 3,5544 0,0737 48,20 &lt; 2e-16 ## ## Scale= 35 ## ## Logistic distribution ## Loglik(model)= -714,3 Loglik(intercept only)= -739,5 ## Chisq= 50,45 on 2 degrees of freedom, p= 1,1e-11 ## Number of Newton-Raphson Iterations: 4 ## n= 144 anova(KM4) ## Df Deviance Resid. Df -2*LL Pr(&gt;Chi) ## NULL NA NA 142 1479,091 NA ## trat 2 50,45218 140 1428,639 1,107765e-11 t_0 &lt;- predict(KM4, newdata = data.frame(trat = &quot;T1&quot;), type = &quot;lp&quot;) t_1 &lt;- predict(KM4, newdata = data.frame(trat = &quot;T2&quot;),type = &quot;lp&quot;) t_2 &lt;- predict(KM4, newdata = data.frame(trat = &quot;T3&quot;),type = &quot;lp&quot;) x_grid &lt;- 1:400 sur_curves &lt;- sapply(t_0, function(x)survreg.distributions[[KM4$dist]]$density((x - x_grid)/KM4$scale)[, 1]) sur_curves1 &lt;- sapply(t_1, function(x)survreg.distributions[[KM4$dist]]$density((x - x_grid)/KM4$scale)[, 1]) sur_curves2 &lt;- sapply(t_2, function(x)survreg.distributions[[KM4$dist]]$density((x - x_grid)/KM4$scale)[, 1]) matplot(x_grid, sur_curves, type = &quot;l&quot;, lty = 1,ylim=c(0,1)) lines(x_grid,sur_curves1,col=&quot;red&quot;) lines(x_grid,sur_curves2,col=&quot;blue&quot;) 21.7 Distribuição Log normal 21.7.1 Sem considerar tratamentos KM &lt;- survreg(Surv(tempo,status) ~ 1, dist=&quot;lognormal&quot;) summary(KM) ## ## Call: ## survreg(formula = Surv(tempo, status) ~ 1, dist = &quot;lognormal&quot;) ## Value Std. Error z p ## (Intercept) 3,8658 0,1080 35,80 &lt; 2e-16 ## Log(scale) 0,2438 0,0648 3,76 0,00017 ## ## Scale= 1,28 ## ## Log Normal distribution ## Loglik(model)= -681,1 Loglik(intercept only)= -681,1 ## Number of Newton-Raphson Iterations: 5 ## n= 144 21.7.2 Considerando tratamentos KM5 &lt;- survreg(Surv(tempo,status) ~ trat, dist=&quot;lognormal&quot;) summary(KM5) ## ## Call: ## survreg(formula = Surv(tempo, status) ~ trat, dist = &quot;lognormal&quot;) ## Value Std. Error z p ## (Intercept) 3,2165 0,1655 19,43 &lt;2e-16 ## tratT2 0,5650 0,2352 2,40 0,016 ## tratT3 1,3925 0,2394 5,82 6e-09 ## Log(scale) 0,1369 0,0644 2,12 0,034 ## ## Scale= 1,15 ## ## Log Normal distribution ## Loglik(model)= -665,4 Loglik(intercept only)= -681,1 ## Chisq= 31,54 on 2 degrees of freedom, p= 1,4e-07 ## Number of Newton-Raphson Iterations: 4 ## n= 144 anova(KM5) ## Df Deviance Resid. Df -2*LL Pr(&gt;Chi) ## NULL NA NA 142 1362,288 NA ## trat 2 31,54326 140 1330,744 1,414059e-07 s &lt;- seq(.01, .99, by = .01) t_0 &lt;- predict(KM5, newdata = data.frame(trat = &quot;T1&quot;), type = &quot;quantile&quot;, p = s) t_1 &lt;- predict(KM5, newdata = data.frame(trat = &quot;T2&quot;), type = &quot;quantile&quot;, p = s) t_2 &lt;- predict(KM5, newdata = data.frame(trat = &quot;T3&quot;), type = &quot;quantile&quot;, p = s) smod &lt;- data.frame(time = c(t_0, t_1, t_2), # acrescentar os tratamentos surv = rep(1 - s, times = 3), # mudar o times strata = rep(c(&quot;T1&quot;, &quot;T2&quot;, &quot;T3&quot;), each = length(s)), upper = NA, lower = NA) ggsurvplot(smod) 21.8 Distribuição Log-Logístico 21.8.1 Sem considerar tratamentos KM &lt;- survreg(Surv(tempo,status) ~ 1, dist=&quot;loglogistic&quot;) summary(KM) ## ## Call: ## survreg(formula = Surv(tempo, status) ~ 1, dist = &quot;loglogistic&quot;) ## Value Std. Error z p ## (Intercept) 3,8717 0,1192 32,49 &lt;2e-16 ## Log(scale) -0,2265 0,0711 -3,19 0,0014 ## ## Scale= 0,797 ## ## Log logistic distribution ## Loglik(model)= -687 Loglik(intercept only)= -687 ## Number of Newton-Raphson Iterations: 5 ## n= 144 21.8.2 Considerando tratamentos KM6 &lt;- survreg(Surv(tempo,status) ~ trat, dist=&quot;loglogistic&quot;) summary(KM6) ## ## Call: ## survreg(formula = Surv(tempo, status) ~ trat, dist = &quot;loglogistic&quot;) ## Value Std. Error z p ## (Intercept) 3,1947 0,1689 18,92 &lt; 2e-16 ## tratT2 0,5839 0,2530 2,31 0,021 ## tratT3 1,5687 0,2441 6,43 1,3e-10 ## Log(scale) -0,3709 0,0725 -5,11 3,2e-07 ## ## Scale= 0,69 ## ## Log logistic distribution ## Loglik(model)= -669,2 Loglik(intercept only)= -687 ## Chisq= 35,64 on 2 degrees of freedom, p= 1,8e-08 ## Number of Newton-Raphson Iterations: 4 ## n= 144 anova(KM6) ## Df Deviance Resid. Df -2*LL Pr(&gt;Chi) ## NULL NA NA 142 1373,973 NA ## trat 2 35,64462 140 1338,328 1,819156e-08 s &lt;- seq(.01, .99, by = .01) t_0 &lt;- predict(KM6, newdata = data.frame(trat = &quot;T1&quot;), type = &quot;quantile&quot;, p = s) t_1 &lt;- predict(KM6, newdata = data.frame(trat = &quot;T2&quot;), type = &quot;quantile&quot;, p = s) t_2 &lt;- predict(KM6, newdata = data.frame(trat = &quot;T3&quot;), type = &quot;quantile&quot;, p = s) smod &lt;- data.frame(time = c(t_0, t_1, t_2), # acrescentar os tratamentos surv = rep(1 - s, times = 3), # mudar o times strata = rep(c(&quot;T1&quot;, &quot;T2&quot;, &quot;T3&quot;), each = length(s)), upper = NA, lower = NA) ggsurvplot(smod) 21.9 Distribuição Weibull (default) 21.9.1 Sem considerar tratamentos KM &lt;- survreg(Surv(tempo,status) ~ 1, dist=&quot;weibull&quot;) summary(KM) ## ## Call: ## survreg(formula = Surv(tempo, status) ~ 1, dist = &quot;weibull&quot;) ## Value Std. Error z p ## (Intercept) 4,4310 0,0969 45,72 &lt;2e-16 ## Log(scale) 0,0685 0,0740 0,93 0,35 ## ## Scale= 1,07 ## ## Weibull distribution ## Loglik(model)= -685,9 Loglik(intercept only)= -685,9 ## Number of Newton-Raphson Iterations: 6 ## n= 144 21.9.2 Considerando tratamentos KM7 &lt;- survreg(Surv(tempo,status) ~ trat, dist=&quot;weibull&quot;) summary(KM7) ## ## Call: ## survreg(formula = Surv(tempo, status) ~ trat, dist = &quot;weibull&quot;) ## Value Std. Error z p ## (Intercept) 3,6259 0,1334 27,18 &lt; 2e-16 ## tratT2 0,7769 0,1906 4,08 4,6e-05 ## tratT3 1,4392 0,2043 7,05 1,8e-12 ## Log(scale) -0,0969 0,0744 -1,30 0,19 ## ## Scale= 0,908 ## ## Weibull distribution ## Loglik(model)= -663,4 Loglik(intercept only)= -685,9 ## Chisq= 45 on 2 degrees of freedom, p= 1,7e-10 ## Number of Newton-Raphson Iterations: 5 ## n= 144 anova(KM7) ## Df Deviance Resid. Df -2*LL Pr(&gt;Chi) ## NULL NA NA 142 1371,840 NA ## trat 2 44,99626 140 1326,844 1,695061e-10 s &lt;- seq(.01, .99, by = .01) t_0 &lt;- predict(KM7, newdata = data.frame(trat = &quot;T1&quot;), type = &quot;quantile&quot;, p = s) t_1 &lt;- predict(KM7, newdata = data.frame(trat = &quot;T2&quot;), type = &quot;quantile&quot;, p = s) t_2 &lt;- predict(KM7, newdata = data.frame(trat = &quot;T3&quot;), type = &quot;quantile&quot;, p = s) smod &lt;- data.frame(time = c(t_0, t_1, t_2), # acrescentar os tratamentos surv = rep(1 - s, times = 3), # mudar o times strata = rep(c(&quot;T1&quot;, &quot;T2&quot;, &quot;T3&quot;), each = length(s)), upper = NA, lower = NA) ggsurvplot(smod) 21.10 Gompertz library(flexsurv) KM9=flexsurvreg(Surv(tempo,status)~trat,dist=&quot;Gompertz&quot;) summary(KM9) ## trat=T1 ## time est lcl ucl ## 1 10 0,786371074 7,187924e-01 0,83943849 ## 2 24 0,549854904 4,434602e-01 0,64050367 ## 3 48 0,279640531 1,821254e-01 0,38028131 ## 4 72 0,130206542 6,490193e-02 0,21561018 ## 5 96 0,054871360 2,040002e-02 0,11632022 ## 6 120 0,020657887 5,043557e-03 0,05962935 ## 7 144 0,006846406 8,958938e-04 0,02949505 ## 8 168 0,001964497 9,034696e-05 0,01405177 ## ## trat=T2 ## time est lcl ucl ## 1 10 0,91229451 0,86901056 0,9399498 ## 2 24 0,79577094 0,71198119 0,8550142 ## 3 48 0,61465240 0,49517999 0,7074381 ## 4 72 0,45902365 0,33621603 0,5697394 ## 5 96 0,32998531 0,21742041 0,4412666 ## 6 120 0,22722132 0,13619486 0,3353306 ## 7 144 0,14902446 0,07688698 0,2459599 ## 8 168 0,09250403 0,03719677 0,1774858 ## ## trat=T3 ## time est lcl ucl ## 1 10 0,9585577 0,9352449 0,9731776 ## 2 24 0,9000225 0,8500392 0,9337660 ## 3 48 0,7989822 0,7128341 0,8616093 ## 4 72 0,6983485 0,5903741 0,7845301 ## 5 96 0,5997606 0,4811075 0,7031812 ## 6 120 0,5049620 0,3834571 0,6175876 ## 7 144 0,4157087 0,2922862 0,5310012 ## 8 168 0,3336543 0,2144865 0,4511787 plot(KM9,col=c(1,2,3)) 21.11 Gamma library(flexsurv) KM10=flexsurvreg(Surv(tempo,status)~trat,dist=&quot;gamma&quot;) summary(KM10) ## trat=T1 ## time est lcl ucl ## 1 10 0,790201487 0,713854693 0,85515784 ## 2 24 0,537681788 0,437350245 0,63595850 ## 3 48 0,267748022 0,173305674 0,37248988 ## 4 72 0,130741530 0,066402949 0,21734900 ## 5 96 0,063206831 0,025496912 0,12516701 ## 6 120 0,030369861 0,009439586 0,07224016 ## 7 144 0,014531118 0,003421212 0,04126515 ## 8 168 0,006931519 0,001233350 0,02393340 ## ## trat=T2 ## time est lcl ucl ## 1 10 0,9055576 0,85734495 0,9460262 ## 2 24 0,7671054 0,68472256 0,8380858 ## 3 48 0,5650288 0,46266594 0,6617095 ## 4 72 0,4110387 0,29804997 0,5192618 ## 5 96 0,2969771 0,18699031 0,4049966 ## 6 120 0,2136179 0,11913912 0,3143148 ## 7 144 0,1531754 0,07570230 0,2441103 ## 8 168 0,1095770 0,04621822 0,1904136 ## ## trat=T3 ## time est lcl ucl ## 1 10 0,9552715 0,9241731 0,9760870 ## 2 24 0,8838874 0,8273276 0,9278808 ## 3 48 0,7645536 0,6810011 0,8355302 ## 4 72 0,6563859 0,5540759 0,7455587 ## 5 96 0,5610497 0,4464963 0,6624342 ## 6 120 0,4781342 0,3573874 0,5871324 ## 7 144 0,4065841 0,2851384 0,5189962 ## 8 168 0,3451603 0,2266967 0,4603263 plot(KM10,col=c(1,2,3)) 21.12 Método semi-paramétrico de Cox Serve para um modelo de regressão de riscos proporcionais de Cox. Variáveis dependentes do tempo, estratos dependentes do tempo, vários eventos por assunto e outras extensões são incorporadas usando a formulação do processo de contagem de Andersen e Gill. Reference: Andersen, P. and Gill, R. (1982). Cox’s regression model for counting processes, a large sample study. Annals of Statistics 10, 1100-1120. 21.12.1 Sem considerar tratamentos KM &lt;- coxph(Surv(tempo,status) ~ 1) summary(KM) ## Call: coxph(formula = Surv(tempo, status) ~ 1) ## ## Null model ## log likelihood= -538,6621 ## n= 144 21.12.2 Considerando tratamentos KM8 &lt;- coxph(Surv(tempo,status) ~ strata(trat),data=dados) summary(KM8) ## Call: coxph(formula = Surv(tempo, status) ~ strata(trat), data = dados) ## ## Null model ## log likelihood= -394,6821 ## n= 144 library(ggfortify) autoplot(survfit(KM8),conf.int = F)+theme_classic() 21.13 Modelo de riscos proporcionais de COX Mostra as taxas de risco (HR) derivadas do modelo para todas as covariáveis incluídas na fórmula coxph. Resumidamente, uma FC&gt; 1 indica um risco aumentado de morte (de acordo com a definição de h(t)) se uma condição específica for atendida por um paciente. Uma FC &lt;1, por outro lado, indica uma diminuição do risco. 21.13.1 Considerando trat library(forestmodel) colnames(dados)=c(&quot;Treatments&quot;,&quot;tempo&quot;,&quot;status&quot;) fit.coxph &lt;- coxph(Surv(tempo, status) ~ Treatments, data = dados) #ggforest(fit.coxph, data = dados) print(forest_model(fit.coxph, limits=log( c(0.05, 5)))) 21.14 Critério de inferência de Akaike library(car) AIC(KM2) # exponencial ## [1] 1334,477 AIC(KM3) # normal ## [1] 1433,069 AIC(KM4) # logistico ## [1] 1436,639 AIC(KM5) # lognormal ## [1] 1338,744 AIC(KM6) # loglogistic ## [1] 1346,328 AIC(KM7) # weibull ## [1] 1334,844 AIC(KM8) # coxph ## [1] 789,3642 AIC(KM9) # Gompertz ## [1] 1331,275 21.15 Resíduo residuo2 &lt;- residuals(KM2, type = &quot;deviance&quot;) g2=ggplot(data = dados, mapping = aes(x = tempo, y = residuo2)) + geom_point() + labs(title=&quot;Exponential&quot;)+ geom_smooth() + theme_bw() + theme(legend.key = element_blank()) residuo3 &lt;- residuals(KM3, type = &quot;deviance&quot;) g3=ggplot(data = dados, mapping = aes(x = tempo, y = residuo3)) + geom_point() + labs(title=&quot;Normal&quot;)+ geom_smooth() + theme_bw() + theme(legend.key = element_blank()) residuo4 &lt;- residuals(KM4, type = &quot;deviance&quot;) g4=ggplot(data = dados, mapping = aes(x = tempo, y = residuo4)) + geom_point() + labs(title=&quot;Logístico&quot;)+ geom_smooth() + theme_bw() + theme(legend.key = element_blank()) residuo5 &lt;- residuals(KM5, type = &quot;deviance&quot;) g5=ggplot(data = dados, mapping = aes(x = tempo, y = residuo5)) + geom_point() + labs(title=&quot;lognormal&quot;)+ geom_smooth() + theme_bw() + theme(legend.key = element_blank()) residuo6 &lt;- residuals(KM6, type = &quot;deviance&quot;) g6=ggplot(data = dados, mapping = aes(x = tempo, y = residuo6)) + geom_point() + labs(title=&quot;loglogistico&quot;)+ geom_smooth() + theme_bw() + theme(legend.key = element_blank()) residuo7 &lt;- residuals(KM7, type = &quot;deviance&quot;) g7=ggplot(data = dados, mapping = aes(x = tempo, y = residuo7)) + geom_point() + labs(title=&quot;weibull&quot;)+ geom_smooth() + theme_bw() + theme(legend.key = element_blank()) residuo8 &lt;- residuals(KM8, type = &quot;deviance&quot;) g8=ggplot(data = dados, mapping = aes(x = tempo, y = residuo8)) + geom_point() + labs(title=&quot;coxph&quot;)+ geom_smooth() + theme_bw() + theme(legend.key = element_blank()) library(gridExtra) grid.arrange(g2,g3,g4,g5,g6,g7,g8,ncol=4) "],
["modelo-linear-generalizado.html", " 22 Modelo linear generalizado 22.1 Conjunto de dados 22.2 Modelo linear generalizado 22.3 Análise de deviance 22.4 Diagnóstico 22.5 Halfnormaplot 22.6 Constrastes 22.7 Retornando a função logistica 22.8 Supondo que não sabemos o total de cada repetição 22.9 Análise de deviance 22.10 Diagnóstico 22.11 Halfnormaplot 22.12 Constrastes 22.13 Retornando a função logistica 22.14 Analisando sobredispersão 22.15 Análise de deviance 22.16 Diagnóstico 22.17 Halfnormaplot 22.18 Constrastes 22.19 Retornando a função logistica 22.20 Distribuição quasibinomial 22.21 Análise de deviance 22.22 Diagnóstico 22.23 Halfnormaplot 22.24 Constrastes 22.25 Retornando a função logistica 22.26 Fatorial qualitativo e quantitativo 22.27 Modelo 22.28 Deviance 22.29 Teste de comparação 22.30 Regressão 22.31 Dividindo o conjunto de dados 22.32 modelo para T1 22.33 modelo para T2 22.34 Gráfico", " 22 Modelo linear generalizado 22.1 Conjunto de dados Considera um conjunto de dados simulados de germinação com oito repetições e quatro tratamento qualitativos. Conforme a regra de análise de sementes, em um teste de germinação é estabelecido a quantidade mínima de 50 sementes por rolo de papel. Logo, sabemos que a quantidade máxima de cada repetição e de 50 sementes. trat=rep(paste(&quot;T&quot;,1:4),e=8) germ=c(33,35,34,30,38,30,37,30,36,38,34,38,38,38,35,35,30,15,31,17,25,24,24,18,27,20,28,35,30,30,30,29) 22.2 Modelo linear generalizado No R, podemos realizar a entrada dos dados de duas formas. Pela proporção ou por dados dicotomizados (Respostas do tipo 0 ou 1). Nosso exemplo usaremos pela proporção. modelo=glm(cbind(germ,50-germ)~trat, family=binomial) Explicação: germ é nossa resposta, ou seja, total de sementes germinadas (ou podemos chamar de total de sucessos na repetição). O valor 50 indica o total de observações na repetição (Deve ser conhecido). trat é nossa variável explicativa qualitativa, binomial é a distrbuição provável que estamos considerando. 22.3 Análise de deviance summary(modelo) ## ## Call: ## glm(formula = cbind(germ, 50 - germ) ~ trat, family = binomial) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -2,4488 -0,5500 0,2359 0,4838 2,2701 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0,6969 0,1061 6,566 5,16e-11 *** ## tratT 2 0,2977 0,1548 1,924 0,05437 . ## tratT 3 -0,8572 0,1460 -5,870 4,36e-09 *** ## tratT 4 -0,4048 0,1466 -2,762 0,00574 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 108,818 on 31 degrees of freedom ## Residual deviance: 38,676 on 28 degrees of freedom ## AIC: 182,75 ## ## Number of Fisher Scoring iterations: 3 anova(modelo, test=&quot;Chisq&quot;) ## Analysis of Deviance Table ## ## Model: binomial, link: logit ## ## Response: cbind(germ, 50 - germ) ## ## Terms added sequentially (first to last) ## ## ## Df Deviance Resid. Df Resid. Dev Pr(&gt;Chi) ## NULL 31 108,818 ## trat 3 70,142 28 38,676 3,979e-15 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 22.4 Diagnóstico par(mfrow=c(2,2)) plot(modelo) 22.5 Halfnormaplot hnp::hnp(modelo, print.on=T) ## Binomial model 22.6 Constrastes library(emmeans) media=emmeans(modelo,~trat) 22.7 Retornando a função logistica medfin=regrid(media) library(multcompView) library(multcomp) cld(medfin, alpha=0.05, Letters=letters, decreasing=FALSE, adjust=&quot;tukey&quot;) ## trat prob SE df asymp.LCL asymp.UCL .group ## T 3 0,460 0,0249 Inf 0,398 0,522 a ## T 4 0,573 0,0247 Inf 0,511 0,634 b ## T 1 0,667 0,0236 Inf 0,609 0,726 c ## T 2 0,730 0,0222 Inf 0,675 0,785 c ## ## Confidence level used: 0,95 ## Conf-level adjustment: sidak method for 4 estimates ## P value adjustment: tukey method for comparing a family of 4 estimates ## significance level used: alpha = 0,05 22.8 Supondo que não sabemos o total de cada repetição Nesse caso, vamos optar pela distribuição poisson modelo=glm(germ~trat, family=poisson) 22.9 Análise de deviance summary(modelo) ## ## Call: ## glm(formula = germ ~ trat, family = poisson) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1,7823 -0,3347 0,1574 0,2550 1,5832 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 3,50781 0,06120 57,318 &lt; 2e-16 *** ## tratT 2 0,08951 0,08468 1,057 0,290496 ## tratT 3 -0,37231 0,09581 -3,886 0,000102 *** ## tratT 4 -0,15353 0,09007 -1,705 0,088274 . ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## (Dispersion parameter for poisson family taken to be 1) ## ## Null deviance: 46,061 on 31 degrees of freedom ## Residual deviance: 18,017 on 28 degrees of freedom ## AIC: 193,41 ## ## Number of Fisher Scoring iterations: 4 anova(modelo, test=&quot;Chisq&quot;) ## Analysis of Deviance Table ## ## Model: poisson, link: log ## ## Response: germ ## ## Terms added sequentially (first to last) ## ## ## Df Deviance Resid. Df Resid. Dev Pr(&gt;Chi) ## NULL 31 46,061 ## trat 3 28,045 28 18,017 3,555e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 22.10 Diagnóstico par(mfrow=c(2,2)) plot(modelo) 22.11 Halfnormaplot hnp::hnp(modelo, print.on=T) ## Poisson model 22.12 Constrastes library(emmeans) media=emmeans(modelo,~trat) 22.13 Retornando a função logistica medfin=regrid(media) library(multcompView) library(multcomp) cld(medfin, alpha=0.05, Letters=letters, decreasing=FALSE, adjust=&quot;tukey&quot;) ## trat rate SE df asymp.LCL asymp.UCL .group ## T 3 23,0 1,70 Inf 18,8 27,2 a ## T 4 28,6 1,89 Inf 23,9 33,3 ab ## T 1 33,4 2,04 Inf 28,3 38,5 bc ## T 2 36,5 2,14 Inf 31,2 41,8 c ## ## Confidence level used: 0,95 ## Conf-level adjustment: sidak method for 4 estimates ## P value adjustment: tukey method for comparing a family of 4 estimates ## significance level used: alpha = 0,05 22.14 Analisando sobredispersão library(AER) dispersiontest(modelo, trafo=1) ## ## Overdispersion test ## ## data: modelo ## z = -2,8129, p-value = 0,9975 ## alternative hypothesis: true alpha is greater than 0 ## sample estimates: ## alpha ## -0,4488216 ## se for menor que 0,01 há sbredispersão, nesse caso usar quasipoisson Caso fosse menor que 0,01 ou 0,05, podemos testar a distribuição quasipoisson. Vamos treinar, ainda que não seja necessário. modelo=glm(germ~trat, family=quasipoisson) 22.15 Análise de deviance summary(modelo) ## ## Call: ## glm(formula = germ ~ trat, family = quasipoisson) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1,7823 -0,3347 0,1574 0,2550 1,5832 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3,50781 0,04857 72,219 &lt; 2e-16 *** ## tratT 2 0,08951 0,06720 1,332 0,1937 ## tratT 3 -0,37231 0,07604 -4,896 3,69e-05 *** ## tratT 4 -0,15353 0,07148 -2,148 0,0405 * ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## (Dispersion parameter for quasipoisson family taken to be 0,6299182) ## ## Null deviance: 46,061 on 31 degrees of freedom ## Residual deviance: 18,017 on 28 degrees of freedom ## AIC: NA ## ## Number of Fisher Scoring iterations: 4 anova(modelo, test=&quot;Chisq&quot;) ## Analysis of Deviance Table ## ## Model: quasipoisson, link: log ## ## Response: germ ## ## Terms added sequentially (first to last) ## ## ## Df Deviance Resid. Df Resid. Dev Pr(&gt;Chi) ## NULL 31 46,061 ## trat 3 28,045 28 18,017 1,17e-09 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 22.16 Diagnóstico par(mfrow=c(2,2)) plot(modelo) 22.17 Halfnormaplot hnp::hnp(modelo, print.on=T) ## Quasi-Poisson model 22.18 Constrastes library(emmeans) media=emmeans(modelo,~trat) 22.19 Retornando a função logistica medfin=regrid(media) library(multcompView) library(multcomp) cld(medfin, alpha=0.05, Letters=letters, decreasing=FALSE, adjust=&quot;tukey&quot;) ## trat rate SE df asymp.LCL asymp.UCL .group ## T 3 23,0 1,35 Inf 19,6 26,4 a ## T 4 28,6 1,50 Inf 24,9 32,4 b ## T 1 33,4 1,62 Inf 29,3 37,4 bc ## T 2 36,5 1,70 Inf 32,3 40,7 c ## ## Confidence level used: 0,95 ## Conf-level adjustment: sidak method for 4 estimates ## P value adjustment: tukey method for comparing a family of 4 estimates ## significance level used: alpha = 0,05 22.20 Distribuição quasibinomial quasibin&lt;-glm(cbind(germ,50-germ)~trat, family = quasibinomial) 22.21 Análise de deviance summary(modelo) ## ## Call: ## glm(formula = germ ~ trat, family = quasipoisson) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1,7823 -0,3347 0,1574 0,2550 1,5832 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3,50781 0,04857 72,219 &lt; 2e-16 *** ## tratT 2 0,08951 0,06720 1,332 0,1937 ## tratT 3 -0,37231 0,07604 -4,896 3,69e-05 *** ## tratT 4 -0,15353 0,07148 -2,148 0,0405 * ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## (Dispersion parameter for quasipoisson family taken to be 0,6299182) ## ## Null deviance: 46,061 on 31 degrees of freedom ## Residual deviance: 18,017 on 28 degrees of freedom ## AIC: NA ## ## Number of Fisher Scoring iterations: 4 anova(modelo, test=&quot;Chisq&quot;) ## Analysis of Deviance Table ## ## Model: quasipoisson, link: log ## ## Response: germ ## ## Terms added sequentially (first to last) ## ## ## Df Deviance Resid. Df Resid. Dev Pr(&gt;Chi) ## NULL 31 46,061 ## trat 3 28,045 28 18,017 1,17e-09 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 22.22 Diagnóstico par(mfrow=c(2,2)) plot(modelo) 22.23 Halfnormaplot hnp::hnp(modelo, print.on=T) ## Quasi-Poisson model 22.24 Constrastes library(emmeans) media=emmeans(modelo,~trat) summary(pairs(media), type = &quot;response&quot;) ## contrast ratio SE df z.ratio p.value ## T 1 / T 2 0,914 0,0615 Inf -1,332 0,5425 ## T 1 / T 3 1,451 0,1103 Inf 4,896 0,0000 ## T 1 / T 4 1,166 0,0833 Inf 2,148 0,1382 ## T 2 / T 3 1,587 0,1186 Inf 6,182 0,0000 ## T 2 / T 4 1,275 0,0893 Inf 3,469 0,0029 ## T 3 / T 4 0,803 0,0631 Inf -2,784 0,0275 ## ## P value adjustment: tukey method for comparing a family of 4 estimates ## Tests are performed on the log scale 22.25 Retornando a função logistica medfin=regrid(media) library(multcompView) library(multcomp) cld(medfin, alpha=0.05, Letters=letters, decreasing=FALSE, adjust=&quot;tukey&quot;) ## trat rate SE df asymp.LCL asymp.UCL .group ## T 3 23,0 1,35 Inf 19,6 26,4 a ## T 4 28,6 1,50 Inf 24,9 32,4 b ## T 1 33,4 1,62 Inf 29,3 37,4 bc ## T 2 36,5 1,70 Inf 32,3 40,7 c ## ## Confidence level used: 0,95 ## Conf-level adjustment: sidak method for 4 estimates ## P value adjustment: tukey method for comparing a family of 4 estimates ## significance level used: alpha = 0,05 22.26 Fatorial qualitativo e quantitativo Supondo um outro exemplo de um experimento em esquema fatorial 2 x 5, em que o primeiro fator e qualitativo e o segundo fator quantitativo com 5 doses (2, 4, 6, 8, 10) e três repetições cada. Total de semenetes e conhecido e o valor e 30. resp=c(0,0,0,3,3,2,6,6,5,17,18,14,25,26,23, 0,1,0,1,1,2,15,14,15,15,16,16,20,20,19) f1=rep(c(&quot;T1&quot;,&quot;T2&quot;),e=15) ## fator qualitativo d=rep(c(2,4,6,8,10),e=3,2) ## dose como numerico D=factor(d) ## considerando dose como fator 22.27 Modelo Vamos considerar os dois fatores como qualitativos bin=glm(cbind(resp,30-resp)~f1*D, family = binomial) 22.28 Deviance summary(bin) ## ## Call: ## glm(formula = cbind(resp, 30 - resp) ~ f1 * D, family = binomial) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -0,8532 -0,2951 0,1217 0,1590 0,9375 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -23,14 6757,51 -0,003 0,997 ## f1T2 18,65 6757,51 0,003 0,998 ## D4 20,81 6757,51 0,003 0,998 ## D6 21,68 6757,51 0,003 0,997 ## D8 23,31 6757,51 0,003 0,997 ## D10 24,67 6757,51 0,004 0,997 ## f1T2:D4 -19,39 6757,51 -0,003 0,998 ## f1T2:D6 -17,24 6757,51 -0,003 0,998 ## f1T2:D8 -18,74 6757,51 -0,003 0,998 ## f1T2:D10 -19,54 6757,51 -0,003 0,998 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 397,0255 on 29 degrees of freedom ## Residual deviance: 5,6398 on 20 degrees of freedom ## AIC: 108,6 ## ## Number of Fisher Scoring iterations: 19 anova(bin, test=&quot;Chisq&quot;) ## Analysis of Deviance Table ## ## Model: binomial, link: logit ## ## Response: cbind(resp, 30 - resp) ## ## Terms added sequentially (first to last) ## ## ## Df Deviance Resid. Df Resid. Dev Pr(&gt;Chi) ## NULL 29 397,03 ## f1 1 0,24 28 396,78 0,6215 ## D 4 363,46 24 33,33 &lt; 2,2e-16 *** ## f1:D 4 27,69 20 5,64 1,443e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 referencia &lt;- ref_grid(bin) referencia ## Aqui deve aparecer os niveis dos fatores, se dose so aparecer 1, está errado ## &#39;emmGrid&#39; object with variables: ## f1 = T1, T2 ## D = 2, 4, 6, 8, 10 ## Transformation: &quot;logit&quot; 22.29 Teste de comparação Se não fosse um fator quantitativo, podemos fazer assim: media &lt;- emmeans(bin, ~f1|D) medfin&lt;-regrid(media) cld(medfin, alpha=0.05, Letters=letters, adjust=&quot;tukey&quot;) ## D = 2: ## f1 prob SE df asymp.LCL asymp.UCL .group ## T1 0,0000 6,00e-07 Inf -1,40e-06 1,40e-06 a ## T2 0,0111 1,10e-02 Inf -1,36e-02 3,58e-02 a ## ## D = 4: ## f1 prob SE df asymp.LCL asymp.UCL .group ## T2 0,0444 2,17e-02 Inf -4,14e-03 9,30e-02 a ## T1 0,0889 3,00e-02 Inf 2,18e-02 1,56e-01 a ## ## D = 6: ## f1 prob SE df asymp.LCL asymp.UCL .group ## T1 0,1889 4,13e-02 Inf 9,66e-02 2,81e-01 a ## T2 0,4889 5,27e-02 Inf 3,71e-01 6,07e-01 b ## ## D = 8: ## f1 prob SE df asymp.LCL asymp.UCL .group ## T2 0,5222 5,27e-02 Inf 4,04e-01 6,40e-01 a ## T1 0,5444 5,25e-02 Inf 4,27e-01 6,62e-01 a ## ## D = 10: ## f1 prob SE df asymp.LCL asymp.UCL .group ## T2 0,6556 5,01e-02 Inf 5,44e-01 7,68e-01 a ## T1 0,8222 4,03e-02 Inf 7,32e-01 9,12e-01 b ## ## Confidence level used: 0,95 ## Conf-level adjustment: sidak method for 2 estimates ## significance level used: alpha = 0,05 media &lt;- emmeans(bin, ~D|f1) medfin&lt;-regrid(media) cld(medfin, alpha=0.05, Letters=letters, adjust=&quot;tukey&quot;) ## f1 = T1: ## D prob SE df asymp.LCL asymp.UCL .group ## 2 0,0000 6,00e-07 Inf -1,60e-06 1,60e-06 a ## 4 0,0889 3,00e-02 Inf 1,18e-02 1,66e-01 b ## 6 0,1889 4,13e-02 Inf 8,29e-02 2,95e-01 b ## 8 0,5444 5,25e-02 Inf 4,10e-01 6,79e-01 c ## 10 0,8222 4,03e-02 Inf 7,19e-01 9,26e-01 d ## ## f1 = T2: ## D prob SE df asymp.LCL asymp.UCL .group ## 2 0,0111 1,10e-02 Inf -1,73e-02 3,95e-02 a ## 4 0,0444 2,17e-02 Inf -1,14e-02 1,00e-01 a ## 6 0,4889 5,27e-02 Inf 3,54e-01 6,24e-01 b ## 8 0,5222 5,27e-02 Inf 3,87e-01 6,57e-01 b ## 10 0,6556 5,01e-02 Inf 5,27e-01 7,84e-01 b ## ## Confidence level used: 0,95 ## Conf-level adjustment: sidak method for 5 estimates ## P value adjustment: tukey method for comparing a family of 5 estimates ## significance level used: alpha = 0,05 22.30 Regressão Como há interação entre os fatores, necessitamos construir duas curvas, vejamos: 22.31 Dividindo o conjunto de dados resp1=resp[1:15] ## resposta de T1, nesse caso as observações de T1 estão na posição de 1 a 15 resp2=resp[16:30] ## resposta de T2, nesse caso as observações de T2 estão na posição de 16 a 30 d=d[1:15] ## cortando dose, nesse caso somente uma vez é necessário 22.32 modelo para T1 bin1=glm(cbind(resp1,30-resp1)~d, family = binomial) summary(bin1) ## ## Call: ## glm(formula = cbind(resp1, 30 - resp1) ~ d, family = binomial) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -0,9384 -0,7855 -0,1458 0,4803 0,8687 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -5,66100 0,51900 -10,91 &lt;2e-16 *** ## d 0,72347 0,06751 10,72 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 223,1818 on 14 degrees of freedom ## Residual deviance: 6,8923 on 13 degrees of freedom ## AIC: 50,895 ## ## Number of Fisher Scoring iterations: 4 22.33 modelo para T2 bin2=glm(cbind(resp2,30-resp2)~d, family = binomial) summary(bin2) ## ## Call: ## glm(formula = cbind(resp2, 30 - resp2) ~ d, family = binomial) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1,8205 -1,5467 -0,9111 0,1884 2,4892 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -3,89248 0,37250 -10,449 &lt;2e-16 *** ## d 0,49464 0,05016 9,862 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0,001 &#39;**&#39; 0,01 &#39;*&#39; 0,05 &#39;.&#39; 0,1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 173,600 on 14 degrees of freedom ## Residual deviance: 34,827 on 13 degrees of freedom ## AIC: 81,781 ## ## Number of Fisher Scoring iterations: 5 22.34 Gráfico 22.34.1 Calculando vetores med1=tapply(resp1/30, d, mean) med2=tapply(resp2/30, d, mean) DOSE=c(2,4,6,8,10) 22.34.2 Gráfico final plot(med1~DOSE,xlab=&quot;Dose(mg/L)&quot;,ylab=&quot;Probabilidade&quot;) points(med2~DOSE,pch=16,col=&quot;darkblue&quot;) curve(predict(bin1,data.frame(d=x),type=&quot;resp&quot;),add=TRUE) ## curva de T1 ##points(d,fitted(bin1),pch=20) curve(predict(bin2,data.frame(d=x),type=&quot;resp&quot;),add=TRUE, lty=2,col=&quot;darkblue&quot;) ## Curva de T2 "]
]
